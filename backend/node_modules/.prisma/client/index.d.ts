
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model Batch
 * 
 */
export type Batch = $Result.DefaultSelection<Prisma.$BatchPayload>
/**
 * Model Announcement
 * 
 */
export type Announcement = $Result.DefaultSelection<Prisma.$AnnouncementPayload>
/**
 * Model LessonComment
 * 
 */
export type LessonComment = $Result.DefaultSelection<Prisma.$LessonCommentPayload>
/**
 * Model Module
 * 
 */
export type Module = $Result.DefaultSelection<Prisma.$ModulePayload>
/**
 * Model Lesson
 * 
 */
export type Lesson = $Result.DefaultSelection<Prisma.$LessonPayload>
/**
 * Model Quiz
 * 
 */
export type Quiz = $Result.DefaultSelection<Prisma.$QuizPayload>
/**
 * Model AssignmentSubmission
 * 
 */
export type AssignmentSubmission = $Result.DefaultSelection<Prisma.$AssignmentSubmissionPayload>
/**
 * Model Enrollment
 * 
 */
export type Enrollment = $Result.DefaultSelection<Prisma.$EnrollmentPayload>
/**
 * Model LessonProgress
 * 
 */
export type LessonProgress = $Result.DefaultSelection<Prisma.$LessonProgressPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Interview
 * 
 */
export type Interview = $Result.DefaultSelection<Prisma.$InterviewPayload>
/**
 * Model InterviewQuestion
 * 
 */
export type InterviewQuestion = $Result.DefaultSelection<Prisma.$InterviewQuestionPayload>
/**
 * Model InterviewResponse
 * 
 */
export type InterviewResponse = $Result.DefaultSelection<Prisma.$InterviewResponsePayload>
/**
 * Model InterviewEvaluation
 * 
 */
export type InterviewEvaluation = $Result.DefaultSelection<Prisma.$InterviewEvaluationPayload>
/**
 * Model Avatar
 * 
 */
export type Avatar = $Result.DefaultSelection<Prisma.$AvatarPayload>
/**
 * Model KnowledgeBase
 * 
 */
export type KnowledgeBase = $Result.DefaultSelection<Prisma.$KnowledgeBasePayload>
/**
 * Model SystemPrompt
 * 
 */
export type SystemPrompt = $Result.DefaultSelection<Prisma.$SystemPromptPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model ForumCategory
 * 
 */
export type ForumCategory = $Result.DefaultSelection<Prisma.$ForumCategoryPayload>
/**
 * Model ForumPost
 * 
 */
export type ForumPost = $Result.DefaultSelection<Prisma.$ForumPostPayload>
/**
 * Model ForumComment
 * 
 */
export type ForumComment = $Result.DefaultSelection<Prisma.$ForumCommentPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Certificate
 * 
 */
export type Certificate = $Result.DefaultSelection<Prisma.$CertificatePayload>
/**
 * Model CertificateTemplate
 * 
 */
export type CertificateTemplate = $Result.DefaultSelection<Prisma.$CertificateTemplatePayload>
/**
 * Model CertificateSettings
 * 
 */
export type CertificateSettings = $Result.DefaultSelection<Prisma.$CertificateSettingsPayload>
/**
 * Model AIProvider
 * 
 */
export type AIProvider = $Result.DefaultSelection<Prisma.$AIProviderPayload>
/**
 * Model AIUsageLog
 * 
 */
export type AIUsageLog = $Result.DefaultSelection<Prisma.$AIUsageLogPayload>
/**
 * Model VideoIntegration
 * 
 */
export type VideoIntegration = $Result.DefaultSelection<Prisma.$VideoIntegrationPayload>
/**
 * Model LiveClass
 * 
 */
export type LiveClass = $Result.DefaultSelection<Prisma.$LiveClassPayload>
/**
 * Model Lead
 * 
 */
export type Lead = $Result.DefaultSelection<Prisma.$LeadPayload>
/**
 * Model MarketingIntegration
 * 
 */
export type MarketingIntegration = $Result.DefaultSelection<Prisma.$MarketingIntegrationPayload>
/**
 * Model EmailIntegration
 * 
 */
export type EmailIntegration = $Result.DefaultSelection<Prisma.$EmailIntegrationPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model TaskComment
 * 
 */
export type TaskComment = $Result.DefaultSelection<Prisma.$TaskCommentPayload>
/**
 * Model BlogPost
 * 
 */
export type BlogPost = $Result.DefaultSelection<Prisma.$BlogPostPayload>
/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>
/**
 * Model TicketMessage
 * 
 */
export type TicketMessage = $Result.DefaultSelection<Prisma.$TicketMessagePayload>
/**
 * Model PaymentConfig
 * 
 */
export type PaymentConfig = $Result.DefaultSelection<Prisma.$PaymentConfigPayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model SystemSettings
 * 
 */
export type SystemSettings = $Result.DefaultSelection<Prisma.$SystemSettingsPayload>
/**
 * Model EmployerProfile
 * 
 */
export type EmployerProfile = $Result.DefaultSelection<Prisma.$EmployerProfilePayload>
/**
 * Model Job
 * 
 */
export type Job = $Result.DefaultSelection<Prisma.$JobPayload>
/**
 * Model JobApplication
 * 
 */
export type JobApplication = $Result.DefaultSelection<Prisma.$JobApplicationPayload>
/**
 * Model JobInterview
 * 
 */
export type JobInterview = $Result.DefaultSelection<Prisma.$JobInterviewPayload>
/**
 * Model EmailLog
 * 
 */
export type EmailLog = $Result.DefaultSelection<Prisma.$EmailLogPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model SavedFilter
 * 
 */
export type SavedFilter = $Result.DefaultSelection<Prisma.$SavedFilterPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  INSTRUCTOR: 'INSTRUCTOR',
  STUDENT: 'STUDENT',
  STAFF: 'STAFF',
  INSTITUTE_ADMIN: 'INSTITUTE_ADMIN',
  EMPLOYER: 'EMPLOYER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Difficulty: {
  BEGINNER: 'BEGINNER',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED'
};

export type Difficulty = (typeof Difficulty)[keyof typeof Difficulty]


export const CourseType: {
  RECORDED: 'RECORDED',
  LIVE: 'LIVE',
  HYBRID: 'HYBRID'
};

export type CourseType = (typeof CourseType)[keyof typeof CourseType]


export const PublishStatus: {
  DRAFT: 'DRAFT',
  IN_REVIEW: 'IN_REVIEW',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED'
};

export type PublishStatus = (typeof PublishStatus)[keyof typeof PublishStatus]


export const LessonType: {
  VIDEO: 'VIDEO',
  TEXT: 'TEXT',
  PDF: 'PDF',
  QUIZ: 'QUIZ',
  ASSIGNMENT: 'ASSIGNMENT',
  LIVE: 'LIVE'
};

export type LessonType = (typeof LessonType)[keyof typeof LessonType]


export const EnrollmentStatus: {
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  PAUSED: 'PAUSED',
  CANCELLED: 'CANCELLED'
};

export type EnrollmentStatus = (typeof EnrollmentStatus)[keyof typeof EnrollmentStatus]


export const InterviewStatus: {
  SCHEDULED: 'SCHEDULED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type InterviewStatus = (typeof InterviewStatus)[keyof typeof InterviewStatus]


export const QuestionType: {
  TECHNICAL: 'TECHNICAL',
  BEHAVIORAL: 'BEHAVIORAL',
  SITUATIONAL: 'SITUATIONAL',
  HR: 'HR',
  CODING: 'CODING'
};

export type QuestionType = (typeof QuestionType)[keyof typeof QuestionType]


export const KnowledgeStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED'
};

export type KnowledgeStatus = (typeof KnowledgeStatus)[keyof typeof KnowledgeStatus]


export const LiveClassStatus: {
  SCHEDULED: 'SCHEDULED',
  LIVE: 'LIVE',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type LiveClassStatus = (typeof LiveClassStatus)[keyof typeof LiveClassStatus]


export const LeadStatus: {
  NEW: 'NEW',
  CONTACTED: 'CONTACTED',
  INTERESTED: 'INTERESTED',
  QUALIFIED: 'QUALIFIED',
  CONVERTED: 'CONVERTED',
  LOST: 'LOST'
};

export type LeadStatus = (typeof LeadStatus)[keyof typeof LeadStatus]


export const BlogStatus: {
  DRAFT: 'DRAFT',
  IN_REVIEW: 'IN_REVIEW',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED'
};

export type BlogStatus = (typeof BlogStatus)[keyof typeof BlogStatus]


export const TaskStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  OVERDUE: 'OVERDUE'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const TicketStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type TicketStatus = (typeof TicketStatus)[keyof typeof TicketStatus]


export const TicketPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type TicketPriority = (typeof TicketPriority)[keyof typeof TicketPriority]


export const TicketCategory: {
  GENERAL: 'GENERAL',
  TECHNICAL: 'TECHNICAL',
  BILLING: 'BILLING',
  COURSE_CONTENT: 'COURSE_CONTENT',
  FEATURE_REQUEST: 'FEATURE_REQUEST'
};

export type TicketCategory = (typeof TicketCategory)[keyof typeof TicketCategory]


export const Gateway: {
  RAZORPAY: 'RAZORPAY',
  STRIPE: 'STRIPE',
  NONE: 'NONE'
};

export type Gateway = (typeof Gateway)[keyof typeof Gateway]


export const EmployerStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type EmployerStatus = (typeof EmployerStatus)[keyof typeof EmployerStatus]


export const JobType: {
  FULL_TIME: 'FULL_TIME',
  PART_TIME: 'PART_TIME',
  INTERNSHIP: 'INTERNSHIP',
  CONTRACT: 'CONTRACT',
  FREELANCE: 'FREELANCE'
};

export type JobType = (typeof JobType)[keyof typeof JobType]


export const CandidateSource: {
  INTERNAL: 'INTERNAL',
  EXTERNAL: 'EXTERNAL'
};

export type CandidateSource = (typeof CandidateSource)[keyof typeof CandidateSource]


export const JobStatus: {
  DRAFT: 'DRAFT',
  OPEN: 'OPEN',
  PUBLISHED: 'PUBLISHED',
  PAUSED: 'PAUSED',
  CLOSED: 'CLOSED',
  ARCHIVED: 'ARCHIVED'
};

export type JobStatus = (typeof JobStatus)[keyof typeof JobStatus]


export const ApplicationStatus: {
  APPLIED: 'APPLIED',
  VIEWED: 'VIEWED',
  SCREENED: 'SCREENED',
  SHORTLISTED: 'SHORTLISTED',
  INTERVIEW_PENDING: 'INTERVIEW_PENDING',
  INTERVIEW_SCHEDULED: 'INTERVIEW_SCHEDULED',
  INTERVIEWED: 'INTERVIEWED',
  INTERVIEW_COMPLETED: 'INTERVIEW_COMPLETED',
  SELECTED: 'SELECTED',
  APPOINTED: 'APPOINTED',
  HIRED: 'HIRED',
  REJECTED: 'REJECTED',
  REVIEWING: 'REVIEWING'
};

export type ApplicationStatus = (typeof ApplicationStatus)[keyof typeof ApplicationStatus]


export const InterviewRoundType: {
  SCREENING: 'SCREENING',
  TECHNICAL: 'TECHNICAL',
  MANAGERIAL: 'MANAGERIAL',
  HR: 'HR',
  FINAL: 'FINAL',
  OTHER: 'OTHER'
};

export type InterviewRoundType = (typeof InterviewRoundType)[keyof typeof InterviewRoundType]


export const InterviewResult: {
  PASSED: 'PASSED',
  FAILED: 'FAILED',
  ON_HOLD: 'ON_HOLD'
};

export type InterviewResult = (typeof InterviewResult)[keyof typeof InterviewResult]


export const EmailStatus: {
  SENT: 'SENT',
  FAILED: 'FAILED',
  QUEUED: 'QUEUED'
};

export type EmailStatus = (typeof EmailStatus)[keyof typeof EmailStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Difficulty = $Enums.Difficulty

export const Difficulty: typeof $Enums.Difficulty

export type CourseType = $Enums.CourseType

export const CourseType: typeof $Enums.CourseType

export type PublishStatus = $Enums.PublishStatus

export const PublishStatus: typeof $Enums.PublishStatus

export type LessonType = $Enums.LessonType

export const LessonType: typeof $Enums.LessonType

export type EnrollmentStatus = $Enums.EnrollmentStatus

export const EnrollmentStatus: typeof $Enums.EnrollmentStatus

export type InterviewStatus = $Enums.InterviewStatus

export const InterviewStatus: typeof $Enums.InterviewStatus

export type QuestionType = $Enums.QuestionType

export const QuestionType: typeof $Enums.QuestionType

export type KnowledgeStatus = $Enums.KnowledgeStatus

export const KnowledgeStatus: typeof $Enums.KnowledgeStatus

export type LiveClassStatus = $Enums.LiveClassStatus

export const LiveClassStatus: typeof $Enums.LiveClassStatus

export type LeadStatus = $Enums.LeadStatus

export const LeadStatus: typeof $Enums.LeadStatus

export type BlogStatus = $Enums.BlogStatus

export const BlogStatus: typeof $Enums.BlogStatus

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type TicketStatus = $Enums.TicketStatus

export const TicketStatus: typeof $Enums.TicketStatus

export type TicketPriority = $Enums.TicketPriority

export const TicketPriority: typeof $Enums.TicketPriority

export type TicketCategory = $Enums.TicketCategory

export const TicketCategory: typeof $Enums.TicketCategory

export type Gateway = $Enums.Gateway

export const Gateway: typeof $Enums.Gateway

export type EmployerStatus = $Enums.EmployerStatus

export const EmployerStatus: typeof $Enums.EmployerStatus

export type JobType = $Enums.JobType

export const JobType: typeof $Enums.JobType

export type CandidateSource = $Enums.CandidateSource

export const CandidateSource: typeof $Enums.CandidateSource

export type JobStatus = $Enums.JobStatus

export const JobStatus: typeof $Enums.JobStatus

export type ApplicationStatus = $Enums.ApplicationStatus

export const ApplicationStatus: typeof $Enums.ApplicationStatus

export type InterviewRoundType = $Enums.InterviewRoundType

export const InterviewRoundType: typeof $Enums.InterviewRoundType

export type InterviewResult = $Enums.InterviewResult

export const InterviewResult: typeof $Enums.InterviewResult

export type EmailStatus = $Enums.EmailStatus

export const EmailStatus: typeof $Enums.EmailStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.batch`: Exposes CRUD operations for the **Batch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Batches
    * const batches = await prisma.batch.findMany()
    * ```
    */
  get batch(): Prisma.BatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcement`: Exposes CRUD operations for the **Announcement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcement.findMany()
    * ```
    */
  get announcement(): Prisma.AnnouncementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lessonComment`: Exposes CRUD operations for the **LessonComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LessonComments
    * const lessonComments = await prisma.lessonComment.findMany()
    * ```
    */
  get lessonComment(): Prisma.LessonCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.module`: Exposes CRUD operations for the **Module** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modules
    * const modules = await prisma.module.findMany()
    * ```
    */
  get module(): Prisma.ModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lesson`: Exposes CRUD operations for the **Lesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lesson.findMany()
    * ```
    */
  get lesson(): Prisma.LessonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quiz`: Exposes CRUD operations for the **Quiz** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quizzes
    * const quizzes = await prisma.quiz.findMany()
    * ```
    */
  get quiz(): Prisma.QuizDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assignmentSubmission`: Exposes CRUD operations for the **AssignmentSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssignmentSubmissions
    * const assignmentSubmissions = await prisma.assignmentSubmission.findMany()
    * ```
    */
  get assignmentSubmission(): Prisma.AssignmentSubmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enrollment`: Exposes CRUD operations for the **Enrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enrollments
    * const enrollments = await prisma.enrollment.findMany()
    * ```
    */
  get enrollment(): Prisma.EnrollmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lessonProgress`: Exposes CRUD operations for the **LessonProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LessonProgresses
    * const lessonProgresses = await prisma.lessonProgress.findMany()
    * ```
    */
  get lessonProgress(): Prisma.LessonProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interview`: Exposes CRUD operations for the **Interview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interviews
    * const interviews = await prisma.interview.findMany()
    * ```
    */
  get interview(): Prisma.InterviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interviewQuestion`: Exposes CRUD operations for the **InterviewQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterviewQuestions
    * const interviewQuestions = await prisma.interviewQuestion.findMany()
    * ```
    */
  get interviewQuestion(): Prisma.InterviewQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interviewResponse`: Exposes CRUD operations for the **InterviewResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterviewResponses
    * const interviewResponses = await prisma.interviewResponse.findMany()
    * ```
    */
  get interviewResponse(): Prisma.InterviewResponseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interviewEvaluation`: Exposes CRUD operations for the **InterviewEvaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterviewEvaluations
    * const interviewEvaluations = await prisma.interviewEvaluation.findMany()
    * ```
    */
  get interviewEvaluation(): Prisma.InterviewEvaluationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.avatar`: Exposes CRUD operations for the **Avatar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Avatars
    * const avatars = await prisma.avatar.findMany()
    * ```
    */
  get avatar(): Prisma.AvatarDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.knowledgeBase`: Exposes CRUD operations for the **KnowledgeBase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeBases
    * const knowledgeBases = await prisma.knowledgeBase.findMany()
    * ```
    */
  get knowledgeBase(): Prisma.KnowledgeBaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemPrompt`: Exposes CRUD operations for the **SystemPrompt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemPrompts
    * const systemPrompts = await prisma.systemPrompt.findMany()
    * ```
    */
  get systemPrompt(): Prisma.SystemPromptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.forumCategory`: Exposes CRUD operations for the **ForumCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumCategories
    * const forumCategories = await prisma.forumCategory.findMany()
    * ```
    */
  get forumCategory(): Prisma.ForumCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.forumPost`: Exposes CRUD operations for the **ForumPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumPosts
    * const forumPosts = await prisma.forumPost.findMany()
    * ```
    */
  get forumPost(): Prisma.ForumPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.forumComment`: Exposes CRUD operations for the **ForumComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumComments
    * const forumComments = await prisma.forumComment.findMany()
    * ```
    */
  get forumComment(): Prisma.ForumCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.certificate`: Exposes CRUD operations for the **Certificate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificates
    * const certificates = await prisma.certificate.findMany()
    * ```
    */
  get certificate(): Prisma.CertificateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.certificateTemplate`: Exposes CRUD operations for the **CertificateTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CertificateTemplates
    * const certificateTemplates = await prisma.certificateTemplate.findMany()
    * ```
    */
  get certificateTemplate(): Prisma.CertificateTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.certificateSettings`: Exposes CRUD operations for the **CertificateSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CertificateSettings
    * const certificateSettings = await prisma.certificateSettings.findMany()
    * ```
    */
  get certificateSettings(): Prisma.CertificateSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIProvider`: Exposes CRUD operations for the **AIProvider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIProviders
    * const aIProviders = await prisma.aIProvider.findMany()
    * ```
    */
  get aIProvider(): Prisma.AIProviderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIUsageLog`: Exposes CRUD operations for the **AIUsageLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIUsageLogs
    * const aIUsageLogs = await prisma.aIUsageLog.findMany()
    * ```
    */
  get aIUsageLog(): Prisma.AIUsageLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videoIntegration`: Exposes CRUD operations for the **VideoIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoIntegrations
    * const videoIntegrations = await prisma.videoIntegration.findMany()
    * ```
    */
  get videoIntegration(): Prisma.VideoIntegrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.liveClass`: Exposes CRUD operations for the **LiveClass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LiveClasses
    * const liveClasses = await prisma.liveClass.findMany()
    * ```
    */
  get liveClass(): Prisma.LiveClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **Lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.LeadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketingIntegration`: Exposes CRUD operations for the **MarketingIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketingIntegrations
    * const marketingIntegrations = await prisma.marketingIntegration.findMany()
    * ```
    */
  get marketingIntegration(): Prisma.MarketingIntegrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailIntegration`: Exposes CRUD operations for the **EmailIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailIntegrations
    * const emailIntegrations = await prisma.emailIntegration.findMany()
    * ```
    */
  get emailIntegration(): Prisma.EmailIntegrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskComment`: Exposes CRUD operations for the **TaskComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskComments
    * const taskComments = await prisma.taskComment.findMany()
    * ```
    */
  get taskComment(): Prisma.TaskCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogPost`: Exposes CRUD operations for the **BlogPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogPosts
    * const blogPosts = await prisma.blogPost.findMany()
    * ```
    */
  get blogPost(): Prisma.BlogPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketMessage`: Exposes CRUD operations for the **TicketMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketMessages
    * const ticketMessages = await prisma.ticketMessage.findMany()
    * ```
    */
  get ticketMessage(): Prisma.TicketMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentConfig`: Exposes CRUD operations for the **PaymentConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentConfigs
    * const paymentConfigs = await prisma.paymentConfig.findMany()
    * ```
    */
  get paymentConfig(): Prisma.PaymentConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSettings`: Exposes CRUD operations for the **SystemSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSettings.findMany()
    * ```
    */
  get systemSettings(): Prisma.SystemSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employerProfile`: Exposes CRUD operations for the **EmployerProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployerProfiles
    * const employerProfiles = await prisma.employerProfile.findMany()
    * ```
    */
  get employerProfile(): Prisma.EmployerProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job`: Exposes CRUD operations for the **Job** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.job.findMany()
    * ```
    */
  get job(): Prisma.JobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobApplication`: Exposes CRUD operations for the **JobApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobApplications
    * const jobApplications = await prisma.jobApplication.findMany()
    * ```
    */
  get jobApplication(): Prisma.JobApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobInterview`: Exposes CRUD operations for the **JobInterview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobInterviews
    * const jobInterviews = await prisma.jobInterview.findMany()
    * ```
    */
  get jobInterview(): Prisma.JobInterviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailLog`: Exposes CRUD operations for the **EmailLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailLogs
    * const emailLogs = await prisma.emailLog.findMany()
    * ```
    */
  get emailLog(): Prisma.EmailLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.savedFilter`: Exposes CRUD operations for the **SavedFilter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SavedFilters
    * const savedFilters = await prisma.savedFilter.findMany()
    * ```
    */
  get savedFilter(): Prisma.SavedFilterDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Course: 'Course',
    Batch: 'Batch',
    Announcement: 'Announcement',
    LessonComment: 'LessonComment',
    Module: 'Module',
    Lesson: 'Lesson',
    Quiz: 'Quiz',
    AssignmentSubmission: 'AssignmentSubmission',
    Enrollment: 'Enrollment',
    LessonProgress: 'LessonProgress',
    Review: 'Review',
    Interview: 'Interview',
    InterviewQuestion: 'InterviewQuestion',
    InterviewResponse: 'InterviewResponse',
    InterviewEvaluation: 'InterviewEvaluation',
    Avatar: 'Avatar',
    KnowledgeBase: 'KnowledgeBase',
    SystemPrompt: 'SystemPrompt',
    Payment: 'Payment',
    ForumCategory: 'ForumCategory',
    ForumPost: 'ForumPost',
    ForumComment: 'ForumComment',
    Conversation: 'Conversation',
    Message: 'Message',
    Certificate: 'Certificate',
    CertificateTemplate: 'CertificateTemplate',
    CertificateSettings: 'CertificateSettings',
    AIProvider: 'AIProvider',
    AIUsageLog: 'AIUsageLog',
    VideoIntegration: 'VideoIntegration',
    LiveClass: 'LiveClass',
    Lead: 'Lead',
    MarketingIntegration: 'MarketingIntegration',
    EmailIntegration: 'EmailIntegration',
    Task: 'Task',
    TaskComment: 'TaskComment',
    BlogPost: 'BlogPost',
    Ticket: 'Ticket',
    TicketMessage: 'TicketMessage',
    PaymentConfig: 'PaymentConfig',
    Expense: 'Expense',
    SystemSettings: 'SystemSettings',
    EmployerProfile: 'EmployerProfile',
    Job: 'Job',
    JobApplication: 'JobApplication',
    JobInterview: 'JobInterview',
    EmailLog: 'EmailLog',
    AuditLog: 'AuditLog',
    SavedFilter: 'SavedFilter'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "course" | "batch" | "announcement" | "lessonComment" | "module" | "lesson" | "quiz" | "assignmentSubmission" | "enrollment" | "lessonProgress" | "review" | "interview" | "interviewQuestion" | "interviewResponse" | "interviewEvaluation" | "avatar" | "knowledgeBase" | "systemPrompt" | "payment" | "forumCategory" | "forumPost" | "forumComment" | "conversation" | "message" | "certificate" | "certificateTemplate" | "certificateSettings" | "aIProvider" | "aIUsageLog" | "videoIntegration" | "liveClass" | "lead" | "marketingIntegration" | "emailIntegration" | "task" | "taskComment" | "blogPost" | "ticket" | "ticketMessage" | "paymentConfig" | "expense" | "systemSettings" | "employerProfile" | "job" | "jobApplication" | "jobInterview" | "emailLog" | "auditLog" | "savedFilter"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      Batch: {
        payload: Prisma.$BatchPayload<ExtArgs>
        fields: Prisma.BatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          findFirst: {
            args: Prisma.BatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          findMany: {
            args: Prisma.BatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          create: {
            args: Prisma.BatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          createMany: {
            args: Prisma.BatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          delete: {
            args: Prisma.BatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          update: {
            args: Prisma.BatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          deleteMany: {
            args: Prisma.BatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          upsert: {
            args: Prisma.BatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          aggregate: {
            args: Prisma.BatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatch>
          }
          groupBy: {
            args: Prisma.BatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BatchCountArgs<ExtArgs>
            result: $Utils.Optional<BatchCountAggregateOutputType> | number
          }
        }
      }
      Announcement: {
        payload: Prisma.$AnnouncementPayload<ExtArgs>
        fields: Prisma.AnnouncementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findFirst: {
            args: Prisma.AnnouncementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findMany: {
            args: Prisma.AnnouncementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          create: {
            args: Prisma.AnnouncementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          createMany: {
            args: Prisma.AnnouncementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnnouncementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          delete: {
            args: Prisma.AnnouncementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          update: {
            args: Prisma.AnnouncementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          deleteMany: {
            args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnnouncementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          upsert: {
            args: Prisma.AnnouncementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncement>
          }
          groupBy: {
            args: Prisma.AnnouncementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnouncementCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementCountAggregateOutputType> | number
          }
        }
      }
      LessonComment: {
        payload: Prisma.$LessonCommentPayload<ExtArgs>
        fields: Prisma.LessonCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentPayload>
          }
          findFirst: {
            args: Prisma.LessonCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentPayload>
          }
          findMany: {
            args: Prisma.LessonCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentPayload>[]
          }
          create: {
            args: Prisma.LessonCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentPayload>
          }
          createMany: {
            args: Prisma.LessonCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentPayload>[]
          }
          delete: {
            args: Prisma.LessonCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentPayload>
          }
          update: {
            args: Prisma.LessonCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentPayload>
          }
          deleteMany: {
            args: Prisma.LessonCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentPayload>[]
          }
          upsert: {
            args: Prisma.LessonCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCommentPayload>
          }
          aggregate: {
            args: Prisma.LessonCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLessonComment>
          }
          groupBy: {
            args: Prisma.LessonCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonCommentCountArgs<ExtArgs>
            result: $Utils.Optional<LessonCommentCountAggregateOutputType> | number
          }
        }
      }
      Module: {
        payload: Prisma.$ModulePayload<ExtArgs>
        fields: Prisma.ModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findFirst: {
            args: Prisma.ModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findMany: {
            args: Prisma.ModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          create: {
            args: Prisma.ModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          createMany: {
            args: Prisma.ModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          delete: {
            args: Prisma.ModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          update: {
            args: Prisma.ModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          deleteMany: {
            args: Prisma.ModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          upsert: {
            args: Prisma.ModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          aggregate: {
            args: Prisma.ModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModule>
          }
          groupBy: {
            args: Prisma.ModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleCountAggregateOutputType> | number
          }
        }
      }
      Lesson: {
        payload: Prisma.$LessonPayload<ExtArgs>
        fields: Prisma.LessonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findFirst: {
            args: Prisma.LessonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findMany: {
            args: Prisma.LessonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          create: {
            args: Prisma.LessonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          createMany: {
            args: Prisma.LessonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          delete: {
            args: Prisma.LessonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          update: {
            args: Prisma.LessonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          deleteMany: {
            args: Prisma.LessonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          upsert: {
            args: Prisma.LessonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          aggregate: {
            args: Prisma.LessonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLesson>
          }
          groupBy: {
            args: Prisma.LessonGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonCountArgs<ExtArgs>
            result: $Utils.Optional<LessonCountAggregateOutputType> | number
          }
        }
      }
      Quiz: {
        payload: Prisma.$QuizPayload<ExtArgs>
        fields: Prisma.QuizFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          findFirst: {
            args: Prisma.QuizFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          findMany: {
            args: Prisma.QuizFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          create: {
            args: Prisma.QuizCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          createMany: {
            args: Prisma.QuizCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          delete: {
            args: Prisma.QuizDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          update: {
            args: Prisma.QuizUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          deleteMany: {
            args: Prisma.QuizDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          upsert: {
            args: Prisma.QuizUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          aggregate: {
            args: Prisma.QuizAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuiz>
          }
          groupBy: {
            args: Prisma.QuizGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizCountArgs<ExtArgs>
            result: $Utils.Optional<QuizCountAggregateOutputType> | number
          }
        }
      }
      AssignmentSubmission: {
        payload: Prisma.$AssignmentSubmissionPayload<ExtArgs>
        fields: Prisma.AssignmentSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssignmentSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssignmentSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          findFirst: {
            args: Prisma.AssignmentSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssignmentSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          findMany: {
            args: Prisma.AssignmentSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>[]
          }
          create: {
            args: Prisma.AssignmentSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          createMany: {
            args: Prisma.AssignmentSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssignmentSubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>[]
          }
          delete: {
            args: Prisma.AssignmentSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          update: {
            args: Prisma.AssignmentSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.AssignmentSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssignmentSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssignmentSubmissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>[]
          }
          upsert: {
            args: Prisma.AssignmentSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          aggregate: {
            args: Prisma.AssignmentSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignmentSubmission>
          }
          groupBy: {
            args: Prisma.AssignmentSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssignmentSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentSubmissionCountAggregateOutputType> | number
          }
        }
      }
      Enrollment: {
        payload: Prisma.$EnrollmentPayload<ExtArgs>
        fields: Prisma.EnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findFirst: {
            args: Prisma.EnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findMany: {
            args: Prisma.EnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          create: {
            args: Prisma.EnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          createMany: {
            args: Prisma.EnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnrollmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          delete: {
            args: Prisma.EnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          update: {
            args: Prisma.EnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.EnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnrollmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          upsert: {
            args: Prisma.EnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          aggregate: {
            args: Prisma.EnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnrollment>
          }
          groupBy: {
            args: Prisma.EnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentCountAggregateOutputType> | number
          }
        }
      }
      LessonProgress: {
        payload: Prisma.$LessonProgressPayload<ExtArgs>
        fields: Prisma.LessonProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          findFirst: {
            args: Prisma.LessonProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          findMany: {
            args: Prisma.LessonProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>[]
          }
          create: {
            args: Prisma.LessonProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          createMany: {
            args: Prisma.LessonProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>[]
          }
          delete: {
            args: Prisma.LessonProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          update: {
            args: Prisma.LessonProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          deleteMany: {
            args: Prisma.LessonProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>[]
          }
          upsert: {
            args: Prisma.LessonProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonProgressPayload>
          }
          aggregate: {
            args: Prisma.LessonProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLessonProgress>
          }
          groupBy: {
            args: Prisma.LessonProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonProgressCountArgs<ExtArgs>
            result: $Utils.Optional<LessonProgressCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Interview: {
        payload: Prisma.$InterviewPayload<ExtArgs>
        fields: Prisma.InterviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          findFirst: {
            args: Prisma.InterviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          findMany: {
            args: Prisma.InterviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>[]
          }
          create: {
            args: Prisma.InterviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          createMany: {
            args: Prisma.InterviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>[]
          }
          delete: {
            args: Prisma.InterviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          update: {
            args: Prisma.InterviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          deleteMany: {
            args: Prisma.InterviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>[]
          }
          upsert: {
            args: Prisma.InterviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          aggregate: {
            args: Prisma.InterviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterview>
          }
          groupBy: {
            args: Prisma.InterviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterviewCountArgs<ExtArgs>
            result: $Utils.Optional<InterviewCountAggregateOutputType> | number
          }
        }
      }
      InterviewQuestion: {
        payload: Prisma.$InterviewQuestionPayload<ExtArgs>
        fields: Prisma.InterviewQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterviewQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterviewQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewQuestionPayload>
          }
          findFirst: {
            args: Prisma.InterviewQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterviewQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewQuestionPayload>
          }
          findMany: {
            args: Prisma.InterviewQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewQuestionPayload>[]
          }
          create: {
            args: Prisma.InterviewQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewQuestionPayload>
          }
          createMany: {
            args: Prisma.InterviewQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterviewQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewQuestionPayload>[]
          }
          delete: {
            args: Prisma.InterviewQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewQuestionPayload>
          }
          update: {
            args: Prisma.InterviewQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewQuestionPayload>
          }
          deleteMany: {
            args: Prisma.InterviewQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterviewQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterviewQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewQuestionPayload>[]
          }
          upsert: {
            args: Prisma.InterviewQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewQuestionPayload>
          }
          aggregate: {
            args: Prisma.InterviewQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterviewQuestion>
          }
          groupBy: {
            args: Prisma.InterviewQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterviewQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterviewQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<InterviewQuestionCountAggregateOutputType> | number
          }
        }
      }
      InterviewResponse: {
        payload: Prisma.$InterviewResponsePayload<ExtArgs>
        fields: Prisma.InterviewResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterviewResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterviewResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewResponsePayload>
          }
          findFirst: {
            args: Prisma.InterviewResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterviewResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewResponsePayload>
          }
          findMany: {
            args: Prisma.InterviewResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewResponsePayload>[]
          }
          create: {
            args: Prisma.InterviewResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewResponsePayload>
          }
          createMany: {
            args: Prisma.InterviewResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterviewResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewResponsePayload>[]
          }
          delete: {
            args: Prisma.InterviewResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewResponsePayload>
          }
          update: {
            args: Prisma.InterviewResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewResponsePayload>
          }
          deleteMany: {
            args: Prisma.InterviewResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterviewResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterviewResponseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewResponsePayload>[]
          }
          upsert: {
            args: Prisma.InterviewResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewResponsePayload>
          }
          aggregate: {
            args: Prisma.InterviewResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterviewResponse>
          }
          groupBy: {
            args: Prisma.InterviewResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterviewResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterviewResponseCountArgs<ExtArgs>
            result: $Utils.Optional<InterviewResponseCountAggregateOutputType> | number
          }
        }
      }
      InterviewEvaluation: {
        payload: Prisma.$InterviewEvaluationPayload<ExtArgs>
        fields: Prisma.InterviewEvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterviewEvaluationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewEvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterviewEvaluationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewEvaluationPayload>
          }
          findFirst: {
            args: Prisma.InterviewEvaluationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewEvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterviewEvaluationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewEvaluationPayload>
          }
          findMany: {
            args: Prisma.InterviewEvaluationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewEvaluationPayload>[]
          }
          create: {
            args: Prisma.InterviewEvaluationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewEvaluationPayload>
          }
          createMany: {
            args: Prisma.InterviewEvaluationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterviewEvaluationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewEvaluationPayload>[]
          }
          delete: {
            args: Prisma.InterviewEvaluationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewEvaluationPayload>
          }
          update: {
            args: Prisma.InterviewEvaluationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewEvaluationPayload>
          }
          deleteMany: {
            args: Prisma.InterviewEvaluationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterviewEvaluationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterviewEvaluationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewEvaluationPayload>[]
          }
          upsert: {
            args: Prisma.InterviewEvaluationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewEvaluationPayload>
          }
          aggregate: {
            args: Prisma.InterviewEvaluationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterviewEvaluation>
          }
          groupBy: {
            args: Prisma.InterviewEvaluationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterviewEvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterviewEvaluationCountArgs<ExtArgs>
            result: $Utils.Optional<InterviewEvaluationCountAggregateOutputType> | number
          }
        }
      }
      Avatar: {
        payload: Prisma.$AvatarPayload<ExtArgs>
        fields: Prisma.AvatarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvatarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvatarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarPayload>
          }
          findFirst: {
            args: Prisma.AvatarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvatarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarPayload>
          }
          findMany: {
            args: Prisma.AvatarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarPayload>[]
          }
          create: {
            args: Prisma.AvatarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarPayload>
          }
          createMany: {
            args: Prisma.AvatarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AvatarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarPayload>[]
          }
          delete: {
            args: Prisma.AvatarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarPayload>
          }
          update: {
            args: Prisma.AvatarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarPayload>
          }
          deleteMany: {
            args: Prisma.AvatarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvatarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AvatarUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarPayload>[]
          }
          upsert: {
            args: Prisma.AvatarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvatarPayload>
          }
          aggregate: {
            args: Prisma.AvatarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvatar>
          }
          groupBy: {
            args: Prisma.AvatarGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvatarGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvatarCountArgs<ExtArgs>
            result: $Utils.Optional<AvatarCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeBase: {
        payload: Prisma.$KnowledgeBasePayload<ExtArgs>
        fields: Prisma.KnowledgeBaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeBaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeBaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>
          }
          findFirst: {
            args: Prisma.KnowledgeBaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeBaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>
          }
          findMany: {
            args: Prisma.KnowledgeBaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>[]
          }
          create: {
            args: Prisma.KnowledgeBaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>
          }
          createMany: {
            args: Prisma.KnowledgeBaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KnowledgeBaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>[]
          }
          delete: {
            args: Prisma.KnowledgeBaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>
          }
          update: {
            args: Prisma.KnowledgeBaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeBaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeBaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KnowledgeBaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>[]
          }
          upsert: {
            args: Prisma.KnowledgeBaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>
          }
          aggregate: {
            args: Prisma.KnowledgeBaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeBase>
          }
          groupBy: {
            args: Prisma.KnowledgeBaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeBaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeBaseCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeBaseCountAggregateOutputType> | number
          }
        }
      }
      SystemPrompt: {
        payload: Prisma.$SystemPromptPayload<ExtArgs>
        fields: Prisma.SystemPromptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemPromptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPromptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemPromptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPromptPayload>
          }
          findFirst: {
            args: Prisma.SystemPromptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPromptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemPromptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPromptPayload>
          }
          findMany: {
            args: Prisma.SystemPromptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPromptPayload>[]
          }
          create: {
            args: Prisma.SystemPromptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPromptPayload>
          }
          createMany: {
            args: Prisma.SystemPromptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemPromptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPromptPayload>[]
          }
          delete: {
            args: Prisma.SystemPromptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPromptPayload>
          }
          update: {
            args: Prisma.SystemPromptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPromptPayload>
          }
          deleteMany: {
            args: Prisma.SystemPromptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemPromptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemPromptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPromptPayload>[]
          }
          upsert: {
            args: Prisma.SystemPromptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemPromptPayload>
          }
          aggregate: {
            args: Prisma.SystemPromptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemPrompt>
          }
          groupBy: {
            args: Prisma.SystemPromptGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemPromptGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemPromptCountArgs<ExtArgs>
            result: $Utils.Optional<SystemPromptCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      ForumCategory: {
        payload: Prisma.$ForumCategoryPayload<ExtArgs>
        fields: Prisma.ForumCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCategoryPayload>
          }
          findFirst: {
            args: Prisma.ForumCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCategoryPayload>
          }
          findMany: {
            args: Prisma.ForumCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCategoryPayload>[]
          }
          create: {
            args: Prisma.ForumCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCategoryPayload>
          }
          createMany: {
            args: Prisma.ForumCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCategoryPayload>[]
          }
          delete: {
            args: Prisma.ForumCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCategoryPayload>
          }
          update: {
            args: Prisma.ForumCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ForumCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ForumCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ForumCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCategoryPayload>
          }
          aggregate: {
            args: Prisma.ForumCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumCategory>
          }
          groupBy: {
            args: Prisma.ForumCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ForumCategoryCountAggregateOutputType> | number
          }
        }
      }
      ForumPost: {
        payload: Prisma.$ForumPostPayload<ExtArgs>
        fields: Prisma.ForumPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          findFirst: {
            args: Prisma.ForumPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          findMany: {
            args: Prisma.ForumPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>[]
          }
          create: {
            args: Prisma.ForumPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          createMany: {
            args: Prisma.ForumPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>[]
          }
          delete: {
            args: Prisma.ForumPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          update: {
            args: Prisma.ForumPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          deleteMany: {
            args: Prisma.ForumPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ForumPostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>[]
          }
          upsert: {
            args: Prisma.ForumPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          aggregate: {
            args: Prisma.ForumPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumPost>
          }
          groupBy: {
            args: Prisma.ForumPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumPostCountArgs<ExtArgs>
            result: $Utils.Optional<ForumPostCountAggregateOutputType> | number
          }
        }
      }
      ForumComment: {
        payload: Prisma.$ForumCommentPayload<ExtArgs>
        fields: Prisma.ForumCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>
          }
          findFirst: {
            args: Prisma.ForumCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>
          }
          findMany: {
            args: Prisma.ForumCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>[]
          }
          create: {
            args: Prisma.ForumCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>
          }
          createMany: {
            args: Prisma.ForumCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>[]
          }
          delete: {
            args: Prisma.ForumCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>
          }
          update: {
            args: Prisma.ForumCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>
          }
          deleteMany: {
            args: Prisma.ForumCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ForumCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>[]
          }
          upsert: {
            args: Prisma.ForumCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>
          }
          aggregate: {
            args: Prisma.ForumCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumComment>
          }
          groupBy: {
            args: Prisma.ForumCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumCommentCountArgs<ExtArgs>
            result: $Utils.Optional<ForumCommentCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Certificate: {
        payload: Prisma.$CertificatePayload<ExtArgs>
        fields: Prisma.CertificateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findFirst: {
            args: Prisma.CertificateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findMany: {
            args: Prisma.CertificateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          create: {
            args: Prisma.CertificateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          createMany: {
            args: Prisma.CertificateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          delete: {
            args: Prisma.CertificateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          update: {
            args: Prisma.CertificateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          deleteMany: {
            args: Prisma.CertificateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CertificateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          upsert: {
            args: Prisma.CertificateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          aggregate: {
            args: Prisma.CertificateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificate>
          }
          groupBy: {
            args: Prisma.CertificateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificateCountArgs<ExtArgs>
            result: $Utils.Optional<CertificateCountAggregateOutputType> | number
          }
        }
      }
      CertificateTemplate: {
        payload: Prisma.$CertificateTemplatePayload<ExtArgs>
        fields: Prisma.CertificateTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificateTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificateTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateTemplatePayload>
          }
          findFirst: {
            args: Prisma.CertificateTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificateTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateTemplatePayload>
          }
          findMany: {
            args: Prisma.CertificateTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateTemplatePayload>[]
          }
          create: {
            args: Prisma.CertificateTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateTemplatePayload>
          }
          createMany: {
            args: Prisma.CertificateTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificateTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateTemplatePayload>[]
          }
          delete: {
            args: Prisma.CertificateTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateTemplatePayload>
          }
          update: {
            args: Prisma.CertificateTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateTemplatePayload>
          }
          deleteMany: {
            args: Prisma.CertificateTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificateTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CertificateTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateTemplatePayload>[]
          }
          upsert: {
            args: Prisma.CertificateTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateTemplatePayload>
          }
          aggregate: {
            args: Prisma.CertificateTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificateTemplate>
          }
          groupBy: {
            args: Prisma.CertificateTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificateTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificateTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<CertificateTemplateCountAggregateOutputType> | number
          }
        }
      }
      CertificateSettings: {
        payload: Prisma.$CertificateSettingsPayload<ExtArgs>
        fields: Prisma.CertificateSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificateSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificateSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateSettingsPayload>
          }
          findFirst: {
            args: Prisma.CertificateSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificateSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateSettingsPayload>
          }
          findMany: {
            args: Prisma.CertificateSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateSettingsPayload>[]
          }
          create: {
            args: Prisma.CertificateSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateSettingsPayload>
          }
          createMany: {
            args: Prisma.CertificateSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificateSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateSettingsPayload>[]
          }
          delete: {
            args: Prisma.CertificateSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateSettingsPayload>
          }
          update: {
            args: Prisma.CertificateSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateSettingsPayload>
          }
          deleteMany: {
            args: Prisma.CertificateSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificateSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CertificateSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateSettingsPayload>[]
          }
          upsert: {
            args: Prisma.CertificateSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificateSettingsPayload>
          }
          aggregate: {
            args: Prisma.CertificateSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificateSettings>
          }
          groupBy: {
            args: Prisma.CertificateSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificateSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificateSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<CertificateSettingsCountAggregateOutputType> | number
          }
        }
      }
      AIProvider: {
        payload: Prisma.$AIProviderPayload<ExtArgs>
        fields: Prisma.AIProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIProviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIProviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderPayload>
          }
          findFirst: {
            args: Prisma.AIProviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIProviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderPayload>
          }
          findMany: {
            args: Prisma.AIProviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderPayload>[]
          }
          create: {
            args: Prisma.AIProviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderPayload>
          }
          createMany: {
            args: Prisma.AIProviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIProviderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderPayload>[]
          }
          delete: {
            args: Prisma.AIProviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderPayload>
          }
          update: {
            args: Prisma.AIProviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderPayload>
          }
          deleteMany: {
            args: Prisma.AIProviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIProviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIProviderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderPayload>[]
          }
          upsert: {
            args: Prisma.AIProviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIProviderPayload>
          }
          aggregate: {
            args: Prisma.AIProviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIProvider>
          }
          groupBy: {
            args: Prisma.AIProviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIProviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIProviderCountArgs<ExtArgs>
            result: $Utils.Optional<AIProviderCountAggregateOutputType> | number
          }
        }
      }
      AIUsageLog: {
        payload: Prisma.$AIUsageLogPayload<ExtArgs>
        fields: Prisma.AIUsageLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIUsageLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIUsageLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          findFirst: {
            args: Prisma.AIUsageLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIUsageLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          findMany: {
            args: Prisma.AIUsageLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>[]
          }
          create: {
            args: Prisma.AIUsageLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          createMany: {
            args: Prisma.AIUsageLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIUsageLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>[]
          }
          delete: {
            args: Prisma.AIUsageLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          update: {
            args: Prisma.AIUsageLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          deleteMany: {
            args: Prisma.AIUsageLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIUsageLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIUsageLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>[]
          }
          upsert: {
            args: Prisma.AIUsageLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageLogPayload>
          }
          aggregate: {
            args: Prisma.AIUsageLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIUsageLog>
          }
          groupBy: {
            args: Prisma.AIUsageLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIUsageLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIUsageLogCountArgs<ExtArgs>
            result: $Utils.Optional<AIUsageLogCountAggregateOutputType> | number
          }
        }
      }
      VideoIntegration: {
        payload: Prisma.$VideoIntegrationPayload<ExtArgs>
        fields: Prisma.VideoIntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoIntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoIntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoIntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoIntegrationPayload>
          }
          findFirst: {
            args: Prisma.VideoIntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoIntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoIntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoIntegrationPayload>
          }
          findMany: {
            args: Prisma.VideoIntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoIntegrationPayload>[]
          }
          create: {
            args: Prisma.VideoIntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoIntegrationPayload>
          }
          createMany: {
            args: Prisma.VideoIntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoIntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoIntegrationPayload>[]
          }
          delete: {
            args: Prisma.VideoIntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoIntegrationPayload>
          }
          update: {
            args: Prisma.VideoIntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoIntegrationPayload>
          }
          deleteMany: {
            args: Prisma.VideoIntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoIntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VideoIntegrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoIntegrationPayload>[]
          }
          upsert: {
            args: Prisma.VideoIntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoIntegrationPayload>
          }
          aggregate: {
            args: Prisma.VideoIntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoIntegration>
          }
          groupBy: {
            args: Prisma.VideoIntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoIntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoIntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<VideoIntegrationCountAggregateOutputType> | number
          }
        }
      }
      LiveClass: {
        payload: Prisma.$LiveClassPayload<ExtArgs>
        fields: Prisma.LiveClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LiveClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LiveClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveClassPayload>
          }
          findFirst: {
            args: Prisma.LiveClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LiveClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveClassPayload>
          }
          findMany: {
            args: Prisma.LiveClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveClassPayload>[]
          }
          create: {
            args: Prisma.LiveClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveClassPayload>
          }
          createMany: {
            args: Prisma.LiveClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LiveClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveClassPayload>[]
          }
          delete: {
            args: Prisma.LiveClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveClassPayload>
          }
          update: {
            args: Prisma.LiveClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveClassPayload>
          }
          deleteMany: {
            args: Prisma.LiveClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LiveClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LiveClassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveClassPayload>[]
          }
          upsert: {
            args: Prisma.LiveClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveClassPayload>
          }
          aggregate: {
            args: Prisma.LiveClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLiveClass>
          }
          groupBy: {
            args: Prisma.LiveClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<LiveClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.LiveClassCountArgs<ExtArgs>
            result: $Utils.Optional<LiveClassCountAggregateOutputType> | number
          }
        }
      }
      Lead: {
        payload: Prisma.$LeadPayload<ExtArgs>
        fields: Prisma.LeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findFirst: {
            args: Prisma.LeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findMany: {
            args: Prisma.LeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          create: {
            args: Prisma.LeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          createMany: {
            args: Prisma.LeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          delete: {
            args: Prisma.LeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          update: {
            args: Prisma.LeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          deleteMany: {
            args: Prisma.LeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          upsert: {
            args: Prisma.LeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.LeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
      MarketingIntegration: {
        payload: Prisma.$MarketingIntegrationPayload<ExtArgs>
        fields: Prisma.MarketingIntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketingIntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingIntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketingIntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingIntegrationPayload>
          }
          findFirst: {
            args: Prisma.MarketingIntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingIntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketingIntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingIntegrationPayload>
          }
          findMany: {
            args: Prisma.MarketingIntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingIntegrationPayload>[]
          }
          create: {
            args: Prisma.MarketingIntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingIntegrationPayload>
          }
          createMany: {
            args: Prisma.MarketingIntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketingIntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingIntegrationPayload>[]
          }
          delete: {
            args: Prisma.MarketingIntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingIntegrationPayload>
          }
          update: {
            args: Prisma.MarketingIntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingIntegrationPayload>
          }
          deleteMany: {
            args: Prisma.MarketingIntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketingIntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MarketingIntegrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingIntegrationPayload>[]
          }
          upsert: {
            args: Prisma.MarketingIntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingIntegrationPayload>
          }
          aggregate: {
            args: Prisma.MarketingIntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketingIntegration>
          }
          groupBy: {
            args: Prisma.MarketingIntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketingIntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketingIntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<MarketingIntegrationCountAggregateOutputType> | number
          }
        }
      }
      EmailIntegration: {
        payload: Prisma.$EmailIntegrationPayload<ExtArgs>
        fields: Prisma.EmailIntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailIntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailIntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailIntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailIntegrationPayload>
          }
          findFirst: {
            args: Prisma.EmailIntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailIntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailIntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailIntegrationPayload>
          }
          findMany: {
            args: Prisma.EmailIntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailIntegrationPayload>[]
          }
          create: {
            args: Prisma.EmailIntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailIntegrationPayload>
          }
          createMany: {
            args: Prisma.EmailIntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailIntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailIntegrationPayload>[]
          }
          delete: {
            args: Prisma.EmailIntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailIntegrationPayload>
          }
          update: {
            args: Prisma.EmailIntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailIntegrationPayload>
          }
          deleteMany: {
            args: Prisma.EmailIntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailIntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailIntegrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailIntegrationPayload>[]
          }
          upsert: {
            args: Prisma.EmailIntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailIntegrationPayload>
          }
          aggregate: {
            args: Prisma.EmailIntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailIntegration>
          }
          groupBy: {
            args: Prisma.EmailIntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailIntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailIntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<EmailIntegrationCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      TaskComment: {
        payload: Prisma.$TaskCommentPayload<ExtArgs>
        fields: Prisma.TaskCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>
          }
          findFirst: {
            args: Prisma.TaskCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>
          }
          findMany: {
            args: Prisma.TaskCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>[]
          }
          create: {
            args: Prisma.TaskCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>
          }
          createMany: {
            args: Prisma.TaskCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>[]
          }
          delete: {
            args: Prisma.TaskCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>
          }
          update: {
            args: Prisma.TaskCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>
          }
          deleteMany: {
            args: Prisma.TaskCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>[]
          }
          upsert: {
            args: Prisma.TaskCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCommentPayload>
          }
          aggregate: {
            args: Prisma.TaskCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskComment>
          }
          groupBy: {
            args: Prisma.TaskCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCommentCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCommentCountAggregateOutputType> | number
          }
        }
      }
      BlogPost: {
        payload: Prisma.$BlogPostPayload<ExtArgs>
        fields: Prisma.BlogPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findFirst: {
            args: Prisma.BlogPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findMany: {
            args: Prisma.BlogPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          create: {
            args: Prisma.BlogPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          createMany: {
            args: Prisma.BlogPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          delete: {
            args: Prisma.BlogPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          update: {
            args: Prisma.BlogPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          deleteMany: {
            args: Prisma.BlogPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogPostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          upsert: {
            args: Prisma.BlogPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          aggregate: {
            args: Prisma.BlogPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogPost>
          }
          groupBy: {
            args: Prisma.BlogPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogPostCountArgs<ExtArgs>
            result: $Utils.Optional<BlogPostCountAggregateOutputType> | number
          }
        }
      }
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      TicketMessage: {
        payload: Prisma.$TicketMessagePayload<ExtArgs>
        fields: Prisma.TicketMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          findFirst: {
            args: Prisma.TicketMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          findMany: {
            args: Prisma.TicketMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>[]
          }
          create: {
            args: Prisma.TicketMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          createMany: {
            args: Prisma.TicketMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>[]
          }
          delete: {
            args: Prisma.TicketMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          update: {
            args: Prisma.TicketMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          deleteMany: {
            args: Prisma.TicketMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>[]
          }
          upsert: {
            args: Prisma.TicketMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          aggregate: {
            args: Prisma.TicketMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketMessage>
          }
          groupBy: {
            args: Prisma.TicketMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketMessageCountArgs<ExtArgs>
            result: $Utils.Optional<TicketMessageCountAggregateOutputType> | number
          }
        }
      }
      PaymentConfig: {
        payload: Prisma.$PaymentConfigPayload<ExtArgs>
        fields: Prisma.PaymentConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConfigPayload>
          }
          findFirst: {
            args: Prisma.PaymentConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConfigPayload>
          }
          findMany: {
            args: Prisma.PaymentConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConfigPayload>[]
          }
          create: {
            args: Prisma.PaymentConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConfigPayload>
          }
          createMany: {
            args: Prisma.PaymentConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConfigPayload>[]
          }
          delete: {
            args: Prisma.PaymentConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConfigPayload>
          }
          update: {
            args: Prisma.PaymentConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConfigPayload>
          }
          deleteMany: {
            args: Prisma.PaymentConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConfigPayload>[]
          }
          upsert: {
            args: Prisma.PaymentConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentConfigPayload>
          }
          aggregate: {
            args: Prisma.PaymentConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentConfig>
          }
          groupBy: {
            args: Prisma.PaymentConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentConfigCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentConfigCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      SystemSettings: {
        payload: Prisma.$SystemSettingsPayload<ExtArgs>
        fields: Prisma.SystemSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findMany: {
            args: Prisma.SystemSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          create: {
            args: Prisma.SystemSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          createMany: {
            args: Prisma.SystemSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          delete: {
            args: Prisma.SystemSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          update: {
            args: Prisma.SystemSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          upsert: {
            args: Prisma.SystemSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSettings>
          }
          groupBy: {
            args: Prisma.SystemSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsCountAggregateOutputType> | number
          }
        }
      }
      EmployerProfile: {
        payload: Prisma.$EmployerProfilePayload<ExtArgs>
        fields: Prisma.EmployerProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployerProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployerProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployerProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployerProfilePayload>
          }
          findFirst: {
            args: Prisma.EmployerProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployerProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployerProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployerProfilePayload>
          }
          findMany: {
            args: Prisma.EmployerProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployerProfilePayload>[]
          }
          create: {
            args: Prisma.EmployerProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployerProfilePayload>
          }
          createMany: {
            args: Prisma.EmployerProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployerProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployerProfilePayload>[]
          }
          delete: {
            args: Prisma.EmployerProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployerProfilePayload>
          }
          update: {
            args: Prisma.EmployerProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployerProfilePayload>
          }
          deleteMany: {
            args: Prisma.EmployerProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployerProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployerProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployerProfilePayload>[]
          }
          upsert: {
            args: Prisma.EmployerProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployerProfilePayload>
          }
          aggregate: {
            args: Prisma.EmployerProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployerProfile>
          }
          groupBy: {
            args: Prisma.EmployerProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployerProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployerProfileCountArgs<ExtArgs>
            result: $Utils.Optional<EmployerProfileCountAggregateOutputType> | number
          }
        }
      }
      Job: {
        payload: Prisma.$JobPayload<ExtArgs>
        fields: Prisma.JobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          findFirst: {
            args: Prisma.JobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          findMany: {
            args: Prisma.JobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          create: {
            args: Prisma.JobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          createMany: {
            args: Prisma.JobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          delete: {
            args: Prisma.JobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          update: {
            args: Prisma.JobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          deleteMany: {
            args: Prisma.JobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          upsert: {
            args: Prisma.JobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          aggregate: {
            args: Prisma.JobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob>
          }
          groupBy: {
            args: Prisma.JobGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobCountArgs<ExtArgs>
            result: $Utils.Optional<JobCountAggregateOutputType> | number
          }
        }
      }
      JobApplication: {
        payload: Prisma.$JobApplicationPayload<ExtArgs>
        fields: Prisma.JobApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          findFirst: {
            args: Prisma.JobApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          findMany: {
            args: Prisma.JobApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>[]
          }
          create: {
            args: Prisma.JobApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          createMany: {
            args: Prisma.JobApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>[]
          }
          delete: {
            args: Prisma.JobApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          update: {
            args: Prisma.JobApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          deleteMany: {
            args: Prisma.JobApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobApplicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>[]
          }
          upsert: {
            args: Prisma.JobApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobApplicationPayload>
          }
          aggregate: {
            args: Prisma.JobApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobApplication>
          }
          groupBy: {
            args: Prisma.JobApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<JobApplicationCountAggregateOutputType> | number
          }
        }
      }
      JobInterview: {
        payload: Prisma.$JobInterviewPayload<ExtArgs>
        fields: Prisma.JobInterviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobInterviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobInterviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobInterviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobInterviewPayload>
          }
          findFirst: {
            args: Prisma.JobInterviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobInterviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobInterviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobInterviewPayload>
          }
          findMany: {
            args: Prisma.JobInterviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobInterviewPayload>[]
          }
          create: {
            args: Prisma.JobInterviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobInterviewPayload>
          }
          createMany: {
            args: Prisma.JobInterviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobInterviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobInterviewPayload>[]
          }
          delete: {
            args: Prisma.JobInterviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobInterviewPayload>
          }
          update: {
            args: Prisma.JobInterviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobInterviewPayload>
          }
          deleteMany: {
            args: Prisma.JobInterviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobInterviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobInterviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobInterviewPayload>[]
          }
          upsert: {
            args: Prisma.JobInterviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobInterviewPayload>
          }
          aggregate: {
            args: Prisma.JobInterviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobInterview>
          }
          groupBy: {
            args: Prisma.JobInterviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobInterviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobInterviewCountArgs<ExtArgs>
            result: $Utils.Optional<JobInterviewCountAggregateOutputType> | number
          }
        }
      }
      EmailLog: {
        payload: Prisma.$EmailLogPayload<ExtArgs>
        fields: Prisma.EmailLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          findFirst: {
            args: Prisma.EmailLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          findMany: {
            args: Prisma.EmailLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>[]
          }
          create: {
            args: Prisma.EmailLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          createMany: {
            args: Prisma.EmailLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>[]
          }
          delete: {
            args: Prisma.EmailLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          update: {
            args: Prisma.EmailLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          deleteMany: {
            args: Prisma.EmailLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>[]
          }
          upsert: {
            args: Prisma.EmailLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          aggregate: {
            args: Prisma.EmailLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailLog>
          }
          groupBy: {
            args: Prisma.EmailLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailLogCountArgs<ExtArgs>
            result: $Utils.Optional<EmailLogCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      SavedFilter: {
        payload: Prisma.$SavedFilterPayload<ExtArgs>
        fields: Prisma.SavedFilterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SavedFilterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedFilterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SavedFilterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedFilterPayload>
          }
          findFirst: {
            args: Prisma.SavedFilterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedFilterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SavedFilterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedFilterPayload>
          }
          findMany: {
            args: Prisma.SavedFilterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedFilterPayload>[]
          }
          create: {
            args: Prisma.SavedFilterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedFilterPayload>
          }
          createMany: {
            args: Prisma.SavedFilterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SavedFilterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedFilterPayload>[]
          }
          delete: {
            args: Prisma.SavedFilterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedFilterPayload>
          }
          update: {
            args: Prisma.SavedFilterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedFilterPayload>
          }
          deleteMany: {
            args: Prisma.SavedFilterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SavedFilterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SavedFilterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedFilterPayload>[]
          }
          upsert: {
            args: Prisma.SavedFilterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedFilterPayload>
          }
          aggregate: {
            args: Prisma.SavedFilterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSavedFilter>
          }
          groupBy: {
            args: Prisma.SavedFilterGroupByArgs<ExtArgs>
            result: $Utils.Optional<SavedFilterGroupByOutputType>[]
          }
          count: {
            args: Prisma.SavedFilterCountArgs<ExtArgs>
            result: $Utils.Optional<SavedFilterCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    course?: CourseOmit
    batch?: BatchOmit
    announcement?: AnnouncementOmit
    lessonComment?: LessonCommentOmit
    module?: ModuleOmit
    lesson?: LessonOmit
    quiz?: QuizOmit
    assignmentSubmission?: AssignmentSubmissionOmit
    enrollment?: EnrollmentOmit
    lessonProgress?: LessonProgressOmit
    review?: ReviewOmit
    interview?: InterviewOmit
    interviewQuestion?: InterviewQuestionOmit
    interviewResponse?: InterviewResponseOmit
    interviewEvaluation?: InterviewEvaluationOmit
    avatar?: AvatarOmit
    knowledgeBase?: KnowledgeBaseOmit
    systemPrompt?: SystemPromptOmit
    payment?: PaymentOmit
    forumCategory?: ForumCategoryOmit
    forumPost?: ForumPostOmit
    forumComment?: ForumCommentOmit
    conversation?: ConversationOmit
    message?: MessageOmit
    certificate?: CertificateOmit
    certificateTemplate?: CertificateTemplateOmit
    certificateSettings?: CertificateSettingsOmit
    aIProvider?: AIProviderOmit
    aIUsageLog?: AIUsageLogOmit
    videoIntegration?: VideoIntegrationOmit
    liveClass?: LiveClassOmit
    lead?: LeadOmit
    marketingIntegration?: MarketingIntegrationOmit
    emailIntegration?: EmailIntegrationOmit
    task?: TaskOmit
    taskComment?: TaskCommentOmit
    blogPost?: BlogPostOmit
    ticket?: TicketOmit
    ticketMessage?: TicketMessageOmit
    paymentConfig?: PaymentConfigOmit
    expense?: ExpenseOmit
    systemSettings?: SystemSettingsOmit
    employerProfile?: EmployerProfileOmit
    job?: JobOmit
    jobApplication?: JobApplicationOmit
    jobInterview?: JobInterviewOmit
    emailLog?: EmailLogOmit
    auditLog?: AuditLogOmit
    savedFilter?: SavedFilterOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    enrollments: number
    interviews: number
    lessonProgress: number
    posts: number
    comments: number
    conversations: number
    sentMessages: number
    payments: number
    certificates: number
    reviews: number
    tickets: number
    sentTicketMessages: number
    jobs: number
    applications: number
    assignedTasks: number
    createdTasks: number
    blogPosts: number
    taskComments: number
    assignmentSubmissions: number
    lessonComments: number
    instructedBatches: number
    announcements: number
    conductedJobInterviews: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | UserCountOutputTypeCountEnrollmentsArgs
    interviews?: boolean | UserCountOutputTypeCountInterviewsArgs
    lessonProgress?: boolean | UserCountOutputTypeCountLessonProgressArgs
    posts?: boolean | UserCountOutputTypeCountPostsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    conversations?: boolean | UserCountOutputTypeCountConversationsArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    certificates?: boolean | UserCountOutputTypeCountCertificatesArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    tickets?: boolean | UserCountOutputTypeCountTicketsArgs
    sentTicketMessages?: boolean | UserCountOutputTypeCountSentTicketMessagesArgs
    jobs?: boolean | UserCountOutputTypeCountJobsArgs
    applications?: boolean | UserCountOutputTypeCountApplicationsArgs
    assignedTasks?: boolean | UserCountOutputTypeCountAssignedTasksArgs
    createdTasks?: boolean | UserCountOutputTypeCountCreatedTasksArgs
    blogPosts?: boolean | UserCountOutputTypeCountBlogPostsArgs
    taskComments?: boolean | UserCountOutputTypeCountTaskCommentsArgs
    assignmentSubmissions?: boolean | UserCountOutputTypeCountAssignmentSubmissionsArgs
    lessonComments?: boolean | UserCountOutputTypeCountLessonCommentsArgs
    instructedBatches?: boolean | UserCountOutputTypeCountInstructedBatchesArgs
    announcements?: boolean | UserCountOutputTypeCountAnnouncementsArgs
    conductedJobInterviews?: boolean | UserCountOutputTypeCountConductedJobInterviewsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInterviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLessonProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumPostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentTicketMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobApplicationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaskCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignmentSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentSubmissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLessonCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInstructedBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConductedJobInterviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobInterviewWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    modules: number
    enrollments: number
    payments: number
    reviews: number
    liveClasses: number
    batches: number
    announcements: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modules?: boolean | CourseCountOutputTypeCountModulesArgs
    enrollments?: boolean | CourseCountOutputTypeCountEnrollmentsArgs
    payments?: boolean | CourseCountOutputTypeCountPaymentsArgs
    reviews?: boolean | CourseCountOutputTypeCountReviewsArgs
    liveClasses?: boolean | CourseCountOutputTypeCountLiveClassesArgs
    batches?: boolean | CourseCountOutputTypeCountBatchesArgs
    announcements?: boolean | CourseCountOutputTypeCountAnnouncementsArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountLiveClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiveClassWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
  }


  /**
   * Count Type BatchCountOutputType
   */

  export type BatchCountOutputType = {
    announcements: number
    enrollments: number
  }

  export type BatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    announcements?: boolean | BatchCountOutputTypeCountAnnouncementsArgs
    enrollments?: boolean | BatchCountOutputTypeCountEnrollmentsArgs
  }

  // Custom InputTypes
  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchCountOutputType
     */
    select?: BatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountAnnouncementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }


  /**
   * Count Type LessonCommentCountOutputType
   */

  export type LessonCommentCountOutputType = {
    replies: number
  }

  export type LessonCommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | LessonCommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * LessonCommentCountOutputType without action
   */
  export type LessonCommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCommentCountOutputType
     */
    select?: LessonCommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LessonCommentCountOutputType without action
   */
  export type LessonCommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonCommentWhereInput
  }


  /**
   * Count Type ModuleCountOutputType
   */

  export type ModuleCountOutputType = {
    lessons: number
  }

  export type ModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | ModuleCountOutputTypeCountLessonsArgs
  }

  // Custom InputTypes
  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCountOutputType
     */
    select?: ModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }


  /**
   * Count Type LessonCountOutputType
   */

  export type LessonCountOutputType = {
    quizzes: number
    progress: number
    comments: number
    assignmentSubmissions: number
  }

  export type LessonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizzes?: boolean | LessonCountOutputTypeCountQuizzesArgs
    progress?: boolean | LessonCountOutputTypeCountProgressArgs
    comments?: boolean | LessonCountOutputTypeCountCommentsArgs
    assignmentSubmissions?: boolean | LessonCountOutputTypeCountAssignmentSubmissionsArgs
  }

  // Custom InputTypes
  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCountOutputType
     */
    select?: LessonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountQuizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonProgressWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonCommentWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountAssignmentSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentSubmissionWhereInput
  }


  /**
   * Count Type InterviewCountOutputType
   */

  export type InterviewCountOutputType = {
    questions: number
    responses: number
  }

  export type InterviewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | InterviewCountOutputTypeCountQuestionsArgs
    responses?: boolean | InterviewCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes
  /**
   * InterviewCountOutputType without action
   */
  export type InterviewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewCountOutputType
     */
    select?: InterviewCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InterviewCountOutputType without action
   */
  export type InterviewCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewQuestionWhereInput
  }

  /**
   * InterviewCountOutputType without action
   */
  export type InterviewCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewResponseWhereInput
  }


  /**
   * Count Type ForumCategoryCountOutputType
   */

  export type ForumCategoryCountOutputType = {
    posts: number
  }

  export type ForumCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | ForumCategoryCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * ForumCategoryCountOutputType without action
   */
  export type ForumCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategoryCountOutputType
     */
    select?: ForumCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ForumCategoryCountOutputType without action
   */
  export type ForumCategoryCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumPostWhereInput
  }


  /**
   * Count Type ForumPostCountOutputType
   */

  export type ForumPostCountOutputType = {
    comments: number
  }

  export type ForumPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | ForumPostCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * ForumPostCountOutputType without action
   */
  export type ForumPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPostCountOutputType
     */
    select?: ForumPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ForumPostCountOutputType without action
   */
  export type ForumPostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumCommentWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    participants: number
    messages: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | ConversationCountOutputTypeCountParticipantsArgs
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type CertificateTemplateCountOutputType
   */

  export type CertificateTemplateCountOutputType = {
    certificates: number
  }

  export type CertificateTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificates?: boolean | CertificateTemplateCountOutputTypeCountCertificatesArgs
  }

  // Custom InputTypes
  /**
   * CertificateTemplateCountOutputType without action
   */
  export type CertificateTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateTemplateCountOutputType
     */
    select?: CertificateTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CertificateTemplateCountOutputType without action
   */
  export type CertificateTemplateCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }


  /**
   * Count Type LeadCountOutputType
   */

  export type LeadCountOutputType = {
    tasks: number
  }

  export type LeadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | LeadCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCountOutputType
     */
    select?: LeadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    comments: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | TaskCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCommentWhereInput
  }


  /**
   * Count Type TicketCountOutputType
   */

  export type TicketCountOutputType = {
    messages: number
  }

  export type TicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | TicketCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCountOutputType
     */
    select?: TicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketMessageWhereInput
  }


  /**
   * Count Type JobCountOutputType
   */

  export type JobCountOutputType = {
    applications: number
  }

  export type JobCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | JobCountOutputTypeCountApplicationsArgs
  }

  // Custom InputTypes
  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCountOutputType
     */
    select?: JobCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobApplicationWhereInput
  }


  /**
   * Count Type JobApplicationCountOutputType
   */

  export type JobApplicationCountOutputType = {
    interviews: number
    emailLogs: number
    auditLogs: number
  }

  export type JobApplicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interviews?: boolean | JobApplicationCountOutputTypeCountInterviewsArgs
    emailLogs?: boolean | JobApplicationCountOutputTypeCountEmailLogsArgs
    auditLogs?: boolean | JobApplicationCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * JobApplicationCountOutputType without action
   */
  export type JobApplicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplicationCountOutputType
     */
    select?: JobApplicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobApplicationCountOutputType without action
   */
  export type JobApplicationCountOutputTypeCountInterviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobInterviewWhereInput
  }

  /**
   * JobApplicationCountOutputType without action
   */
  export type JobApplicationCountOutputTypeCountEmailLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailLogWhereInput
  }

  /**
   * JobApplicationCountOutputType without action
   */
  export type JobApplicationCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.Role | null
    avatar: string | null
    phone: string | null
    isActive: boolean | null
    emailVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.Role | null
    avatar: string | null
    phone: string | null
    isActive: boolean | null
    emailVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    role: number
    avatar: number
    phone: number
    isActive: number
    emailVerified: number
    permissions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    avatar?: true
    phone?: true
    isActive?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    avatar?: true
    phone?: true
    isActive?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    avatar?: true
    phone?: true
    isActive?: true
    emailVerified?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string
    role: $Enums.Role
    avatar: string | null
    phone: string | null
    isActive: boolean
    emailVerified: boolean
    permissions: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    avatar?: boolean
    phone?: boolean
    isActive?: boolean
    emailVerified?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    enrollments?: boolean | User$enrollmentsArgs<ExtArgs>
    interviews?: boolean | User$interviewsArgs<ExtArgs>
    lessonProgress?: boolean | User$lessonProgressArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    certificates?: boolean | User$certificatesArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    tickets?: boolean | User$ticketsArgs<ExtArgs>
    sentTicketMessages?: boolean | User$sentTicketMessagesArgs<ExtArgs>
    employerProfile?: boolean | User$employerProfileArgs<ExtArgs>
    jobs?: boolean | User$jobsArgs<ExtArgs>
    applications?: boolean | User$applicationsArgs<ExtArgs>
    assignedTasks?: boolean | User$assignedTasksArgs<ExtArgs>
    createdTasks?: boolean | User$createdTasksArgs<ExtArgs>
    blogPosts?: boolean | User$blogPostsArgs<ExtArgs>
    taskComments?: boolean | User$taskCommentsArgs<ExtArgs>
    assignmentSubmissions?: boolean | User$assignmentSubmissionsArgs<ExtArgs>
    lessonComments?: boolean | User$lessonCommentsArgs<ExtArgs>
    instructedBatches?: boolean | User$instructedBatchesArgs<ExtArgs>
    announcements?: boolean | User$announcementsArgs<ExtArgs>
    conductedJobInterviews?: boolean | User$conductedJobInterviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    avatar?: boolean
    phone?: boolean
    isActive?: boolean
    emailVerified?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    avatar?: boolean
    phone?: boolean
    isActive?: boolean
    emailVerified?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    avatar?: boolean
    phone?: boolean
    isActive?: boolean
    emailVerified?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "role" | "avatar" | "phone" | "isActive" | "emailVerified" | "permissions" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | User$enrollmentsArgs<ExtArgs>
    interviews?: boolean | User$interviewsArgs<ExtArgs>
    lessonProgress?: boolean | User$lessonProgressArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    certificates?: boolean | User$certificatesArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    tickets?: boolean | User$ticketsArgs<ExtArgs>
    sentTicketMessages?: boolean | User$sentTicketMessagesArgs<ExtArgs>
    employerProfile?: boolean | User$employerProfileArgs<ExtArgs>
    jobs?: boolean | User$jobsArgs<ExtArgs>
    applications?: boolean | User$applicationsArgs<ExtArgs>
    assignedTasks?: boolean | User$assignedTasksArgs<ExtArgs>
    createdTasks?: boolean | User$createdTasksArgs<ExtArgs>
    blogPosts?: boolean | User$blogPostsArgs<ExtArgs>
    taskComments?: boolean | User$taskCommentsArgs<ExtArgs>
    assignmentSubmissions?: boolean | User$assignmentSubmissionsArgs<ExtArgs>
    lessonComments?: boolean | User$lessonCommentsArgs<ExtArgs>
    instructedBatches?: boolean | User$instructedBatchesArgs<ExtArgs>
    announcements?: boolean | User$announcementsArgs<ExtArgs>
    conductedJobInterviews?: boolean | User$conductedJobInterviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      interviews: Prisma.$InterviewPayload<ExtArgs>[]
      lessonProgress: Prisma.$LessonProgressPayload<ExtArgs>[]
      posts: Prisma.$ForumPostPayload<ExtArgs>[]
      comments: Prisma.$ForumCommentPayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      sentTicketMessages: Prisma.$TicketMessagePayload<ExtArgs>[]
      employerProfile: Prisma.$EmployerProfilePayload<ExtArgs> | null
      jobs: Prisma.$JobPayload<ExtArgs>[]
      applications: Prisma.$JobApplicationPayload<ExtArgs>[]
      assignedTasks: Prisma.$TaskPayload<ExtArgs>[]
      createdTasks: Prisma.$TaskPayload<ExtArgs>[]
      blogPosts: Prisma.$BlogPostPayload<ExtArgs>[]
      taskComments: Prisma.$TaskCommentPayload<ExtArgs>[]
      assignmentSubmissions: Prisma.$AssignmentSubmissionPayload<ExtArgs>[]
      lessonComments: Prisma.$LessonCommentPayload<ExtArgs>[]
      instructedBatches: Prisma.$BatchPayload<ExtArgs>[]
      announcements: Prisma.$AnnouncementPayload<ExtArgs>[]
      conductedJobInterviews: Prisma.$JobInterviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string
      role: $Enums.Role
      avatar: string | null
      phone: string | null
      isActive: boolean
      emailVerified: boolean
      permissions: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enrollments<T extends User$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interviews<T extends User$interviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$interviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lessonProgress<T extends User$lessonProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$lessonProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends User$postsArgs<ExtArgs> = {}>(args?: Subset<T, User$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends User$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    certificates<T extends User$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, User$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends User$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentTicketMessages<T extends User$sentTicketMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentTicketMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employerProfile<T extends User$employerProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$employerProfileArgs<ExtArgs>>): Prisma__EmployerProfileClient<$Result.GetResult<Prisma.$EmployerProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    jobs<T extends User$jobsArgs<ExtArgs> = {}>(args?: Subset<T, User$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    applications<T extends User$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, User$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedTasks<T extends User$assignedTasksArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdTasks<T extends User$createdTasksArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blogPosts<T extends User$blogPostsArgs<ExtArgs> = {}>(args?: Subset<T, User$blogPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taskComments<T extends User$taskCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$taskCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignmentSubmissions<T extends User$assignmentSubmissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignmentSubmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lessonComments<T extends User$lessonCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$lessonCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    instructedBatches<T extends User$instructedBatchesArgs<ExtArgs> = {}>(args?: Subset<T, User$instructedBatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    announcements<T extends User$announcementsArgs<ExtArgs> = {}>(args?: Subset<T, User$announcementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conductedJobInterviews<T extends User$conductedJobInterviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$conductedJobInterviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobInterviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly permissions: FieldRef<"User", 'Json'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.enrollments
   */
  export type User$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * User.interviews
   */
  export type User$interviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    where?: InterviewWhereInput
    orderBy?: InterviewOrderByWithRelationInput | InterviewOrderByWithRelationInput[]
    cursor?: InterviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterviewScalarFieldEnum | InterviewScalarFieldEnum[]
  }

  /**
   * User.lessonProgress
   */
  export type User$lessonProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    where?: LessonProgressWhereInput
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    cursor?: LessonProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonProgressScalarFieldEnum | LessonProgressScalarFieldEnum[]
  }

  /**
   * User.posts
   */
  export type User$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    where?: ForumPostWhereInput
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    cursor?: ForumPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComment
     */
    omit?: ForumCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    where?: ForumCommentWhereInput
    orderBy?: ForumCommentOrderByWithRelationInput | ForumCommentOrderByWithRelationInput[]
    cursor?: ForumCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumCommentScalarFieldEnum | ForumCommentScalarFieldEnum[]
  }

  /**
   * User.conversations
   */
  export type User$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.certificates
   */
  export type User$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.tickets
   */
  export type User$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.sentTicketMessages
   */
  export type User$sentTicketMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMessage
     */
    omit?: TicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    where?: TicketMessageWhereInput
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    cursor?: TicketMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketMessageScalarFieldEnum | TicketMessageScalarFieldEnum[]
  }

  /**
   * User.employerProfile
   */
  export type User$employerProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployerProfile
     */
    select?: EmployerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployerProfile
     */
    omit?: EmployerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerProfileInclude<ExtArgs> | null
    where?: EmployerProfileWhereInput
  }

  /**
   * User.jobs
   */
  export type User$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * User.applications
   */
  export type User$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    where?: JobApplicationWhereInput
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    cursor?: JobApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }

  /**
   * User.assignedTasks
   */
  export type User$assignedTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.createdTasks
   */
  export type User$createdTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.blogPosts
   */
  export type User$blogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    cursor?: BlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * User.taskComments
   */
  export type User$taskCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    where?: TaskCommentWhereInput
    orderBy?: TaskCommentOrderByWithRelationInput | TaskCommentOrderByWithRelationInput[]
    cursor?: TaskCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskCommentScalarFieldEnum | TaskCommentScalarFieldEnum[]
  }

  /**
   * User.assignmentSubmissions
   */
  export type User$assignmentSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    where?: AssignmentSubmissionWhereInput
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    cursor?: AssignmentSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * User.lessonComments
   */
  export type User$lessonCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    where?: LessonCommentWhereInput
    orderBy?: LessonCommentOrderByWithRelationInput | LessonCommentOrderByWithRelationInput[]
    cursor?: LessonCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonCommentScalarFieldEnum | LessonCommentScalarFieldEnum[]
  }

  /**
   * User.instructedBatches
   */
  export type User$instructedBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * User.announcements
   */
  export type User$announcementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    cursor?: AnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * User.conductedJobInterviews
   */
  export type User$conductedJobInterviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobInterview
     */
    select?: JobInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobInterview
     */
    omit?: JobInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInterviewInclude<ExtArgs> | null
    where?: JobInterviewWhereInput
    orderBy?: JobInterviewOrderByWithRelationInput | JobInterviewOrderByWithRelationInput[]
    cursor?: JobInterviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobInterviewScalarFieldEnum | JobInterviewScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    duration: number | null
    price: Decimal | null
    discountPrice: Decimal | null
    averageRating: number | null
    interviewPrice: Decimal | null
    bundlePrice: Decimal | null
  }

  export type CourseSumAggregateOutputType = {
    duration: number | null
    price: Decimal | null
    discountPrice: Decimal | null
    averageRating: number | null
    interviewPrice: Decimal | null
    bundlePrice: Decimal | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    thumbnail: string | null
    category: string | null
    difficulty: $Enums.Difficulty | null
    duration: number | null
    price: Decimal | null
    discountPrice: Decimal | null
    courseCode: string | null
    bannerUrl: string | null
    averageRating: number | null
    instructorId: string | null
    isPublished: boolean | null
    hasInterviewPrep: boolean | null
    interviewPrice: Decimal | null
    bundlePrice: Decimal | null
    courseType: $Enums.CourseType | null
    publishStatus: $Enums.PublishStatus | null
    publishedAt: Date | null
    reviewNotes: string | null
    submittedForReviewAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    thumbnail: string | null
    category: string | null
    difficulty: $Enums.Difficulty | null
    duration: number | null
    price: Decimal | null
    discountPrice: Decimal | null
    courseCode: string | null
    bannerUrl: string | null
    averageRating: number | null
    instructorId: string | null
    isPublished: boolean | null
    hasInterviewPrep: boolean | null
    interviewPrice: Decimal | null
    bundlePrice: Decimal | null
    courseType: $Enums.CourseType | null
    publishStatus: $Enums.PublishStatus | null
    publishedAt: Date | null
    reviewNotes: string | null
    submittedForReviewAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    title: number
    description: number
    thumbnail: number
    category: number
    difficulty: number
    duration: number
    price: number
    discountPrice: number
    courseCode: number
    jobRoles: number
    bannerUrl: number
    averageRating: number
    instructorId: number
    isPublished: number
    hasInterviewPrep: number
    interviewPrice: number
    bundlePrice: number
    courseType: number
    liveSchedule: number
    hybridConfig: number
    publishStatus: number
    publishedAt: number
    reviewNotes: number
    submittedForReviewAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    duration?: true
    price?: true
    discountPrice?: true
    averageRating?: true
    interviewPrice?: true
    bundlePrice?: true
  }

  export type CourseSumAggregateInputType = {
    duration?: true
    price?: true
    discountPrice?: true
    averageRating?: true
    interviewPrice?: true
    bundlePrice?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnail?: true
    category?: true
    difficulty?: true
    duration?: true
    price?: true
    discountPrice?: true
    courseCode?: true
    bannerUrl?: true
    averageRating?: true
    instructorId?: true
    isPublished?: true
    hasInterviewPrep?: true
    interviewPrice?: true
    bundlePrice?: true
    courseType?: true
    publishStatus?: true
    publishedAt?: true
    reviewNotes?: true
    submittedForReviewAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnail?: true
    category?: true
    difficulty?: true
    duration?: true
    price?: true
    discountPrice?: true
    courseCode?: true
    bannerUrl?: true
    averageRating?: true
    instructorId?: true
    isPublished?: true
    hasInterviewPrep?: true
    interviewPrice?: true
    bundlePrice?: true
    courseType?: true
    publishStatus?: true
    publishedAt?: true
    reviewNotes?: true
    submittedForReviewAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnail?: true
    category?: true
    difficulty?: true
    duration?: true
    price?: true
    discountPrice?: true
    courseCode?: true
    jobRoles?: true
    bannerUrl?: true
    averageRating?: true
    instructorId?: true
    isPublished?: true
    hasInterviewPrep?: true
    interviewPrice?: true
    bundlePrice?: true
    courseType?: true
    liveSchedule?: true
    hybridConfig?: true
    publishStatus?: true
    publishedAt?: true
    reviewNotes?: true
    submittedForReviewAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    title: string
    description: string
    thumbnail: string | null
    category: string
    difficulty: $Enums.Difficulty
    duration: number
    price: Decimal
    discountPrice: Decimal
    courseCode: string | null
    jobRoles: JsonValue | null
    bannerUrl: string | null
    averageRating: number
    instructorId: string
    isPublished: boolean
    hasInterviewPrep: boolean
    interviewPrice: Decimal
    bundlePrice: Decimal
    courseType: $Enums.CourseType
    liveSchedule: JsonValue | null
    hybridConfig: JsonValue | null
    publishStatus: $Enums.PublishStatus
    publishedAt: Date | null
    reviewNotes: string | null
    submittedForReviewAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    price?: boolean
    discountPrice?: boolean
    courseCode?: boolean
    jobRoles?: boolean
    bannerUrl?: boolean
    averageRating?: boolean
    instructorId?: boolean
    isPublished?: boolean
    hasInterviewPrep?: boolean
    interviewPrice?: boolean
    bundlePrice?: boolean
    courseType?: boolean
    liveSchedule?: boolean
    hybridConfig?: boolean
    publishStatus?: boolean
    publishedAt?: boolean
    reviewNotes?: boolean
    submittedForReviewAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    modules?: boolean | Course$modulesArgs<ExtArgs>
    enrollments?: boolean | Course$enrollmentsArgs<ExtArgs>
    payments?: boolean | Course$paymentsArgs<ExtArgs>
    reviews?: boolean | Course$reviewsArgs<ExtArgs>
    liveClasses?: boolean | Course$liveClassesArgs<ExtArgs>
    batches?: boolean | Course$batchesArgs<ExtArgs>
    announcements?: boolean | Course$announcementsArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    price?: boolean
    discountPrice?: boolean
    courseCode?: boolean
    jobRoles?: boolean
    bannerUrl?: boolean
    averageRating?: boolean
    instructorId?: boolean
    isPublished?: boolean
    hasInterviewPrep?: boolean
    interviewPrice?: boolean
    bundlePrice?: boolean
    courseType?: boolean
    liveSchedule?: boolean
    hybridConfig?: boolean
    publishStatus?: boolean
    publishedAt?: boolean
    reviewNotes?: boolean
    submittedForReviewAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["course"]>

  export type CourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    price?: boolean
    discountPrice?: boolean
    courseCode?: boolean
    jobRoles?: boolean
    bannerUrl?: boolean
    averageRating?: boolean
    instructorId?: boolean
    isPublished?: boolean
    hasInterviewPrep?: boolean
    interviewPrice?: boolean
    bundlePrice?: boolean
    courseType?: boolean
    liveSchedule?: boolean
    hybridConfig?: boolean
    publishStatus?: boolean
    publishedAt?: boolean
    reviewNotes?: boolean
    submittedForReviewAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    price?: boolean
    discountPrice?: boolean
    courseCode?: boolean
    jobRoles?: boolean
    bannerUrl?: boolean
    averageRating?: boolean
    instructorId?: boolean
    isPublished?: boolean
    hasInterviewPrep?: boolean
    interviewPrice?: boolean
    bundlePrice?: boolean
    courseType?: boolean
    liveSchedule?: boolean
    hybridConfig?: boolean
    publishStatus?: boolean
    publishedAt?: boolean
    reviewNotes?: boolean
    submittedForReviewAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "thumbnail" | "category" | "difficulty" | "duration" | "price" | "discountPrice" | "courseCode" | "jobRoles" | "bannerUrl" | "averageRating" | "instructorId" | "isPublished" | "hasInterviewPrep" | "interviewPrice" | "bundlePrice" | "courseType" | "liveSchedule" | "hybridConfig" | "publishStatus" | "publishedAt" | "reviewNotes" | "submittedForReviewAt" | "createdAt" | "updatedAt", ExtArgs["result"]["course"]>
  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modules?: boolean | Course$modulesArgs<ExtArgs>
    enrollments?: boolean | Course$enrollmentsArgs<ExtArgs>
    payments?: boolean | Course$paymentsArgs<ExtArgs>
    reviews?: boolean | Course$reviewsArgs<ExtArgs>
    liveClasses?: boolean | Course$liveClassesArgs<ExtArgs>
    batches?: boolean | Course$batchesArgs<ExtArgs>
    announcements?: boolean | Course$announcementsArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      modules: Prisma.$ModulePayload<ExtArgs>[]
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      liveClasses: Prisma.$LiveClassPayload<ExtArgs>[]
      batches: Prisma.$BatchPayload<ExtArgs>[]
      announcements: Prisma.$AnnouncementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      thumbnail: string | null
      category: string
      difficulty: $Enums.Difficulty
      duration: number
      price: Prisma.Decimal
      discountPrice: Prisma.Decimal
      courseCode: string | null
      jobRoles: Prisma.JsonValue | null
      bannerUrl: string | null
      averageRating: number
      instructorId: string
      isPublished: boolean
      hasInterviewPrep: boolean
      interviewPrice: Prisma.Decimal
      bundlePrice: Prisma.Decimal
      courseType: $Enums.CourseType
      liveSchedule: Prisma.JsonValue | null
      hybridConfig: Prisma.JsonValue | null
      publishStatus: $Enums.PublishStatus
      publishedAt: Date | null
      reviewNotes: string | null
      submittedForReviewAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses and returns the data updated in the database.
     * @param {CourseUpdateManyAndReturnArgs} args - Arguments to update many Courses.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    modules<T extends Course$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Course$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends Course$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Course$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Course$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Course$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Course$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Course$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    liveClasses<T extends Course$liveClassesArgs<ExtArgs> = {}>(args?: Subset<T, Course$liveClassesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiveClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    batches<T extends Course$batchesArgs<ExtArgs> = {}>(args?: Subset<T, Course$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    announcements<T extends Course$announcementsArgs<ExtArgs> = {}>(args?: Subset<T, Course$announcementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly title: FieldRef<"Course", 'String'>
    readonly description: FieldRef<"Course", 'String'>
    readonly thumbnail: FieldRef<"Course", 'String'>
    readonly category: FieldRef<"Course", 'String'>
    readonly difficulty: FieldRef<"Course", 'Difficulty'>
    readonly duration: FieldRef<"Course", 'Int'>
    readonly price: FieldRef<"Course", 'Decimal'>
    readonly discountPrice: FieldRef<"Course", 'Decimal'>
    readonly courseCode: FieldRef<"Course", 'String'>
    readonly jobRoles: FieldRef<"Course", 'Json'>
    readonly bannerUrl: FieldRef<"Course", 'String'>
    readonly averageRating: FieldRef<"Course", 'Float'>
    readonly instructorId: FieldRef<"Course", 'String'>
    readonly isPublished: FieldRef<"Course", 'Boolean'>
    readonly hasInterviewPrep: FieldRef<"Course", 'Boolean'>
    readonly interviewPrice: FieldRef<"Course", 'Decimal'>
    readonly bundlePrice: FieldRef<"Course", 'Decimal'>
    readonly courseType: FieldRef<"Course", 'CourseType'>
    readonly liveSchedule: FieldRef<"Course", 'Json'>
    readonly hybridConfig: FieldRef<"Course", 'Json'>
    readonly publishStatus: FieldRef<"Course", 'PublishStatus'>
    readonly publishedAt: FieldRef<"Course", 'DateTime'>
    readonly reviewNotes: FieldRef<"Course", 'String'>
    readonly submittedForReviewAt: FieldRef<"Course", 'DateTime'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course updateManyAndReturn
   */
  export type CourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to delete.
     */
    limit?: number
  }

  /**
   * Course.modules
   */
  export type Course$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    cursor?: ModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Course.enrollments
   */
  export type Course$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Course.payments
   */
  export type Course$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Course.reviews
   */
  export type Course$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Course.liveClasses
   */
  export type Course$liveClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveClass
     */
    select?: LiveClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiveClass
     */
    omit?: LiveClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveClassInclude<ExtArgs> | null
    where?: LiveClassWhereInput
    orderBy?: LiveClassOrderByWithRelationInput | LiveClassOrderByWithRelationInput[]
    cursor?: LiveClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiveClassScalarFieldEnum | LiveClassScalarFieldEnum[]
  }

  /**
   * Course.batches
   */
  export type Course$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Course.announcements
   */
  export type Course$announcementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    cursor?: AnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model Batch
   */

  export type AggregateBatch = {
    _count: BatchCountAggregateOutputType | null
    _avg: BatchAvgAggregateOutputType | null
    _sum: BatchSumAggregateOutputType | null
    _min: BatchMinAggregateOutputType | null
    _max: BatchMaxAggregateOutputType | null
  }

  export type BatchAvgAggregateOutputType = {
    maxStudents: number | null
  }

  export type BatchSumAggregateOutputType = {
    maxStudents: number | null
  }

  export type BatchMinAggregateOutputType = {
    id: string | null
    name: string | null
    courseId: string | null
    instructorId: string | null
    startDate: Date | null
    endDate: Date | null
    description: string | null
    maxStudents: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchMaxAggregateOutputType = {
    id: string | null
    name: string | null
    courseId: string | null
    instructorId: string | null
    startDate: Date | null
    endDate: Date | null
    description: string | null
    maxStudents: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchCountAggregateOutputType = {
    id: number
    name: number
    courseId: number
    instructorId: number
    startDate: number
    endDate: number
    description: number
    maxStudents: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BatchAvgAggregateInputType = {
    maxStudents?: true
  }

  export type BatchSumAggregateInputType = {
    maxStudents?: true
  }

  export type BatchMinAggregateInputType = {
    id?: true
    name?: true
    courseId?: true
    instructorId?: true
    startDate?: true
    endDate?: true
    description?: true
    maxStudents?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchMaxAggregateInputType = {
    id?: true
    name?: true
    courseId?: true
    instructorId?: true
    startDate?: true
    endDate?: true
    description?: true
    maxStudents?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchCountAggregateInputType = {
    id?: true
    name?: true
    courseId?: true
    instructorId?: true
    startDate?: true
    endDate?: true
    description?: true
    maxStudents?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Batch to aggregate.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Batches
    **/
    _count?: true | BatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchMaxAggregateInputType
  }

  export type GetBatchAggregateType<T extends BatchAggregateArgs> = {
        [P in keyof T & keyof AggregateBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatch[P]>
      : GetScalarType<T[P], AggregateBatch[P]>
  }




  export type BatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithAggregationInput | BatchOrderByWithAggregationInput[]
    by: BatchScalarFieldEnum[] | BatchScalarFieldEnum
    having?: BatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchCountAggregateInputType | true
    _avg?: BatchAvgAggregateInputType
    _sum?: BatchSumAggregateInputType
    _min?: BatchMinAggregateInputType
    _max?: BatchMaxAggregateInputType
  }

  export type BatchGroupByOutputType = {
    id: string
    name: string
    courseId: string
    instructorId: string
    startDate: Date | null
    endDate: Date | null
    description: string | null
    maxStudents: number | null
    createdAt: Date
    updatedAt: Date
    _count: BatchCountAggregateOutputType | null
    _avg: BatchAvgAggregateOutputType | null
    _sum: BatchSumAggregateOutputType | null
    _min: BatchMinAggregateOutputType | null
    _max: BatchMaxAggregateOutputType | null
  }

  type GetBatchGroupByPayload<T extends BatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchGroupByOutputType[P]>
            : GetScalarType<T[P], BatchGroupByOutputType[P]>
        }
      >
    >


  export type BatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    courseId?: boolean
    instructorId?: boolean
    startDate?: boolean
    endDate?: boolean
    description?: boolean
    maxStudents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    instructor?: boolean | UserDefaultArgs<ExtArgs>
    announcements?: boolean | Batch$announcementsArgs<ExtArgs>
    enrollments?: boolean | Batch$enrollmentsArgs<ExtArgs>
    _count?: boolean | BatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    courseId?: boolean
    instructorId?: boolean
    startDate?: boolean
    endDate?: boolean
    description?: boolean
    maxStudents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    instructor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    courseId?: boolean
    instructorId?: boolean
    startDate?: boolean
    endDate?: boolean
    description?: boolean
    maxStudents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    instructor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectScalar = {
    id?: boolean
    name?: boolean
    courseId?: boolean
    instructorId?: boolean
    startDate?: boolean
    endDate?: boolean
    description?: boolean
    maxStudents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "courseId" | "instructorId" | "startDate" | "endDate" | "description" | "maxStudents" | "createdAt" | "updatedAt", ExtArgs["result"]["batch"]>
  export type BatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    instructor?: boolean | UserDefaultArgs<ExtArgs>
    announcements?: boolean | Batch$announcementsArgs<ExtArgs>
    enrollments?: boolean | Batch$enrollmentsArgs<ExtArgs>
    _count?: boolean | BatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    instructor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    instructor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Batch"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      instructor: Prisma.$UserPayload<ExtArgs>
      announcements: Prisma.$AnnouncementPayload<ExtArgs>[]
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      courseId: string
      instructorId: string
      startDate: Date | null
      endDate: Date | null
      description: string | null
      maxStudents: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["batch"]>
    composites: {}
  }

  type BatchGetPayload<S extends boolean | null | undefined | BatchDefaultArgs> = $Result.GetResult<Prisma.$BatchPayload, S>

  type BatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BatchCountAggregateInputType | true
    }

  export interface BatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Batch'], meta: { name: 'Batch' } }
    /**
     * Find zero or one Batch that matches the filter.
     * @param {BatchFindUniqueArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatchFindUniqueArgs>(args: SelectSubset<T, BatchFindUniqueArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Batch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BatchFindUniqueOrThrowArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatchFindUniqueOrThrowArgs>(args: SelectSubset<T, BatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Batch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindFirstArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatchFindFirstArgs>(args?: SelectSubset<T, BatchFindFirstArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Batch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindFirstOrThrowArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatchFindFirstOrThrowArgs>(args?: SelectSubset<T, BatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Batches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Batches
     * const batches = await prisma.batch.findMany()
     * 
     * // Get first 10 Batches
     * const batches = await prisma.batch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batchWithIdOnly = await prisma.batch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BatchFindManyArgs>(args?: SelectSubset<T, BatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Batch.
     * @param {BatchCreateArgs} args - Arguments to create a Batch.
     * @example
     * // Create one Batch
     * const Batch = await prisma.batch.create({
     *   data: {
     *     // ... data to create a Batch
     *   }
     * })
     * 
     */
    create<T extends BatchCreateArgs>(args: SelectSubset<T, BatchCreateArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Batches.
     * @param {BatchCreateManyArgs} args - Arguments to create many Batches.
     * @example
     * // Create many Batches
     * const batch = await prisma.batch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatchCreateManyArgs>(args?: SelectSubset<T, BatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Batches and returns the data saved in the database.
     * @param {BatchCreateManyAndReturnArgs} args - Arguments to create many Batches.
     * @example
     * // Create many Batches
     * const batch = await prisma.batch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Batches and only return the `id`
     * const batchWithIdOnly = await prisma.batch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BatchCreateManyAndReturnArgs>(args?: SelectSubset<T, BatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Batch.
     * @param {BatchDeleteArgs} args - Arguments to delete one Batch.
     * @example
     * // Delete one Batch
     * const Batch = await prisma.batch.delete({
     *   where: {
     *     // ... filter to delete one Batch
     *   }
     * })
     * 
     */
    delete<T extends BatchDeleteArgs>(args: SelectSubset<T, BatchDeleteArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Batch.
     * @param {BatchUpdateArgs} args - Arguments to update one Batch.
     * @example
     * // Update one Batch
     * const batch = await prisma.batch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatchUpdateArgs>(args: SelectSubset<T, BatchUpdateArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Batches.
     * @param {BatchDeleteManyArgs} args - Arguments to filter Batches to delete.
     * @example
     * // Delete a few Batches
     * const { count } = await prisma.batch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatchDeleteManyArgs>(args?: SelectSubset<T, BatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Batches
     * const batch = await prisma.batch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatchUpdateManyArgs>(args: SelectSubset<T, BatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Batches and returns the data updated in the database.
     * @param {BatchUpdateManyAndReturnArgs} args - Arguments to update many Batches.
     * @example
     * // Update many Batches
     * const batch = await prisma.batch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Batches and only return the `id`
     * const batchWithIdOnly = await prisma.batch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BatchUpdateManyAndReturnArgs>(args: SelectSubset<T, BatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Batch.
     * @param {BatchUpsertArgs} args - Arguments to update or create a Batch.
     * @example
     * // Update or create a Batch
     * const batch = await prisma.batch.upsert({
     *   create: {
     *     // ... data to create a Batch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Batch we want to update
     *   }
     * })
     */
    upsert<T extends BatchUpsertArgs>(args: SelectSubset<T, BatchUpsertArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchCountArgs} args - Arguments to filter Batches to count.
     * @example
     * // Count the number of Batches
     * const count = await prisma.batch.count({
     *   where: {
     *     // ... the filter for the Batches we want to count
     *   }
     * })
    **/
    count<T extends BatchCountArgs>(
      args?: Subset<T, BatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Batch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchAggregateArgs>(args: Subset<T, BatchAggregateArgs>): Prisma.PrismaPromise<GetBatchAggregateType<T>>

    /**
     * Group by Batch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatchGroupByArgs['orderBy'] }
        : { orderBy?: BatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Batch model
   */
  readonly fields: BatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Batch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    instructor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    announcements<T extends Batch$announcementsArgs<ExtArgs> = {}>(args?: Subset<T, Batch$announcementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends Batch$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Batch$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Batch model
   */
  interface BatchFieldRefs {
    readonly id: FieldRef<"Batch", 'String'>
    readonly name: FieldRef<"Batch", 'String'>
    readonly courseId: FieldRef<"Batch", 'String'>
    readonly instructorId: FieldRef<"Batch", 'String'>
    readonly startDate: FieldRef<"Batch", 'DateTime'>
    readonly endDate: FieldRef<"Batch", 'DateTime'>
    readonly description: FieldRef<"Batch", 'String'>
    readonly maxStudents: FieldRef<"Batch", 'Int'>
    readonly createdAt: FieldRef<"Batch", 'DateTime'>
    readonly updatedAt: FieldRef<"Batch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Batch findUnique
   */
  export type BatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch findUniqueOrThrow
   */
  export type BatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch findFirst
   */
  export type BatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Batches.
     */
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch findFirstOrThrow
   */
  export type BatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Batches.
     */
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch findMany
   */
  export type BatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batches to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch create
   */
  export type BatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The data needed to create a Batch.
     */
    data: XOR<BatchCreateInput, BatchUncheckedCreateInput>
  }

  /**
   * Batch createMany
   */
  export type BatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Batches.
     */
    data: BatchCreateManyInput | BatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Batch createManyAndReturn
   */
  export type BatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * The data used to create many Batches.
     */
    data: BatchCreateManyInput | BatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Batch update
   */
  export type BatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The data needed to update a Batch.
     */
    data: XOR<BatchUpdateInput, BatchUncheckedUpdateInput>
    /**
     * Choose, which Batch to update.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch updateMany
   */
  export type BatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Batches.
     */
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyInput>
    /**
     * Filter which Batches to update
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to update.
     */
    limit?: number
  }

  /**
   * Batch updateManyAndReturn
   */
  export type BatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * The data used to update Batches.
     */
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyInput>
    /**
     * Filter which Batches to update
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Batch upsert
   */
  export type BatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The filter to search for the Batch to update in case it exists.
     */
    where: BatchWhereUniqueInput
    /**
     * In case the Batch found by the `where` argument doesn't exist, create a new Batch with this data.
     */
    create: XOR<BatchCreateInput, BatchUncheckedCreateInput>
    /**
     * In case the Batch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatchUpdateInput, BatchUncheckedUpdateInput>
  }

  /**
   * Batch delete
   */
  export type BatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter which Batch to delete.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch deleteMany
   */
  export type BatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Batches to delete
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to delete.
     */
    limit?: number
  }

  /**
   * Batch.announcements
   */
  export type Batch$announcementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    cursor?: AnnouncementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Batch.enrollments
   */
  export type Batch$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Batch without action
   */
  export type BatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
  }


  /**
   * Model Announcement
   */

  export type AggregateAnnouncement = {
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  export type AnnouncementMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    priority: string | null
    courseId: string | null
    batchId: string | null
    instructorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnnouncementMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    priority: string | null
    courseId: string | null
    batchId: string | null
    instructorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnnouncementCountAggregateOutputType = {
    id: number
    title: number
    content: number
    priority: number
    courseId: number
    batchId: number
    instructorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnnouncementMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    priority?: true
    courseId?: true
    batchId?: true
    instructorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnnouncementMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    priority?: true
    courseId?: true
    batchId?: true
    instructorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnnouncementCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    priority?: true
    courseId?: true
    batchId?: true
    instructorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnnouncementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcement to aggregate.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Announcements
    **/
    _count?: true | AnnouncementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementMaxAggregateInputType
  }

  export type GetAnnouncementAggregateType<T extends AnnouncementAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncement[P]>
      : GetScalarType<T[P], AggregateAnnouncement[P]>
  }




  export type AnnouncementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithAggregationInput | AnnouncementOrderByWithAggregationInput[]
    by: AnnouncementScalarFieldEnum[] | AnnouncementScalarFieldEnum
    having?: AnnouncementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementCountAggregateInputType | true
    _min?: AnnouncementMinAggregateInputType
    _max?: AnnouncementMaxAggregateInputType
  }

  export type AnnouncementGroupByOutputType = {
    id: string
    title: string
    content: string
    priority: string
    courseId: string | null
    batchId: string | null
    instructorId: string
    createdAt: Date
    updatedAt: Date
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  type GetAnnouncementGroupByPayload<T extends AnnouncementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
        }
      >
    >


  export type AnnouncementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    priority?: boolean
    courseId?: boolean
    batchId?: boolean
    instructorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | Announcement$courseArgs<ExtArgs>
    batch?: boolean | Announcement$batchArgs<ExtArgs>
    instructor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    priority?: boolean
    courseId?: boolean
    batchId?: boolean
    instructorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | Announcement$courseArgs<ExtArgs>
    batch?: boolean | Announcement$batchArgs<ExtArgs>
    instructor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    priority?: boolean
    courseId?: boolean
    batchId?: boolean
    instructorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | Announcement$courseArgs<ExtArgs>
    batch?: boolean | Announcement$batchArgs<ExtArgs>
    instructor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    priority?: boolean
    courseId?: boolean
    batchId?: boolean
    instructorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnnouncementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "priority" | "courseId" | "batchId" | "instructorId" | "createdAt" | "updatedAt", ExtArgs["result"]["announcement"]>
  export type AnnouncementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | Announcement$courseArgs<ExtArgs>
    batch?: boolean | Announcement$batchArgs<ExtArgs>
    instructor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnnouncementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | Announcement$courseArgs<ExtArgs>
    batch?: boolean | Announcement$batchArgs<ExtArgs>
    instructor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AnnouncementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | Announcement$courseArgs<ExtArgs>
    batch?: boolean | Announcement$batchArgs<ExtArgs>
    instructor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AnnouncementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Announcement"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs> | null
      batch: Prisma.$BatchPayload<ExtArgs> | null
      instructor: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      priority: string
      courseId: string | null
      batchId: string | null
      instructorId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["announcement"]>
    composites: {}
  }

  type AnnouncementGetPayload<S extends boolean | null | undefined | AnnouncementDefaultArgs> = $Result.GetResult<Prisma.$AnnouncementPayload, S>

  type AnnouncementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnnouncementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnouncementCountAggregateInputType | true
    }

  export interface AnnouncementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Announcement'], meta: { name: 'Announcement' } }
    /**
     * Find zero or one Announcement that matches the filter.
     * @param {AnnouncementFindUniqueArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementFindUniqueArgs>(args: SelectSubset<T, AnnouncementFindUniqueArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Announcement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnouncementFindUniqueOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnouncementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementFindFirstArgs>(args?: SelectSubset<T, AnnouncementFindFirstArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnouncementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcement.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementWithIdOnly = await prisma.announcement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnnouncementFindManyArgs>(args?: SelectSubset<T, AnnouncementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Announcement.
     * @param {AnnouncementCreateArgs} args - Arguments to create a Announcement.
     * @example
     * // Create one Announcement
     * const Announcement = await prisma.announcement.create({
     *   data: {
     *     // ... data to create a Announcement
     *   }
     * })
     * 
     */
    create<T extends AnnouncementCreateArgs>(args: SelectSubset<T, AnnouncementCreateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Announcements.
     * @param {AnnouncementCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnouncementCreateManyArgs>(args?: SelectSubset<T, AnnouncementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Announcements and returns the data saved in the database.
     * @param {AnnouncementCreateManyAndReturnArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Announcements and only return the `id`
     * const announcementWithIdOnly = await prisma.announcement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnnouncementCreateManyAndReturnArgs>(args?: SelectSubset<T, AnnouncementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Announcement.
     * @param {AnnouncementDeleteArgs} args - Arguments to delete one Announcement.
     * @example
     * // Delete one Announcement
     * const Announcement = await prisma.announcement.delete({
     *   where: {
     *     // ... filter to delete one Announcement
     *   }
     * })
     * 
     */
    delete<T extends AnnouncementDeleteArgs>(args: SelectSubset<T, AnnouncementDeleteArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Announcement.
     * @param {AnnouncementUpdateArgs} args - Arguments to update one Announcement.
     * @example
     * // Update one Announcement
     * const announcement = await prisma.announcement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnouncementUpdateArgs>(args: SelectSubset<T, AnnouncementUpdateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Announcements.
     * @param {AnnouncementDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnouncementDeleteManyArgs>(args?: SelectSubset<T, AnnouncementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnouncementUpdateManyArgs>(args: SelectSubset<T, AnnouncementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements and returns the data updated in the database.
     * @param {AnnouncementUpdateManyAndReturnArgs} args - Arguments to update many Announcements.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Announcements and only return the `id`
     * const announcementWithIdOnly = await prisma.announcement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnnouncementUpdateManyAndReturnArgs>(args: SelectSubset<T, AnnouncementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Announcement.
     * @param {AnnouncementUpsertArgs} args - Arguments to update or create a Announcement.
     * @example
     * // Update or create a Announcement
     * const announcement = await prisma.announcement.upsert({
     *   create: {
     *     // ... data to create a Announcement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcement we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementUpsertArgs>(args: SelectSubset<T, AnnouncementUpsertArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcement.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends AnnouncementCountArgs>(
      args?: Subset<T, AnnouncementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementAggregateArgs>(args: Subset<T, AnnouncementAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementAggregateType<T>>

    /**
     * Group by Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnouncementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnouncementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Announcement model
   */
  readonly fields: AnnouncementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Announcement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends Announcement$courseArgs<ExtArgs> = {}>(args?: Subset<T, Announcement$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    batch<T extends Announcement$batchArgs<ExtArgs> = {}>(args?: Subset<T, Announcement$batchArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    instructor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Announcement model
   */
  interface AnnouncementFieldRefs {
    readonly id: FieldRef<"Announcement", 'String'>
    readonly title: FieldRef<"Announcement", 'String'>
    readonly content: FieldRef<"Announcement", 'String'>
    readonly priority: FieldRef<"Announcement", 'String'>
    readonly courseId: FieldRef<"Announcement", 'String'>
    readonly batchId: FieldRef<"Announcement", 'String'>
    readonly instructorId: FieldRef<"Announcement", 'String'>
    readonly createdAt: FieldRef<"Announcement", 'DateTime'>
    readonly updatedAt: FieldRef<"Announcement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Announcement findUnique
   */
  export type AnnouncementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findUniqueOrThrow
   */
  export type AnnouncementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findFirst
   */
  export type AnnouncementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findFirstOrThrow
   */
  export type AnnouncementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findMany
   */
  export type AnnouncementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement create
   */
  export type AnnouncementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to create a Announcement.
     */
    data: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
  }

  /**
   * Announcement createMany
   */
  export type AnnouncementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Announcement createManyAndReturn
   */
  export type AnnouncementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Announcement update
   */
  export type AnnouncementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The data needed to update a Announcement.
     */
    data: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
    /**
     * Choose, which Announcement to update.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement updateMany
   */
  export type AnnouncementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
  }

  /**
   * Announcement updateManyAndReturn
   */
  export type AnnouncementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Announcement upsert
   */
  export type AnnouncementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * The filter to search for the Announcement to update in case it exists.
     */
    where: AnnouncementWhereUniqueInput
    /**
     * In case the Announcement found by the `where` argument doesn't exist, create a new Announcement with this data.
     */
    create: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
    /**
     * In case the Announcement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
  }

  /**
   * Announcement delete
   */
  export type AnnouncementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
    /**
     * Filter which Announcement to delete.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement deleteMany
   */
  export type AnnouncementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcements to delete
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to delete.
     */
    limit?: number
  }

  /**
   * Announcement.course
   */
  export type Announcement$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * Announcement.batch
   */
  export type Announcement$batchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
  }

  /**
   * Announcement without action
   */
  export type AnnouncementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null
  }


  /**
   * Model LessonComment
   */

  export type AggregateLessonComment = {
    _count: LessonCommentCountAggregateOutputType | null
    _min: LessonCommentMinAggregateOutputType | null
    _max: LessonCommentMaxAggregateOutputType | null
  }

  export type LessonCommentMinAggregateOutputType = {
    id: string | null
    lessonId: string | null
    userId: string | null
    content: string | null
    parentId: string | null
    isPinned: boolean | null
    isInstructorResponse: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LessonCommentMaxAggregateOutputType = {
    id: string | null
    lessonId: string | null
    userId: string | null
    content: string | null
    parentId: string | null
    isPinned: boolean | null
    isInstructorResponse: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LessonCommentCountAggregateOutputType = {
    id: number
    lessonId: number
    userId: number
    content: number
    parentId: number
    isPinned: number
    isInstructorResponse: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LessonCommentMinAggregateInputType = {
    id?: true
    lessonId?: true
    userId?: true
    content?: true
    parentId?: true
    isPinned?: true
    isInstructorResponse?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LessonCommentMaxAggregateInputType = {
    id?: true
    lessonId?: true
    userId?: true
    content?: true
    parentId?: true
    isPinned?: true
    isInstructorResponse?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LessonCommentCountAggregateInputType = {
    id?: true
    lessonId?: true
    userId?: true
    content?: true
    parentId?: true
    isPinned?: true
    isInstructorResponse?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LessonCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonComment to aggregate.
     */
    where?: LessonCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonComments to fetch.
     */
    orderBy?: LessonCommentOrderByWithRelationInput | LessonCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LessonComments
    **/
    _count?: true | LessonCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonCommentMaxAggregateInputType
  }

  export type GetLessonCommentAggregateType<T extends LessonCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateLessonComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessonComment[P]>
      : GetScalarType<T[P], AggregateLessonComment[P]>
  }




  export type LessonCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonCommentWhereInput
    orderBy?: LessonCommentOrderByWithAggregationInput | LessonCommentOrderByWithAggregationInput[]
    by: LessonCommentScalarFieldEnum[] | LessonCommentScalarFieldEnum
    having?: LessonCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCommentCountAggregateInputType | true
    _min?: LessonCommentMinAggregateInputType
    _max?: LessonCommentMaxAggregateInputType
  }

  export type LessonCommentGroupByOutputType = {
    id: string
    lessonId: string
    userId: string
    content: string
    parentId: string | null
    isPinned: boolean
    isInstructorResponse: boolean
    createdAt: Date
    updatedAt: Date
    _count: LessonCommentCountAggregateOutputType | null
    _min: LessonCommentMinAggregateOutputType | null
    _max: LessonCommentMaxAggregateOutputType | null
  }

  type GetLessonCommentGroupByPayload<T extends LessonCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonCommentGroupByOutputType[P]>
            : GetScalarType<T[P], LessonCommentGroupByOutputType[P]>
        }
      >
    >


  export type LessonCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    userId?: boolean
    content?: boolean
    parentId?: boolean
    isPinned?: boolean
    isInstructorResponse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | LessonComment$parentArgs<ExtArgs>
    replies?: boolean | LessonComment$repliesArgs<ExtArgs>
    _count?: boolean | LessonCommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonComment"]>

  export type LessonCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    userId?: boolean
    content?: boolean
    parentId?: boolean
    isPinned?: boolean
    isInstructorResponse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | LessonComment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["lessonComment"]>

  export type LessonCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    userId?: boolean
    content?: boolean
    parentId?: boolean
    isPinned?: boolean
    isInstructorResponse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | LessonComment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["lessonComment"]>

  export type LessonCommentSelectScalar = {
    id?: boolean
    lessonId?: boolean
    userId?: boolean
    content?: boolean
    parentId?: boolean
    isPinned?: boolean
    isInstructorResponse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LessonCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lessonId" | "userId" | "content" | "parentId" | "isPinned" | "isInstructorResponse" | "createdAt" | "updatedAt", ExtArgs["result"]["lessonComment"]>
  export type LessonCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | LessonComment$parentArgs<ExtArgs>
    replies?: boolean | LessonComment$repliesArgs<ExtArgs>
    _count?: boolean | LessonCommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LessonCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | LessonComment$parentArgs<ExtArgs>
  }
  export type LessonCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | LessonComment$parentArgs<ExtArgs>
  }

  export type $LessonCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LessonComment"
    objects: {
      lesson: Prisma.$LessonPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      parent: Prisma.$LessonCommentPayload<ExtArgs> | null
      replies: Prisma.$LessonCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lessonId: string
      userId: string
      content: string
      parentId: string | null
      isPinned: boolean
      isInstructorResponse: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lessonComment"]>
    composites: {}
  }

  type LessonCommentGetPayload<S extends boolean | null | undefined | LessonCommentDefaultArgs> = $Result.GetResult<Prisma.$LessonCommentPayload, S>

  type LessonCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonCommentCountAggregateInputType | true
    }

  export interface LessonCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LessonComment'], meta: { name: 'LessonComment' } }
    /**
     * Find zero or one LessonComment that matches the filter.
     * @param {LessonCommentFindUniqueArgs} args - Arguments to find a LessonComment
     * @example
     * // Get one LessonComment
     * const lessonComment = await prisma.lessonComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonCommentFindUniqueArgs>(args: SelectSubset<T, LessonCommentFindUniqueArgs<ExtArgs>>): Prisma__LessonCommentClient<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LessonComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonCommentFindUniqueOrThrowArgs} args - Arguments to find a LessonComment
     * @example
     * // Get one LessonComment
     * const lessonComment = await prisma.lessonComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonCommentClient<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCommentFindFirstArgs} args - Arguments to find a LessonComment
     * @example
     * // Get one LessonComment
     * const lessonComment = await prisma.lessonComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonCommentFindFirstArgs>(args?: SelectSubset<T, LessonCommentFindFirstArgs<ExtArgs>>): Prisma__LessonCommentClient<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCommentFindFirstOrThrowArgs} args - Arguments to find a LessonComment
     * @example
     * // Get one LessonComment
     * const lessonComment = await prisma.lessonComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonCommentClient<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LessonComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LessonComments
     * const lessonComments = await prisma.lessonComment.findMany()
     * 
     * // Get first 10 LessonComments
     * const lessonComments = await prisma.lessonComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonCommentWithIdOnly = await prisma.lessonComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonCommentFindManyArgs>(args?: SelectSubset<T, LessonCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LessonComment.
     * @param {LessonCommentCreateArgs} args - Arguments to create a LessonComment.
     * @example
     * // Create one LessonComment
     * const LessonComment = await prisma.lessonComment.create({
     *   data: {
     *     // ... data to create a LessonComment
     *   }
     * })
     * 
     */
    create<T extends LessonCommentCreateArgs>(args: SelectSubset<T, LessonCommentCreateArgs<ExtArgs>>): Prisma__LessonCommentClient<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LessonComments.
     * @param {LessonCommentCreateManyArgs} args - Arguments to create many LessonComments.
     * @example
     * // Create many LessonComments
     * const lessonComment = await prisma.lessonComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonCommentCreateManyArgs>(args?: SelectSubset<T, LessonCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LessonComments and returns the data saved in the database.
     * @param {LessonCommentCreateManyAndReturnArgs} args - Arguments to create many LessonComments.
     * @example
     * // Create many LessonComments
     * const lessonComment = await prisma.lessonComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LessonComments and only return the `id`
     * const lessonCommentWithIdOnly = await prisma.lessonComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LessonComment.
     * @param {LessonCommentDeleteArgs} args - Arguments to delete one LessonComment.
     * @example
     * // Delete one LessonComment
     * const LessonComment = await prisma.lessonComment.delete({
     *   where: {
     *     // ... filter to delete one LessonComment
     *   }
     * })
     * 
     */
    delete<T extends LessonCommentDeleteArgs>(args: SelectSubset<T, LessonCommentDeleteArgs<ExtArgs>>): Prisma__LessonCommentClient<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LessonComment.
     * @param {LessonCommentUpdateArgs} args - Arguments to update one LessonComment.
     * @example
     * // Update one LessonComment
     * const lessonComment = await prisma.lessonComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonCommentUpdateArgs>(args: SelectSubset<T, LessonCommentUpdateArgs<ExtArgs>>): Prisma__LessonCommentClient<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LessonComments.
     * @param {LessonCommentDeleteManyArgs} args - Arguments to filter LessonComments to delete.
     * @example
     * // Delete a few LessonComments
     * const { count } = await prisma.lessonComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonCommentDeleteManyArgs>(args?: SelectSubset<T, LessonCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LessonComments
     * const lessonComment = await prisma.lessonComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonCommentUpdateManyArgs>(args: SelectSubset<T, LessonCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonComments and returns the data updated in the database.
     * @param {LessonCommentUpdateManyAndReturnArgs} args - Arguments to update many LessonComments.
     * @example
     * // Update many LessonComments
     * const lessonComment = await prisma.lessonComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LessonComments and only return the `id`
     * const lessonCommentWithIdOnly = await prisma.lessonComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LessonComment.
     * @param {LessonCommentUpsertArgs} args - Arguments to update or create a LessonComment.
     * @example
     * // Update or create a LessonComment
     * const lessonComment = await prisma.lessonComment.upsert({
     *   create: {
     *     // ... data to create a LessonComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LessonComment we want to update
     *   }
     * })
     */
    upsert<T extends LessonCommentUpsertArgs>(args: SelectSubset<T, LessonCommentUpsertArgs<ExtArgs>>): Prisma__LessonCommentClient<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LessonComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCommentCountArgs} args - Arguments to filter LessonComments to count.
     * @example
     * // Count the number of LessonComments
     * const count = await prisma.lessonComment.count({
     *   where: {
     *     // ... the filter for the LessonComments we want to count
     *   }
     * })
    **/
    count<T extends LessonCommentCountArgs>(
      args?: Subset<T, LessonCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LessonComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonCommentAggregateArgs>(args: Subset<T, LessonCommentAggregateArgs>): Prisma.PrismaPromise<GetLessonCommentAggregateType<T>>

    /**
     * Group by LessonComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonCommentGroupByArgs['orderBy'] }
        : { orderBy?: LessonCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LessonComment model
   */
  readonly fields: LessonCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LessonComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends LessonComment$parentArgs<ExtArgs> = {}>(args?: Subset<T, LessonComment$parentArgs<ExtArgs>>): Prisma__LessonCommentClient<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replies<T extends LessonComment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, LessonComment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LessonComment model
   */
  interface LessonCommentFieldRefs {
    readonly id: FieldRef<"LessonComment", 'String'>
    readonly lessonId: FieldRef<"LessonComment", 'String'>
    readonly userId: FieldRef<"LessonComment", 'String'>
    readonly content: FieldRef<"LessonComment", 'String'>
    readonly parentId: FieldRef<"LessonComment", 'String'>
    readonly isPinned: FieldRef<"LessonComment", 'Boolean'>
    readonly isInstructorResponse: FieldRef<"LessonComment", 'Boolean'>
    readonly createdAt: FieldRef<"LessonComment", 'DateTime'>
    readonly updatedAt: FieldRef<"LessonComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LessonComment findUnique
   */
  export type LessonCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    /**
     * Filter, which LessonComment to fetch.
     */
    where: LessonCommentWhereUniqueInput
  }

  /**
   * LessonComment findUniqueOrThrow
   */
  export type LessonCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    /**
     * Filter, which LessonComment to fetch.
     */
    where: LessonCommentWhereUniqueInput
  }

  /**
   * LessonComment findFirst
   */
  export type LessonCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    /**
     * Filter, which LessonComment to fetch.
     */
    where?: LessonCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonComments to fetch.
     */
    orderBy?: LessonCommentOrderByWithRelationInput | LessonCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonComments.
     */
    cursor?: LessonCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonComments.
     */
    distinct?: LessonCommentScalarFieldEnum | LessonCommentScalarFieldEnum[]
  }

  /**
   * LessonComment findFirstOrThrow
   */
  export type LessonCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    /**
     * Filter, which LessonComment to fetch.
     */
    where?: LessonCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonComments to fetch.
     */
    orderBy?: LessonCommentOrderByWithRelationInput | LessonCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonComments.
     */
    cursor?: LessonCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonComments.
     */
    distinct?: LessonCommentScalarFieldEnum | LessonCommentScalarFieldEnum[]
  }

  /**
   * LessonComment findMany
   */
  export type LessonCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    /**
     * Filter, which LessonComments to fetch.
     */
    where?: LessonCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonComments to fetch.
     */
    orderBy?: LessonCommentOrderByWithRelationInput | LessonCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LessonComments.
     */
    cursor?: LessonCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonComments.
     */
    skip?: number
    distinct?: LessonCommentScalarFieldEnum | LessonCommentScalarFieldEnum[]
  }

  /**
   * LessonComment create
   */
  export type LessonCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a LessonComment.
     */
    data: XOR<LessonCommentCreateInput, LessonCommentUncheckedCreateInput>
  }

  /**
   * LessonComment createMany
   */
  export type LessonCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LessonComments.
     */
    data: LessonCommentCreateManyInput | LessonCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LessonComment createManyAndReturn
   */
  export type LessonCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * The data used to create many LessonComments.
     */
    data: LessonCommentCreateManyInput | LessonCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonComment update
   */
  export type LessonCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a LessonComment.
     */
    data: XOR<LessonCommentUpdateInput, LessonCommentUncheckedUpdateInput>
    /**
     * Choose, which LessonComment to update.
     */
    where: LessonCommentWhereUniqueInput
  }

  /**
   * LessonComment updateMany
   */
  export type LessonCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LessonComments.
     */
    data: XOR<LessonCommentUpdateManyMutationInput, LessonCommentUncheckedUpdateManyInput>
    /**
     * Filter which LessonComments to update
     */
    where?: LessonCommentWhereInput
    /**
     * Limit how many LessonComments to update.
     */
    limit?: number
  }

  /**
   * LessonComment updateManyAndReturn
   */
  export type LessonCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * The data used to update LessonComments.
     */
    data: XOR<LessonCommentUpdateManyMutationInput, LessonCommentUncheckedUpdateManyInput>
    /**
     * Filter which LessonComments to update
     */
    where?: LessonCommentWhereInput
    /**
     * Limit how many LessonComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonComment upsert
   */
  export type LessonCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the LessonComment to update in case it exists.
     */
    where: LessonCommentWhereUniqueInput
    /**
     * In case the LessonComment found by the `where` argument doesn't exist, create a new LessonComment with this data.
     */
    create: XOR<LessonCommentCreateInput, LessonCommentUncheckedCreateInput>
    /**
     * In case the LessonComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonCommentUpdateInput, LessonCommentUncheckedUpdateInput>
  }

  /**
   * LessonComment delete
   */
  export type LessonCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    /**
     * Filter which LessonComment to delete.
     */
    where: LessonCommentWhereUniqueInput
  }

  /**
   * LessonComment deleteMany
   */
  export type LessonCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonComments to delete
     */
    where?: LessonCommentWhereInput
    /**
     * Limit how many LessonComments to delete.
     */
    limit?: number
  }

  /**
   * LessonComment.parent
   */
  export type LessonComment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    where?: LessonCommentWhereInput
  }

  /**
   * LessonComment.replies
   */
  export type LessonComment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    where?: LessonCommentWhereInput
    orderBy?: LessonCommentOrderByWithRelationInput | LessonCommentOrderByWithRelationInput[]
    cursor?: LessonCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonCommentScalarFieldEnum | LessonCommentScalarFieldEnum[]
  }

  /**
   * LessonComment without action
   */
  export type LessonCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
  }


  /**
   * Model Module
   */

  export type AggregateModule = {
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  export type ModuleAvgAggregateOutputType = {
    orderIndex: number | null
  }

  export type ModuleSumAggregateOutputType = {
    orderIndex: number | null
  }

  export type ModuleMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    title: string | null
    description: string | null
    orderIndex: number | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    title: string | null
    description: string | null
    orderIndex: number | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleCountAggregateOutputType = {
    id: number
    courseId: number
    title: number
    description: number
    orderIndex: number
    isPublished: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModuleAvgAggregateInputType = {
    orderIndex?: true
  }

  export type ModuleSumAggregateInputType = {
    orderIndex?: true
  }

  export type ModuleMinAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    orderIndex?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleMaxAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    orderIndex?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleCountAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    orderIndex?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Module to aggregate.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Modules
    **/
    _count?: true | ModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleMaxAggregateInputType
  }

  export type GetModuleAggregateType<T extends ModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModule[P]>
      : GetScalarType<T[P], AggregateModule[P]>
  }




  export type ModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithAggregationInput | ModuleOrderByWithAggregationInput[]
    by: ModuleScalarFieldEnum[] | ModuleScalarFieldEnum
    having?: ModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleCountAggregateInputType | true
    _avg?: ModuleAvgAggregateInputType
    _sum?: ModuleSumAggregateInputType
    _min?: ModuleMinAggregateInputType
    _max?: ModuleMaxAggregateInputType
  }

  export type ModuleGroupByOutputType = {
    id: string
    courseId: string
    title: string
    description: string | null
    orderIndex: number
    isPublished: boolean
    createdAt: Date
    updatedAt: Date
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  type GetModuleGroupByPayload<T extends ModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleGroupByOutputType[P]>
        }
      >
    >


  export type ModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    orderIndex?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    lessons?: boolean | Module$lessonsArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    orderIndex?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    orderIndex?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectScalar = {
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    orderIndex?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "title" | "description" | "orderIndex" | "isPublished" | "createdAt" | "updatedAt", ExtArgs["result"]["module"]>
  export type ModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    lessons?: boolean | Module$lessonsArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type ModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $ModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Module"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      lessons: Prisma.$LessonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      title: string
      description: string | null
      orderIndex: number
      isPublished: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["module"]>
    composites: {}
  }

  type ModuleGetPayload<S extends boolean | null | undefined | ModuleDefaultArgs> = $Result.GetResult<Prisma.$ModulePayload, S>

  type ModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleCountAggregateInputType | true
    }

  export interface ModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Module'], meta: { name: 'Module' } }
    /**
     * Find zero or one Module that matches the filter.
     * @param {ModuleFindUniqueArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleFindUniqueArgs>(args: SelectSubset<T, ModuleFindUniqueArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Module that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleFindUniqueOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Module that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleFindFirstArgs>(args?: SelectSubset<T, ModuleFindFirstArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Module that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Modules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modules
     * const modules = await prisma.module.findMany()
     * 
     * // Get first 10 Modules
     * const modules = await prisma.module.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleWithIdOnly = await prisma.module.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuleFindManyArgs>(args?: SelectSubset<T, ModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Module.
     * @param {ModuleCreateArgs} args - Arguments to create a Module.
     * @example
     * // Create one Module
     * const Module = await prisma.module.create({
     *   data: {
     *     // ... data to create a Module
     *   }
     * })
     * 
     */
    create<T extends ModuleCreateArgs>(args: SelectSubset<T, ModuleCreateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Modules.
     * @param {ModuleCreateManyArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleCreateManyArgs>(args?: SelectSubset<T, ModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Modules and returns the data saved in the database.
     * @param {ModuleCreateManyAndReturnArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Modules and only return the `id`
     * const moduleWithIdOnly = await prisma.module.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Module.
     * @param {ModuleDeleteArgs} args - Arguments to delete one Module.
     * @example
     * // Delete one Module
     * const Module = await prisma.module.delete({
     *   where: {
     *     // ... filter to delete one Module
     *   }
     * })
     * 
     */
    delete<T extends ModuleDeleteArgs>(args: SelectSubset<T, ModuleDeleteArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Module.
     * @param {ModuleUpdateArgs} args - Arguments to update one Module.
     * @example
     * // Update one Module
     * const module = await prisma.module.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleUpdateArgs>(args: SelectSubset<T, ModuleUpdateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Modules.
     * @param {ModuleDeleteManyArgs} args - Arguments to filter Modules to delete.
     * @example
     * // Delete a few Modules
     * const { count } = await prisma.module.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleDeleteManyArgs>(args?: SelectSubset<T, ModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleUpdateManyArgs>(args: SelectSubset<T, ModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules and returns the data updated in the database.
     * @param {ModuleUpdateManyAndReturnArgs} args - Arguments to update many Modules.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Modules and only return the `id`
     * const moduleWithIdOnly = await prisma.module.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Module.
     * @param {ModuleUpsertArgs} args - Arguments to update or create a Module.
     * @example
     * // Update or create a Module
     * const module = await prisma.module.upsert({
     *   create: {
     *     // ... data to create a Module
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Module we want to update
     *   }
     * })
     */
    upsert<T extends ModuleUpsertArgs>(args: SelectSubset<T, ModuleUpsertArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCountArgs} args - Arguments to filter Modules to count.
     * @example
     * // Count the number of Modules
     * const count = await prisma.module.count({
     *   where: {
     *     // ... the filter for the Modules we want to count
     *   }
     * })
    **/
    count<T extends ModuleCountArgs>(
      args?: Subset<T, ModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleAggregateArgs>(args: Subset<T, ModuleAggregateArgs>): Prisma.PrismaPromise<GetModuleAggregateType<T>>

    /**
     * Group by Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleGroupByArgs['orderBy'] }
        : { orderBy?: ModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Module model
   */
  readonly fields: ModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Module.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lessons<T extends Module$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Module$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Module model
   */
  interface ModuleFieldRefs {
    readonly id: FieldRef<"Module", 'String'>
    readonly courseId: FieldRef<"Module", 'String'>
    readonly title: FieldRef<"Module", 'String'>
    readonly description: FieldRef<"Module", 'String'>
    readonly orderIndex: FieldRef<"Module", 'Int'>
    readonly isPublished: FieldRef<"Module", 'Boolean'>
    readonly createdAt: FieldRef<"Module", 'DateTime'>
    readonly updatedAt: FieldRef<"Module", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Module findUnique
   */
  export type ModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findUniqueOrThrow
   */
  export type ModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findFirst
   */
  export type ModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findFirstOrThrow
   */
  export type ModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findMany
   */
  export type ModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Modules to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module create
   */
  export type ModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a Module.
     */
    data: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
  }

  /**
   * Module createMany
   */
  export type ModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Module createManyAndReturn
   */
  export type ModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Module update
   */
  export type ModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a Module.
     */
    data: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
    /**
     * Choose, which Module to update.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module updateMany
   */
  export type ModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to update.
     */
    limit?: number
  }

  /**
   * Module updateManyAndReturn
   */
  export type ModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Module upsert
   */
  export type ModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the Module to update in case it exists.
     */
    where: ModuleWhereUniqueInput
    /**
     * In case the Module found by the `where` argument doesn't exist, create a new Module with this data.
     */
    create: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
    /**
     * In case the Module was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
  }

  /**
   * Module delete
   */
  export type ModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter which Module to delete.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module deleteMany
   */
  export type ModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modules to delete
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to delete.
     */
    limit?: number
  }

  /**
   * Module.lessons
   */
  export type Module$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Module without action
   */
  export type ModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
  }


  /**
   * Model Lesson
   */

  export type AggregateLesson = {
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  export type LessonAvgAggregateOutputType = {
    duration: number | null
    order: number | null
  }

  export type LessonSumAggregateOutputType = {
    duration: number | null
    order: number | null
  }

  export type LessonMinAggregateOutputType = {
    id: string | null
    moduleId: string | null
    title: string | null
    content: string | null
    videoUrl: string | null
    duration: number | null
    order: number | null
    type: $Enums.LessonType | null
    isPublished: boolean | null
    isPreview: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LessonMaxAggregateOutputType = {
    id: string | null
    moduleId: string | null
    title: string | null
    content: string | null
    videoUrl: string | null
    duration: number | null
    order: number | null
    type: $Enums.LessonType | null
    isPublished: boolean | null
    isPreview: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LessonCountAggregateOutputType = {
    id: number
    moduleId: number
    title: number
    content: number
    videoUrl: number
    duration: number
    order: number
    type: number
    isPublished: number
    isPreview: number
    settings: number
    resources: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LessonAvgAggregateInputType = {
    duration?: true
    order?: true
  }

  export type LessonSumAggregateInputType = {
    duration?: true
    order?: true
  }

  export type LessonMinAggregateInputType = {
    id?: true
    moduleId?: true
    title?: true
    content?: true
    videoUrl?: true
    duration?: true
    order?: true
    type?: true
    isPublished?: true
    isPreview?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LessonMaxAggregateInputType = {
    id?: true
    moduleId?: true
    title?: true
    content?: true
    videoUrl?: true
    duration?: true
    order?: true
    type?: true
    isPublished?: true
    isPreview?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LessonCountAggregateInputType = {
    id?: true
    moduleId?: true
    title?: true
    content?: true
    videoUrl?: true
    duration?: true
    order?: true
    type?: true
    isPublished?: true
    isPreview?: true
    settings?: true
    resources?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LessonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lesson to aggregate.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lessons
    **/
    _count?: true | LessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonMaxAggregateInputType
  }

  export type GetLessonAggregateType<T extends LessonAggregateArgs> = {
        [P in keyof T & keyof AggregateLesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLesson[P]>
      : GetScalarType<T[P], AggregateLesson[P]>
  }




  export type LessonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithAggregationInput | LessonOrderByWithAggregationInput[]
    by: LessonScalarFieldEnum[] | LessonScalarFieldEnum
    having?: LessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCountAggregateInputType | true
    _avg?: LessonAvgAggregateInputType
    _sum?: LessonSumAggregateInputType
    _min?: LessonMinAggregateInputType
    _max?: LessonMaxAggregateInputType
  }

  export type LessonGroupByOutputType = {
    id: string
    moduleId: string
    title: string
    content: string | null
    videoUrl: string | null
    duration: number | null
    order: number
    type: $Enums.LessonType
    isPublished: boolean
    isPreview: boolean
    settings: JsonValue | null
    resources: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  type GetLessonGroupByPayload<T extends LessonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonGroupByOutputType[P]>
            : GetScalarType<T[P], LessonGroupByOutputType[P]>
        }
      >
    >


  export type LessonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    title?: boolean
    content?: boolean
    videoUrl?: boolean
    duration?: boolean
    order?: boolean
    type?: boolean
    isPublished?: boolean
    isPreview?: boolean
    settings?: boolean
    resources?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    quizzes?: boolean | Lesson$quizzesArgs<ExtArgs>
    progress?: boolean | Lesson$progressArgs<ExtArgs>
    comments?: boolean | Lesson$commentsArgs<ExtArgs>
    assignmentSubmissions?: boolean | Lesson$assignmentSubmissionsArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    title?: boolean
    content?: boolean
    videoUrl?: boolean
    duration?: boolean
    order?: boolean
    type?: boolean
    isPublished?: boolean
    isPreview?: boolean
    settings?: boolean
    resources?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    title?: boolean
    content?: boolean
    videoUrl?: boolean
    duration?: boolean
    order?: boolean
    type?: boolean
    isPublished?: boolean
    isPreview?: boolean
    settings?: boolean
    resources?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectScalar = {
    id?: boolean
    moduleId?: boolean
    title?: boolean
    content?: boolean
    videoUrl?: boolean
    duration?: boolean
    order?: boolean
    type?: boolean
    isPublished?: boolean
    isPreview?: boolean
    settings?: boolean
    resources?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LessonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "moduleId" | "title" | "content" | "videoUrl" | "duration" | "order" | "type" | "isPublished" | "isPreview" | "settings" | "resources" | "createdAt" | "updatedAt", ExtArgs["result"]["lesson"]>
  export type LessonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    quizzes?: boolean | Lesson$quizzesArgs<ExtArgs>
    progress?: boolean | Lesson$progressArgs<ExtArgs>
    comments?: boolean | Lesson$commentsArgs<ExtArgs>
    assignmentSubmissions?: boolean | Lesson$assignmentSubmissionsArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LessonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }
  export type LessonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }

  export type $LessonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lesson"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      quizzes: Prisma.$QuizPayload<ExtArgs>[]
      progress: Prisma.$LessonProgressPayload<ExtArgs>[]
      comments: Prisma.$LessonCommentPayload<ExtArgs>[]
      assignmentSubmissions: Prisma.$AssignmentSubmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      moduleId: string
      title: string
      content: string | null
      videoUrl: string | null
      duration: number | null
      order: number
      type: $Enums.LessonType
      isPublished: boolean
      isPreview: boolean
      settings: Prisma.JsonValue | null
      resources: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lesson"]>
    composites: {}
  }

  type LessonGetPayload<S extends boolean | null | undefined | LessonDefaultArgs> = $Result.GetResult<Prisma.$LessonPayload, S>

  type LessonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonCountAggregateInputType | true
    }

  export interface LessonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lesson'], meta: { name: 'Lesson' } }
    /**
     * Find zero or one Lesson that matches the filter.
     * @param {LessonFindUniqueArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonFindUniqueArgs>(args: SelectSubset<T, LessonFindUniqueArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lesson that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonFindUniqueOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonFindFirstArgs>(args?: SelectSubset<T, LessonFindFirstArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lesson.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lesson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonWithIdOnly = await prisma.lesson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonFindManyArgs>(args?: SelectSubset<T, LessonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lesson.
     * @param {LessonCreateArgs} args - Arguments to create a Lesson.
     * @example
     * // Create one Lesson
     * const Lesson = await prisma.lesson.create({
     *   data: {
     *     // ... data to create a Lesson
     *   }
     * })
     * 
     */
    create<T extends LessonCreateArgs>(args: SelectSubset<T, LessonCreateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lessons.
     * @param {LessonCreateManyArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonCreateManyArgs>(args?: SelectSubset<T, LessonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lessons and returns the data saved in the database.
     * @param {LessonCreateManyAndReturnArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lesson.
     * @param {LessonDeleteArgs} args - Arguments to delete one Lesson.
     * @example
     * // Delete one Lesson
     * const Lesson = await prisma.lesson.delete({
     *   where: {
     *     // ... filter to delete one Lesson
     *   }
     * })
     * 
     */
    delete<T extends LessonDeleteArgs>(args: SelectSubset<T, LessonDeleteArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lesson.
     * @param {LessonUpdateArgs} args - Arguments to update one Lesson.
     * @example
     * // Update one Lesson
     * const lesson = await prisma.lesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonUpdateArgs>(args: SelectSubset<T, LessonUpdateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lessons.
     * @param {LessonDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonDeleteManyArgs>(args?: SelectSubset<T, LessonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonUpdateManyArgs>(args: SelectSubset<T, LessonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons and returns the data updated in the database.
     * @param {LessonUpdateManyAndReturnArgs} args - Arguments to update many Lessons.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lesson.
     * @param {LessonUpsertArgs} args - Arguments to update or create a Lesson.
     * @example
     * // Update or create a Lesson
     * const lesson = await prisma.lesson.upsert({
     *   create: {
     *     // ... data to create a Lesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lesson we want to update
     *   }
     * })
     */
    upsert<T extends LessonUpsertArgs>(args: SelectSubset<T, LessonUpsertArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lesson.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends LessonCountArgs>(
      args?: Subset<T, LessonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonAggregateArgs>(args: Subset<T, LessonAggregateArgs>): Prisma.PrismaPromise<GetLessonAggregateType<T>>

    /**
     * Group by Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonGroupByArgs['orderBy'] }
        : { orderBy?: LessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lesson model
   */
  readonly fields: LessonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    quizzes<T extends Lesson$quizzesArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$quizzesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    progress<T extends Lesson$progressArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Lesson$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignmentSubmissions<T extends Lesson$assignmentSubmissionsArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$assignmentSubmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lesson model
   */
  interface LessonFieldRefs {
    readonly id: FieldRef<"Lesson", 'String'>
    readonly moduleId: FieldRef<"Lesson", 'String'>
    readonly title: FieldRef<"Lesson", 'String'>
    readonly content: FieldRef<"Lesson", 'String'>
    readonly videoUrl: FieldRef<"Lesson", 'String'>
    readonly duration: FieldRef<"Lesson", 'Int'>
    readonly order: FieldRef<"Lesson", 'Int'>
    readonly type: FieldRef<"Lesson", 'LessonType'>
    readonly isPublished: FieldRef<"Lesson", 'Boolean'>
    readonly isPreview: FieldRef<"Lesson", 'Boolean'>
    readonly settings: FieldRef<"Lesson", 'Json'>
    readonly resources: FieldRef<"Lesson", 'Json'>
    readonly createdAt: FieldRef<"Lesson", 'DateTime'>
    readonly updatedAt: FieldRef<"Lesson", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lesson findUnique
   */
  export type LessonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findUniqueOrThrow
   */
  export type LessonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findFirst
   */
  export type LessonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findFirstOrThrow
   */
  export type LessonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findMany
   */
  export type LessonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson create
   */
  export type LessonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to create a Lesson.
     */
    data: XOR<LessonCreateInput, LessonUncheckedCreateInput>
  }

  /**
   * Lesson createMany
   */
  export type LessonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lesson createManyAndReturn
   */
  export type LessonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson update
   */
  export type LessonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to update a Lesson.
     */
    data: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
    /**
     * Choose, which Lesson to update.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson updateMany
   */
  export type LessonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
  }

  /**
   * Lesson updateManyAndReturn
   */
  export type LessonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson upsert
   */
  export type LessonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The filter to search for the Lesson to update in case it exists.
     */
    where: LessonWhereUniqueInput
    /**
     * In case the Lesson found by the `where` argument doesn't exist, create a new Lesson with this data.
     */
    create: XOR<LessonCreateInput, LessonUncheckedCreateInput>
    /**
     * In case the Lesson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
  }

  /**
   * Lesson delete
   */
  export type LessonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter which Lesson to delete.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson deleteMany
   */
  export type LessonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to delete
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to delete.
     */
    limit?: number
  }

  /**
   * Lesson.quizzes
   */
  export type Lesson$quizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    cursor?: QuizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Lesson.progress
   */
  export type Lesson$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    where?: LessonProgressWhereInput
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    cursor?: LessonProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonProgressScalarFieldEnum | LessonProgressScalarFieldEnum[]
  }

  /**
   * Lesson.comments
   */
  export type Lesson$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonComment
     */
    select?: LessonCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonComment
     */
    omit?: LessonCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCommentInclude<ExtArgs> | null
    where?: LessonCommentWhereInput
    orderBy?: LessonCommentOrderByWithRelationInput | LessonCommentOrderByWithRelationInput[]
    cursor?: LessonCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonCommentScalarFieldEnum | LessonCommentScalarFieldEnum[]
  }

  /**
   * Lesson.assignmentSubmissions
   */
  export type Lesson$assignmentSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    where?: AssignmentSubmissionWhereInput
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    cursor?: AssignmentSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * Lesson without action
   */
  export type LessonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
  }


  /**
   * Model Quiz
   */

  export type AggregateQuiz = {
    _count: QuizCountAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  export type QuizMinAggregateOutputType = {
    id: string | null
    lessonId: string | null
    question: string | null
    correctAnswer: string | null
    explanation: string | null
    createdAt: Date | null
  }

  export type QuizMaxAggregateOutputType = {
    id: string | null
    lessonId: string | null
    question: string | null
    correctAnswer: string | null
    explanation: string | null
    createdAt: Date | null
  }

  export type QuizCountAggregateOutputType = {
    id: number
    lessonId: number
    question: number
    options: number
    correctAnswer: number
    explanation: number
    createdAt: number
    _all: number
  }


  export type QuizMinAggregateInputType = {
    id?: true
    lessonId?: true
    question?: true
    correctAnswer?: true
    explanation?: true
    createdAt?: true
  }

  export type QuizMaxAggregateInputType = {
    id?: true
    lessonId?: true
    question?: true
    correctAnswer?: true
    explanation?: true
    createdAt?: true
  }

  export type QuizCountAggregateInputType = {
    id?: true
    lessonId?: true
    question?: true
    options?: true
    correctAnswer?: true
    explanation?: true
    createdAt?: true
    _all?: true
  }

  export type QuizAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quiz to aggregate.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quizzes
    **/
    _count?: true | QuizCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizMaxAggregateInputType
  }

  export type GetQuizAggregateType<T extends QuizAggregateArgs> = {
        [P in keyof T & keyof AggregateQuiz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuiz[P]>
      : GetScalarType<T[P], AggregateQuiz[P]>
  }




  export type QuizGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithAggregationInput | QuizOrderByWithAggregationInput[]
    by: QuizScalarFieldEnum[] | QuizScalarFieldEnum
    having?: QuizScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizCountAggregateInputType | true
    _min?: QuizMinAggregateInputType
    _max?: QuizMaxAggregateInputType
  }

  export type QuizGroupByOutputType = {
    id: string
    lessonId: string
    question: string
    options: JsonValue
    correctAnswer: string
    explanation: string | null
    createdAt: Date
    _count: QuizCountAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  type GetQuizGroupByPayload<T extends QuizGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizGroupByOutputType[P]>
            : GetScalarType<T[P], QuizGroupByOutputType[P]>
        }
      >
    >


  export type QuizSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    question?: boolean
    options?: boolean
    correctAnswer?: boolean
    explanation?: boolean
    createdAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    question?: boolean
    options?: boolean
    correctAnswer?: boolean
    explanation?: boolean
    createdAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    question?: boolean
    options?: boolean
    correctAnswer?: boolean
    explanation?: boolean
    createdAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectScalar = {
    id?: boolean
    lessonId?: boolean
    question?: boolean
    options?: boolean
    correctAnswer?: boolean
    explanation?: boolean
    createdAt?: boolean
  }

  export type QuizOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lessonId" | "question" | "options" | "correctAnswer" | "explanation" | "createdAt", ExtArgs["result"]["quiz"]>
  export type QuizInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type QuizIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type QuizIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }

  export type $QuizPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quiz"
    objects: {
      lesson: Prisma.$LessonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lessonId: string
      question: string
      options: Prisma.JsonValue
      correctAnswer: string
      explanation: string | null
      createdAt: Date
    }, ExtArgs["result"]["quiz"]>
    composites: {}
  }

  type QuizGetPayload<S extends boolean | null | undefined | QuizDefaultArgs> = $Result.GetResult<Prisma.$QuizPayload, S>

  type QuizCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizCountAggregateInputType | true
    }

  export interface QuizDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quiz'], meta: { name: 'Quiz' } }
    /**
     * Find zero or one Quiz that matches the filter.
     * @param {QuizFindUniqueArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizFindUniqueArgs>(args: SelectSubset<T, QuizFindUniqueArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quiz that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizFindUniqueOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizFindFirstArgs>(args?: SelectSubset<T, QuizFindFirstArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quizzes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quizzes
     * const quizzes = await prisma.quiz.findMany()
     * 
     * // Get first 10 Quizzes
     * const quizzes = await prisma.quiz.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizWithIdOnly = await prisma.quiz.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizFindManyArgs>(args?: SelectSubset<T, QuizFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quiz.
     * @param {QuizCreateArgs} args - Arguments to create a Quiz.
     * @example
     * // Create one Quiz
     * const Quiz = await prisma.quiz.create({
     *   data: {
     *     // ... data to create a Quiz
     *   }
     * })
     * 
     */
    create<T extends QuizCreateArgs>(args: SelectSubset<T, QuizCreateArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quizzes.
     * @param {QuizCreateManyArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizCreateManyArgs>(args?: SelectSubset<T, QuizCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quizzes and returns the data saved in the database.
     * @param {QuizCreateManyAndReturnArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quizzes and only return the `id`
     * const quizWithIdOnly = await prisma.quiz.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quiz.
     * @param {QuizDeleteArgs} args - Arguments to delete one Quiz.
     * @example
     * // Delete one Quiz
     * const Quiz = await prisma.quiz.delete({
     *   where: {
     *     // ... filter to delete one Quiz
     *   }
     * })
     * 
     */
    delete<T extends QuizDeleteArgs>(args: SelectSubset<T, QuizDeleteArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quiz.
     * @param {QuizUpdateArgs} args - Arguments to update one Quiz.
     * @example
     * // Update one Quiz
     * const quiz = await prisma.quiz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizUpdateArgs>(args: SelectSubset<T, QuizUpdateArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quizzes.
     * @param {QuizDeleteManyArgs} args - Arguments to filter Quizzes to delete.
     * @example
     * // Delete a few Quizzes
     * const { count } = await prisma.quiz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizDeleteManyArgs>(args?: SelectSubset<T, QuizDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizUpdateManyArgs>(args: SelectSubset<T, QuizUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes and returns the data updated in the database.
     * @param {QuizUpdateManyAndReturnArgs} args - Arguments to update many Quizzes.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quizzes and only return the `id`
     * const quizWithIdOnly = await prisma.quiz.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quiz.
     * @param {QuizUpsertArgs} args - Arguments to update or create a Quiz.
     * @example
     * // Update or create a Quiz
     * const quiz = await prisma.quiz.upsert({
     *   create: {
     *     // ... data to create a Quiz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quiz we want to update
     *   }
     * })
     */
    upsert<T extends QuizUpsertArgs>(args: SelectSubset<T, QuizUpsertArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCountArgs} args - Arguments to filter Quizzes to count.
     * @example
     * // Count the number of Quizzes
     * const count = await prisma.quiz.count({
     *   where: {
     *     // ... the filter for the Quizzes we want to count
     *   }
     * })
    **/
    count<T extends QuizCountArgs>(
      args?: Subset<T, QuizCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAggregateArgs>(args: Subset<T, QuizAggregateArgs>): Prisma.PrismaPromise<GetQuizAggregateType<T>>

    /**
     * Group by Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizGroupByArgs['orderBy'] }
        : { orderBy?: QuizGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quiz model
   */
  readonly fields: QuizFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quiz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quiz model
   */
  interface QuizFieldRefs {
    readonly id: FieldRef<"Quiz", 'String'>
    readonly lessonId: FieldRef<"Quiz", 'String'>
    readonly question: FieldRef<"Quiz", 'String'>
    readonly options: FieldRef<"Quiz", 'Json'>
    readonly correctAnswer: FieldRef<"Quiz", 'String'>
    readonly explanation: FieldRef<"Quiz", 'String'>
    readonly createdAt: FieldRef<"Quiz", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quiz findUnique
   */
  export type QuizFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findUniqueOrThrow
   */
  export type QuizFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findFirst
   */
  export type QuizFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz findFirstOrThrow
   */
  export type QuizFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz findMany
   */
  export type QuizFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quizzes to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz create
   */
  export type QuizCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The data needed to create a Quiz.
     */
    data: XOR<QuizCreateInput, QuizUncheckedCreateInput>
  }

  /**
   * Quiz createMany
   */
  export type QuizCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quizzes.
     */
    data: QuizCreateManyInput | QuizCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quiz createManyAndReturn
   */
  export type QuizCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * The data used to create many Quizzes.
     */
    data: QuizCreateManyInput | QuizCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quiz update
   */
  export type QuizUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The data needed to update a Quiz.
     */
    data: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
    /**
     * Choose, which Quiz to update.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz updateMany
   */
  export type QuizUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quizzes.
     */
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyInput>
    /**
     * Filter which Quizzes to update
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to update.
     */
    limit?: number
  }

  /**
   * Quiz updateManyAndReturn
   */
  export type QuizUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * The data used to update Quizzes.
     */
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyInput>
    /**
     * Filter which Quizzes to update
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quiz upsert
   */
  export type QuizUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The filter to search for the Quiz to update in case it exists.
     */
    where: QuizWhereUniqueInput
    /**
     * In case the Quiz found by the `where` argument doesn't exist, create a new Quiz with this data.
     */
    create: XOR<QuizCreateInput, QuizUncheckedCreateInput>
    /**
     * In case the Quiz was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
  }

  /**
   * Quiz delete
   */
  export type QuizDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter which Quiz to delete.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz deleteMany
   */
  export type QuizDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quizzes to delete
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to delete.
     */
    limit?: number
  }

  /**
   * Quiz without action
   */
  export type QuizDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
  }


  /**
   * Model AssignmentSubmission
   */

  export type AggregateAssignmentSubmission = {
    _count: AssignmentSubmissionCountAggregateOutputType | null
    _avg: AssignmentSubmissionAvgAggregateOutputType | null
    _sum: AssignmentSubmissionSumAggregateOutputType | null
    _min: AssignmentSubmissionMinAggregateOutputType | null
    _max: AssignmentSubmissionMaxAggregateOutputType | null
  }

  export type AssignmentSubmissionAvgAggregateOutputType = {
    grade: number | null
  }

  export type AssignmentSubmissionSumAggregateOutputType = {
    grade: number | null
  }

  export type AssignmentSubmissionMinAggregateOutputType = {
    id: string | null
    lessonId: string | null
    userId: string | null
    content: string | null
    fileUrl: string | null
    grade: number | null
    feedback: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssignmentSubmissionMaxAggregateOutputType = {
    id: string | null
    lessonId: string | null
    userId: string | null
    content: string | null
    fileUrl: string | null
    grade: number | null
    feedback: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssignmentSubmissionCountAggregateOutputType = {
    id: number
    lessonId: number
    userId: number
    content: number
    fileUrl: number
    grade: number
    feedback: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssignmentSubmissionAvgAggregateInputType = {
    grade?: true
  }

  export type AssignmentSubmissionSumAggregateInputType = {
    grade?: true
  }

  export type AssignmentSubmissionMinAggregateInputType = {
    id?: true
    lessonId?: true
    userId?: true
    content?: true
    fileUrl?: true
    grade?: true
    feedback?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssignmentSubmissionMaxAggregateInputType = {
    id?: true
    lessonId?: true
    userId?: true
    content?: true
    fileUrl?: true
    grade?: true
    feedback?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssignmentSubmissionCountAggregateInputType = {
    id?: true
    lessonId?: true
    userId?: true
    content?: true
    fileUrl?: true
    grade?: true
    feedback?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssignmentSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssignmentSubmission to aggregate.
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentSubmissions to fetch.
     */
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssignmentSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssignmentSubmissions
    **/
    _count?: true | AssignmentSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignmentSubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignmentSubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentSubmissionMaxAggregateInputType
  }

  export type GetAssignmentSubmissionAggregateType<T extends AssignmentSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignmentSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignmentSubmission[P]>
      : GetScalarType<T[P], AggregateAssignmentSubmission[P]>
  }




  export type AssignmentSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentSubmissionWhereInput
    orderBy?: AssignmentSubmissionOrderByWithAggregationInput | AssignmentSubmissionOrderByWithAggregationInput[]
    by: AssignmentSubmissionScalarFieldEnum[] | AssignmentSubmissionScalarFieldEnum
    having?: AssignmentSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentSubmissionCountAggregateInputType | true
    _avg?: AssignmentSubmissionAvgAggregateInputType
    _sum?: AssignmentSubmissionSumAggregateInputType
    _min?: AssignmentSubmissionMinAggregateInputType
    _max?: AssignmentSubmissionMaxAggregateInputType
  }

  export type AssignmentSubmissionGroupByOutputType = {
    id: string
    lessonId: string
    userId: string
    content: string | null
    fileUrl: string | null
    grade: number | null
    feedback: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: AssignmentSubmissionCountAggregateOutputType | null
    _avg: AssignmentSubmissionAvgAggregateOutputType | null
    _sum: AssignmentSubmissionSumAggregateOutputType | null
    _min: AssignmentSubmissionMinAggregateOutputType | null
    _max: AssignmentSubmissionMaxAggregateOutputType | null
  }

  type GetAssignmentSubmissionGroupByPayload<T extends AssignmentSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type AssignmentSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    userId?: boolean
    content?: boolean
    fileUrl?: boolean
    grade?: boolean
    feedback?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignmentSubmission"]>

  export type AssignmentSubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    userId?: boolean
    content?: boolean
    fileUrl?: boolean
    grade?: boolean
    feedback?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignmentSubmission"]>

  export type AssignmentSubmissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    userId?: boolean
    content?: boolean
    fileUrl?: boolean
    grade?: boolean
    feedback?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignmentSubmission"]>

  export type AssignmentSubmissionSelectScalar = {
    id?: boolean
    lessonId?: boolean
    userId?: boolean
    content?: boolean
    fileUrl?: boolean
    grade?: boolean
    feedback?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AssignmentSubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lessonId" | "userId" | "content" | "fileUrl" | "grade" | "feedback" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["assignmentSubmission"]>
  export type AssignmentSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AssignmentSubmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AssignmentSubmissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AssignmentSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssignmentSubmission"
    objects: {
      lesson: Prisma.$LessonPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lessonId: string
      userId: string
      content: string | null
      fileUrl: string | null
      grade: number | null
      feedback: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["assignmentSubmission"]>
    composites: {}
  }

  type AssignmentSubmissionGetPayload<S extends boolean | null | undefined | AssignmentSubmissionDefaultArgs> = $Result.GetResult<Prisma.$AssignmentSubmissionPayload, S>

  type AssignmentSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssignmentSubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssignmentSubmissionCountAggregateInputType | true
    }

  export interface AssignmentSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssignmentSubmission'], meta: { name: 'AssignmentSubmission' } }
    /**
     * Find zero or one AssignmentSubmission that matches the filter.
     * @param {AssignmentSubmissionFindUniqueArgs} args - Arguments to find a AssignmentSubmission
     * @example
     * // Get one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssignmentSubmissionFindUniqueArgs>(args: SelectSubset<T, AssignmentSubmissionFindUniqueArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssignmentSubmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssignmentSubmissionFindUniqueOrThrowArgs} args - Arguments to find a AssignmentSubmission
     * @example
     * // Get one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssignmentSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, AssignmentSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssignmentSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionFindFirstArgs} args - Arguments to find a AssignmentSubmission
     * @example
     * // Get one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssignmentSubmissionFindFirstArgs>(args?: SelectSubset<T, AssignmentSubmissionFindFirstArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssignmentSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionFindFirstOrThrowArgs} args - Arguments to find a AssignmentSubmission
     * @example
     * // Get one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssignmentSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, AssignmentSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssignmentSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssignmentSubmissions
     * const assignmentSubmissions = await prisma.assignmentSubmission.findMany()
     * 
     * // Get first 10 AssignmentSubmissions
     * const assignmentSubmissions = await prisma.assignmentSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignmentSubmissionWithIdOnly = await prisma.assignmentSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssignmentSubmissionFindManyArgs>(args?: SelectSubset<T, AssignmentSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssignmentSubmission.
     * @param {AssignmentSubmissionCreateArgs} args - Arguments to create a AssignmentSubmission.
     * @example
     * // Create one AssignmentSubmission
     * const AssignmentSubmission = await prisma.assignmentSubmission.create({
     *   data: {
     *     // ... data to create a AssignmentSubmission
     *   }
     * })
     * 
     */
    create<T extends AssignmentSubmissionCreateArgs>(args: SelectSubset<T, AssignmentSubmissionCreateArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssignmentSubmissions.
     * @param {AssignmentSubmissionCreateManyArgs} args - Arguments to create many AssignmentSubmissions.
     * @example
     * // Create many AssignmentSubmissions
     * const assignmentSubmission = await prisma.assignmentSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssignmentSubmissionCreateManyArgs>(args?: SelectSubset<T, AssignmentSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssignmentSubmissions and returns the data saved in the database.
     * @param {AssignmentSubmissionCreateManyAndReturnArgs} args - Arguments to create many AssignmentSubmissions.
     * @example
     * // Create many AssignmentSubmissions
     * const assignmentSubmission = await prisma.assignmentSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssignmentSubmissions and only return the `id`
     * const assignmentSubmissionWithIdOnly = await prisma.assignmentSubmission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssignmentSubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, AssignmentSubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssignmentSubmission.
     * @param {AssignmentSubmissionDeleteArgs} args - Arguments to delete one AssignmentSubmission.
     * @example
     * // Delete one AssignmentSubmission
     * const AssignmentSubmission = await prisma.assignmentSubmission.delete({
     *   where: {
     *     // ... filter to delete one AssignmentSubmission
     *   }
     * })
     * 
     */
    delete<T extends AssignmentSubmissionDeleteArgs>(args: SelectSubset<T, AssignmentSubmissionDeleteArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssignmentSubmission.
     * @param {AssignmentSubmissionUpdateArgs} args - Arguments to update one AssignmentSubmission.
     * @example
     * // Update one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssignmentSubmissionUpdateArgs>(args: SelectSubset<T, AssignmentSubmissionUpdateArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssignmentSubmissions.
     * @param {AssignmentSubmissionDeleteManyArgs} args - Arguments to filter AssignmentSubmissions to delete.
     * @example
     * // Delete a few AssignmentSubmissions
     * const { count } = await prisma.assignmentSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssignmentSubmissionDeleteManyArgs>(args?: SelectSubset<T, AssignmentSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssignmentSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssignmentSubmissions
     * const assignmentSubmission = await prisma.assignmentSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssignmentSubmissionUpdateManyArgs>(args: SelectSubset<T, AssignmentSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssignmentSubmissions and returns the data updated in the database.
     * @param {AssignmentSubmissionUpdateManyAndReturnArgs} args - Arguments to update many AssignmentSubmissions.
     * @example
     * // Update many AssignmentSubmissions
     * const assignmentSubmission = await prisma.assignmentSubmission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AssignmentSubmissions and only return the `id`
     * const assignmentSubmissionWithIdOnly = await prisma.assignmentSubmission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssignmentSubmissionUpdateManyAndReturnArgs>(args: SelectSubset<T, AssignmentSubmissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssignmentSubmission.
     * @param {AssignmentSubmissionUpsertArgs} args - Arguments to update or create a AssignmentSubmission.
     * @example
     * // Update or create a AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.upsert({
     *   create: {
     *     // ... data to create a AssignmentSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssignmentSubmission we want to update
     *   }
     * })
     */
    upsert<T extends AssignmentSubmissionUpsertArgs>(args: SelectSubset<T, AssignmentSubmissionUpsertArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssignmentSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionCountArgs} args - Arguments to filter AssignmentSubmissions to count.
     * @example
     * // Count the number of AssignmentSubmissions
     * const count = await prisma.assignmentSubmission.count({
     *   where: {
     *     // ... the filter for the AssignmentSubmissions we want to count
     *   }
     * })
    **/
    count<T extends AssignmentSubmissionCountArgs>(
      args?: Subset<T, AssignmentSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssignmentSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentSubmissionAggregateArgs>(args: Subset<T, AssignmentSubmissionAggregateArgs>): Prisma.PrismaPromise<GetAssignmentSubmissionAggregateType<T>>

    /**
     * Group by AssignmentSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignmentSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignmentSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: AssignmentSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignmentSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssignmentSubmission model
   */
  readonly fields: AssignmentSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssignmentSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssignmentSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssignmentSubmission model
   */
  interface AssignmentSubmissionFieldRefs {
    readonly id: FieldRef<"AssignmentSubmission", 'String'>
    readonly lessonId: FieldRef<"AssignmentSubmission", 'String'>
    readonly userId: FieldRef<"AssignmentSubmission", 'String'>
    readonly content: FieldRef<"AssignmentSubmission", 'String'>
    readonly fileUrl: FieldRef<"AssignmentSubmission", 'String'>
    readonly grade: FieldRef<"AssignmentSubmission", 'Int'>
    readonly feedback: FieldRef<"AssignmentSubmission", 'String'>
    readonly status: FieldRef<"AssignmentSubmission", 'String'>
    readonly createdAt: FieldRef<"AssignmentSubmission", 'DateTime'>
    readonly updatedAt: FieldRef<"AssignmentSubmission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AssignmentSubmission findUnique
   */
  export type AssignmentSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmission to fetch.
     */
    where: AssignmentSubmissionWhereUniqueInput
  }

  /**
   * AssignmentSubmission findUniqueOrThrow
   */
  export type AssignmentSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmission to fetch.
     */
    where: AssignmentSubmissionWhereUniqueInput
  }

  /**
   * AssignmentSubmission findFirst
   */
  export type AssignmentSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmission to fetch.
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentSubmissions to fetch.
     */
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssignmentSubmissions.
     */
    cursor?: AssignmentSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssignmentSubmissions.
     */
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * AssignmentSubmission findFirstOrThrow
   */
  export type AssignmentSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmission to fetch.
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentSubmissions to fetch.
     */
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssignmentSubmissions.
     */
    cursor?: AssignmentSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssignmentSubmissions.
     */
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * AssignmentSubmission findMany
   */
  export type AssignmentSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmissions to fetch.
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentSubmissions to fetch.
     */
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssignmentSubmissions.
     */
    cursor?: AssignmentSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentSubmissions.
     */
    skip?: number
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * AssignmentSubmission create
   */
  export type AssignmentSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a AssignmentSubmission.
     */
    data: XOR<AssignmentSubmissionCreateInput, AssignmentSubmissionUncheckedCreateInput>
  }

  /**
   * AssignmentSubmission createMany
   */
  export type AssignmentSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssignmentSubmissions.
     */
    data: AssignmentSubmissionCreateManyInput | AssignmentSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssignmentSubmission createManyAndReturn
   */
  export type AssignmentSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * The data used to create many AssignmentSubmissions.
     */
    data: AssignmentSubmissionCreateManyInput | AssignmentSubmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssignmentSubmission update
   */
  export type AssignmentSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a AssignmentSubmission.
     */
    data: XOR<AssignmentSubmissionUpdateInput, AssignmentSubmissionUncheckedUpdateInput>
    /**
     * Choose, which AssignmentSubmission to update.
     */
    where: AssignmentSubmissionWhereUniqueInput
  }

  /**
   * AssignmentSubmission updateMany
   */
  export type AssignmentSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssignmentSubmissions.
     */
    data: XOR<AssignmentSubmissionUpdateManyMutationInput, AssignmentSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which AssignmentSubmissions to update
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * Limit how many AssignmentSubmissions to update.
     */
    limit?: number
  }

  /**
   * AssignmentSubmission updateManyAndReturn
   */
  export type AssignmentSubmissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * The data used to update AssignmentSubmissions.
     */
    data: XOR<AssignmentSubmissionUpdateManyMutationInput, AssignmentSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which AssignmentSubmissions to update
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * Limit how many AssignmentSubmissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssignmentSubmission upsert
   */
  export type AssignmentSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the AssignmentSubmission to update in case it exists.
     */
    where: AssignmentSubmissionWhereUniqueInput
    /**
     * In case the AssignmentSubmission found by the `where` argument doesn't exist, create a new AssignmentSubmission with this data.
     */
    create: XOR<AssignmentSubmissionCreateInput, AssignmentSubmissionUncheckedCreateInput>
    /**
     * In case the AssignmentSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssignmentSubmissionUpdateInput, AssignmentSubmissionUncheckedUpdateInput>
  }

  /**
   * AssignmentSubmission delete
   */
  export type AssignmentSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter which AssignmentSubmission to delete.
     */
    where: AssignmentSubmissionWhereUniqueInput
  }

  /**
   * AssignmentSubmission deleteMany
   */
  export type AssignmentSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssignmentSubmissions to delete
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * Limit how many AssignmentSubmissions to delete.
     */
    limit?: number
  }

  /**
   * AssignmentSubmission without action
   */
  export type AssignmentSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssignmentSubmission
     */
    omit?: AssignmentSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
  }


  /**
   * Model Enrollment
   */

  export type AggregateEnrollment = {
    _count: EnrollmentCountAggregateOutputType | null
    _avg: EnrollmentAvgAggregateOutputType | null
    _sum: EnrollmentSumAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  export type EnrollmentAvgAggregateOutputType = {
    progress: number | null
  }

  export type EnrollmentSumAggregateOutputType = {
    progress: number | null
  }

  export type EnrollmentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    progress: number | null
    status: $Enums.EnrollmentStatus | null
    hasInterviewAccess: boolean | null
    batchId: string | null
    enrolledAt: Date | null
    completedAt: Date | null
  }

  export type EnrollmentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    progress: number | null
    status: $Enums.EnrollmentStatus | null
    hasInterviewAccess: boolean | null
    batchId: string | null
    enrolledAt: Date | null
    completedAt: Date | null
  }

  export type EnrollmentCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    progress: number
    status: number
    hasInterviewAccess: number
    batchId: number
    enrolledAt: number
    completedAt: number
    _all: number
  }


  export type EnrollmentAvgAggregateInputType = {
    progress?: true
  }

  export type EnrollmentSumAggregateInputType = {
    progress?: true
  }

  export type EnrollmentMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    progress?: true
    status?: true
    hasInterviewAccess?: true
    batchId?: true
    enrolledAt?: true
    completedAt?: true
  }

  export type EnrollmentMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    progress?: true
    status?: true
    hasInterviewAccess?: true
    batchId?: true
    enrolledAt?: true
    completedAt?: true
  }

  export type EnrollmentCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    progress?: true
    status?: true
    hasInterviewAccess?: true
    batchId?: true
    enrolledAt?: true
    completedAt?: true
    _all?: true
  }

  export type EnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollment to aggregate.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enrollments
    **/
    _count?: true | EnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnrollmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnrollmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnrollmentMaxAggregateInputType
  }

  export type GetEnrollmentAggregateType<T extends EnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrollment[P]>
      : GetScalarType<T[P], AggregateEnrollment[P]>
  }




  export type EnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithAggregationInput | EnrollmentOrderByWithAggregationInput[]
    by: EnrollmentScalarFieldEnum[] | EnrollmentScalarFieldEnum
    having?: EnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnrollmentCountAggregateInputType | true
    _avg?: EnrollmentAvgAggregateInputType
    _sum?: EnrollmentSumAggregateInputType
    _min?: EnrollmentMinAggregateInputType
    _max?: EnrollmentMaxAggregateInputType
  }

  export type EnrollmentGroupByOutputType = {
    id: string
    userId: string
    courseId: string
    progress: number
    status: $Enums.EnrollmentStatus
    hasInterviewAccess: boolean
    batchId: string | null
    enrolledAt: Date
    completedAt: Date | null
    _count: EnrollmentCountAggregateOutputType | null
    _avg: EnrollmentAvgAggregateOutputType | null
    _sum: EnrollmentSumAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  type GetEnrollmentGroupByPayload<T extends EnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type EnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    progress?: boolean
    status?: boolean
    hasInterviewAccess?: boolean
    batchId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    batch?: boolean | Enrollment$batchArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    progress?: boolean
    status?: boolean
    hasInterviewAccess?: boolean
    batchId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    batch?: boolean | Enrollment$batchArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    progress?: boolean
    status?: boolean
    hasInterviewAccess?: boolean
    batchId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    batch?: boolean | Enrollment$batchArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    progress?: boolean
    status?: boolean
    hasInterviewAccess?: boolean
    batchId?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
  }

  export type EnrollmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "courseId" | "progress" | "status" | "hasInterviewAccess" | "batchId" | "enrolledAt" | "completedAt", ExtArgs["result"]["enrollment"]>
  export type EnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    batch?: boolean | Enrollment$batchArgs<ExtArgs>
  }
  export type EnrollmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    batch?: boolean | Enrollment$batchArgs<ExtArgs>
  }
  export type EnrollmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    batch?: boolean | Enrollment$batchArgs<ExtArgs>
  }

  export type $EnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Enrollment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
      batch: Prisma.$BatchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      courseId: string
      progress: number
      status: $Enums.EnrollmentStatus
      hasInterviewAccess: boolean
      batchId: string | null
      enrolledAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["enrollment"]>
    composites: {}
  }

  type EnrollmentGetPayload<S extends boolean | null | undefined | EnrollmentDefaultArgs> = $Result.GetResult<Prisma.$EnrollmentPayload, S>

  type EnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnrollmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnrollmentCountAggregateInputType | true
    }

  export interface EnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enrollment'], meta: { name: 'Enrollment' } }
    /**
     * Find zero or one Enrollment that matches the filter.
     * @param {EnrollmentFindUniqueArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnrollmentFindUniqueArgs>(args: SelectSubset<T, EnrollmentFindUniqueArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Enrollment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnrollmentFindUniqueOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnrollmentFindFirstArgs>(args?: SelectSubset<T, EnrollmentFindFirstArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enrollments
     * const enrollments = await prisma.enrollment.findMany()
     * 
     * // Get first 10 Enrollments
     * const enrollments = await prisma.enrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnrollmentFindManyArgs>(args?: SelectSubset<T, EnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Enrollment.
     * @param {EnrollmentCreateArgs} args - Arguments to create a Enrollment.
     * @example
     * // Create one Enrollment
     * const Enrollment = await prisma.enrollment.create({
     *   data: {
     *     // ... data to create a Enrollment
     *   }
     * })
     * 
     */
    create<T extends EnrollmentCreateArgs>(args: SelectSubset<T, EnrollmentCreateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Enrollments.
     * @param {EnrollmentCreateManyArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnrollmentCreateManyArgs>(args?: SelectSubset<T, EnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Enrollments and returns the data saved in the database.
     * @param {EnrollmentCreateManyAndReturnArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Enrollments and only return the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnrollmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EnrollmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Enrollment.
     * @param {EnrollmentDeleteArgs} args - Arguments to delete one Enrollment.
     * @example
     * // Delete one Enrollment
     * const Enrollment = await prisma.enrollment.delete({
     *   where: {
     *     // ... filter to delete one Enrollment
     *   }
     * })
     * 
     */
    delete<T extends EnrollmentDeleteArgs>(args: SelectSubset<T, EnrollmentDeleteArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Enrollment.
     * @param {EnrollmentUpdateArgs} args - Arguments to update one Enrollment.
     * @example
     * // Update one Enrollment
     * const enrollment = await prisma.enrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnrollmentUpdateArgs>(args: SelectSubset<T, EnrollmentUpdateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Enrollments.
     * @param {EnrollmentDeleteManyArgs} args - Arguments to filter Enrollments to delete.
     * @example
     * // Delete a few Enrollments
     * const { count } = await prisma.enrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnrollmentDeleteManyArgs>(args?: SelectSubset<T, EnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnrollmentUpdateManyArgs>(args: SelectSubset<T, EnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments and returns the data updated in the database.
     * @param {EnrollmentUpdateManyAndReturnArgs} args - Arguments to update many Enrollments.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Enrollments and only return the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnrollmentUpdateManyAndReturnArgs>(args: SelectSubset<T, EnrollmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Enrollment.
     * @param {EnrollmentUpsertArgs} args - Arguments to update or create a Enrollment.
     * @example
     * // Update or create a Enrollment
     * const enrollment = await prisma.enrollment.upsert({
     *   create: {
     *     // ... data to create a Enrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enrollment we want to update
     *   }
     * })
     */
    upsert<T extends EnrollmentUpsertArgs>(args: SelectSubset<T, EnrollmentUpsertArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentCountArgs} args - Arguments to filter Enrollments to count.
     * @example
     * // Count the number of Enrollments
     * const count = await prisma.enrollment.count({
     *   where: {
     *     // ... the filter for the Enrollments we want to count
     *   }
     * })
    **/
    count<T extends EnrollmentCountArgs>(
      args?: Subset<T, EnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnrollmentAggregateArgs>(args: Subset<T, EnrollmentAggregateArgs>): Prisma.PrismaPromise<GetEnrollmentAggregateType<T>>

    /**
     * Group by Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: EnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enrollment model
   */
  readonly fields: EnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    batch<T extends Enrollment$batchArgs<ExtArgs> = {}>(args?: Subset<T, Enrollment$batchArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Enrollment model
   */
  interface EnrollmentFieldRefs {
    readonly id: FieldRef<"Enrollment", 'String'>
    readonly userId: FieldRef<"Enrollment", 'String'>
    readonly courseId: FieldRef<"Enrollment", 'String'>
    readonly progress: FieldRef<"Enrollment", 'Int'>
    readonly status: FieldRef<"Enrollment", 'EnrollmentStatus'>
    readonly hasInterviewAccess: FieldRef<"Enrollment", 'Boolean'>
    readonly batchId: FieldRef<"Enrollment", 'String'>
    readonly enrolledAt: FieldRef<"Enrollment", 'DateTime'>
    readonly completedAt: FieldRef<"Enrollment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Enrollment findUnique
   */
  export type EnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findUniqueOrThrow
   */
  export type EnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findFirst
   */
  export type EnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findFirstOrThrow
   */
  export type EnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findMany
   */
  export type EnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollments to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment create
   */
  export type EnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Enrollment.
     */
    data: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
  }

  /**
   * Enrollment createMany
   */
  export type EnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Enrollment createManyAndReturn
   */
  export type EnrollmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Enrollment update
   */
  export type EnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Enrollment.
     */
    data: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
    /**
     * Choose, which Enrollment to update.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment updateMany
   */
  export type EnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enrollments.
     */
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to update.
     */
    limit?: number
  }

  /**
   * Enrollment updateManyAndReturn
   */
  export type EnrollmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * The data used to update Enrollments.
     */
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Enrollment upsert
   */
  export type EnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Enrollment to update in case it exists.
     */
    where: EnrollmentWhereUniqueInput
    /**
     * In case the Enrollment found by the `where` argument doesn't exist, create a new Enrollment with this data.
     */
    create: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
    /**
     * In case the Enrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
  }

  /**
   * Enrollment delete
   */
  export type EnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter which Enrollment to delete.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment deleteMany
   */
  export type EnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollments to delete
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to delete.
     */
    limit?: number
  }

  /**
   * Enrollment.batch
   */
  export type Enrollment$batchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
  }

  /**
   * Enrollment without action
   */
  export type EnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model LessonProgress
   */

  export type AggregateLessonProgress = {
    _count: LessonProgressCountAggregateOutputType | null
    _avg: LessonProgressAvgAggregateOutputType | null
    _sum: LessonProgressSumAggregateOutputType | null
    _min: LessonProgressMinAggregateOutputType | null
    _max: LessonProgressMaxAggregateOutputType | null
  }

  export type LessonProgressAvgAggregateOutputType = {
    score: number | null
    timeSpent: number | null
  }

  export type LessonProgressSumAggregateOutputType = {
    score: number | null
    timeSpent: number | null
  }

  export type LessonProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    lessonId: string | null
    completed: boolean | null
    score: number | null
    timeSpent: number | null
    lastAccessedAt: Date | null
  }

  export type LessonProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    lessonId: string | null
    completed: boolean | null
    score: number | null
    timeSpent: number | null
    lastAccessedAt: Date | null
  }

  export type LessonProgressCountAggregateOutputType = {
    id: number
    userId: number
    lessonId: number
    completed: number
    score: number
    timeSpent: number
    lastAccessedAt: number
    _all: number
  }


  export type LessonProgressAvgAggregateInputType = {
    score?: true
    timeSpent?: true
  }

  export type LessonProgressSumAggregateInputType = {
    score?: true
    timeSpent?: true
  }

  export type LessonProgressMinAggregateInputType = {
    id?: true
    userId?: true
    lessonId?: true
    completed?: true
    score?: true
    timeSpent?: true
    lastAccessedAt?: true
  }

  export type LessonProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    lessonId?: true
    completed?: true
    score?: true
    timeSpent?: true
    lastAccessedAt?: true
  }

  export type LessonProgressCountAggregateInputType = {
    id?: true
    userId?: true
    lessonId?: true
    completed?: true
    score?: true
    timeSpent?: true
    lastAccessedAt?: true
    _all?: true
  }

  export type LessonProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonProgress to aggregate.
     */
    where?: LessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgresses to fetch.
     */
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LessonProgresses
    **/
    _count?: true | LessonProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonProgressMaxAggregateInputType
  }

  export type GetLessonProgressAggregateType<T extends LessonProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateLessonProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessonProgress[P]>
      : GetScalarType<T[P], AggregateLessonProgress[P]>
  }




  export type LessonProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonProgressWhereInput
    orderBy?: LessonProgressOrderByWithAggregationInput | LessonProgressOrderByWithAggregationInput[]
    by: LessonProgressScalarFieldEnum[] | LessonProgressScalarFieldEnum
    having?: LessonProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonProgressCountAggregateInputType | true
    _avg?: LessonProgressAvgAggregateInputType
    _sum?: LessonProgressSumAggregateInputType
    _min?: LessonProgressMinAggregateInputType
    _max?: LessonProgressMaxAggregateInputType
  }

  export type LessonProgressGroupByOutputType = {
    id: string
    userId: string
    lessonId: string
    completed: boolean
    score: number | null
    timeSpent: number
    lastAccessedAt: Date
    _count: LessonProgressCountAggregateOutputType | null
    _avg: LessonProgressAvgAggregateOutputType | null
    _sum: LessonProgressSumAggregateOutputType | null
    _min: LessonProgressMinAggregateOutputType | null
    _max: LessonProgressMaxAggregateOutputType | null
  }

  type GetLessonProgressGroupByPayload<T extends LessonProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonProgressGroupByOutputType[P]>
            : GetScalarType<T[P], LessonProgressGroupByOutputType[P]>
        }
      >
    >


  export type LessonProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    lessonId?: boolean
    completed?: boolean
    score?: boolean
    timeSpent?: boolean
    lastAccessedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonProgress"]>

  export type LessonProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    lessonId?: boolean
    completed?: boolean
    score?: boolean
    timeSpent?: boolean
    lastAccessedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonProgress"]>

  export type LessonProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    lessonId?: boolean
    completed?: boolean
    score?: boolean
    timeSpent?: boolean
    lastAccessedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonProgress"]>

  export type LessonProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    lessonId?: boolean
    completed?: boolean
    score?: boolean
    timeSpent?: boolean
    lastAccessedAt?: boolean
  }

  export type LessonProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "lessonId" | "completed" | "score" | "timeSpent" | "lastAccessedAt", ExtArgs["result"]["lessonProgress"]>
  export type LessonProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type LessonProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type LessonProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }

  export type $LessonProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LessonProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      lesson: Prisma.$LessonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      lessonId: string
      completed: boolean
      score: number | null
      timeSpent: number
      lastAccessedAt: Date
    }, ExtArgs["result"]["lessonProgress"]>
    composites: {}
  }

  type LessonProgressGetPayload<S extends boolean | null | undefined | LessonProgressDefaultArgs> = $Result.GetResult<Prisma.$LessonProgressPayload, S>

  type LessonProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonProgressCountAggregateInputType | true
    }

  export interface LessonProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LessonProgress'], meta: { name: 'LessonProgress' } }
    /**
     * Find zero or one LessonProgress that matches the filter.
     * @param {LessonProgressFindUniqueArgs} args - Arguments to find a LessonProgress
     * @example
     * // Get one LessonProgress
     * const lessonProgress = await prisma.lessonProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonProgressFindUniqueArgs>(args: SelectSubset<T, LessonProgressFindUniqueArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LessonProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonProgressFindUniqueOrThrowArgs} args - Arguments to find a LessonProgress
     * @example
     * // Get one LessonProgress
     * const lessonProgress = await prisma.lessonProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressFindFirstArgs} args - Arguments to find a LessonProgress
     * @example
     * // Get one LessonProgress
     * const lessonProgress = await prisma.lessonProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonProgressFindFirstArgs>(args?: SelectSubset<T, LessonProgressFindFirstArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LessonProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressFindFirstOrThrowArgs} args - Arguments to find a LessonProgress
     * @example
     * // Get one LessonProgress
     * const lessonProgress = await prisma.lessonProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LessonProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LessonProgresses
     * const lessonProgresses = await prisma.lessonProgress.findMany()
     * 
     * // Get first 10 LessonProgresses
     * const lessonProgresses = await prisma.lessonProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonProgressWithIdOnly = await prisma.lessonProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonProgressFindManyArgs>(args?: SelectSubset<T, LessonProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LessonProgress.
     * @param {LessonProgressCreateArgs} args - Arguments to create a LessonProgress.
     * @example
     * // Create one LessonProgress
     * const LessonProgress = await prisma.lessonProgress.create({
     *   data: {
     *     // ... data to create a LessonProgress
     *   }
     * })
     * 
     */
    create<T extends LessonProgressCreateArgs>(args: SelectSubset<T, LessonProgressCreateArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LessonProgresses.
     * @param {LessonProgressCreateManyArgs} args - Arguments to create many LessonProgresses.
     * @example
     * // Create many LessonProgresses
     * const lessonProgress = await prisma.lessonProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonProgressCreateManyArgs>(args?: SelectSubset<T, LessonProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LessonProgresses and returns the data saved in the database.
     * @param {LessonProgressCreateManyAndReturnArgs} args - Arguments to create many LessonProgresses.
     * @example
     * // Create many LessonProgresses
     * const lessonProgress = await prisma.lessonProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LessonProgresses and only return the `id`
     * const lessonProgressWithIdOnly = await prisma.lessonProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LessonProgress.
     * @param {LessonProgressDeleteArgs} args - Arguments to delete one LessonProgress.
     * @example
     * // Delete one LessonProgress
     * const LessonProgress = await prisma.lessonProgress.delete({
     *   where: {
     *     // ... filter to delete one LessonProgress
     *   }
     * })
     * 
     */
    delete<T extends LessonProgressDeleteArgs>(args: SelectSubset<T, LessonProgressDeleteArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LessonProgress.
     * @param {LessonProgressUpdateArgs} args - Arguments to update one LessonProgress.
     * @example
     * // Update one LessonProgress
     * const lessonProgress = await prisma.lessonProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonProgressUpdateArgs>(args: SelectSubset<T, LessonProgressUpdateArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LessonProgresses.
     * @param {LessonProgressDeleteManyArgs} args - Arguments to filter LessonProgresses to delete.
     * @example
     * // Delete a few LessonProgresses
     * const { count } = await prisma.lessonProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonProgressDeleteManyArgs>(args?: SelectSubset<T, LessonProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LessonProgresses
     * const lessonProgress = await prisma.lessonProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonProgressUpdateManyArgs>(args: SelectSubset<T, LessonProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonProgresses and returns the data updated in the database.
     * @param {LessonProgressUpdateManyAndReturnArgs} args - Arguments to update many LessonProgresses.
     * @example
     * // Update many LessonProgresses
     * const lessonProgress = await prisma.lessonProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LessonProgresses and only return the `id`
     * const lessonProgressWithIdOnly = await prisma.lessonProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LessonProgress.
     * @param {LessonProgressUpsertArgs} args - Arguments to update or create a LessonProgress.
     * @example
     * // Update or create a LessonProgress
     * const lessonProgress = await prisma.lessonProgress.upsert({
     *   create: {
     *     // ... data to create a LessonProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LessonProgress we want to update
     *   }
     * })
     */
    upsert<T extends LessonProgressUpsertArgs>(args: SelectSubset<T, LessonProgressUpsertArgs<ExtArgs>>): Prisma__LessonProgressClient<$Result.GetResult<Prisma.$LessonProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LessonProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressCountArgs} args - Arguments to filter LessonProgresses to count.
     * @example
     * // Count the number of LessonProgresses
     * const count = await prisma.lessonProgress.count({
     *   where: {
     *     // ... the filter for the LessonProgresses we want to count
     *   }
     * })
    **/
    count<T extends LessonProgressCountArgs>(
      args?: Subset<T, LessonProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LessonProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonProgressAggregateArgs>(args: Subset<T, LessonProgressAggregateArgs>): Prisma.PrismaPromise<GetLessonProgressAggregateType<T>>

    /**
     * Group by LessonProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonProgressGroupByArgs['orderBy'] }
        : { orderBy?: LessonProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LessonProgress model
   */
  readonly fields: LessonProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LessonProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LessonProgress model
   */
  interface LessonProgressFieldRefs {
    readonly id: FieldRef<"LessonProgress", 'String'>
    readonly userId: FieldRef<"LessonProgress", 'String'>
    readonly lessonId: FieldRef<"LessonProgress", 'String'>
    readonly completed: FieldRef<"LessonProgress", 'Boolean'>
    readonly score: FieldRef<"LessonProgress", 'Int'>
    readonly timeSpent: FieldRef<"LessonProgress", 'Int'>
    readonly lastAccessedAt: FieldRef<"LessonProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LessonProgress findUnique
   */
  export type LessonProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgress to fetch.
     */
    where: LessonProgressWhereUniqueInput
  }

  /**
   * LessonProgress findUniqueOrThrow
   */
  export type LessonProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgress to fetch.
     */
    where: LessonProgressWhereUniqueInput
  }

  /**
   * LessonProgress findFirst
   */
  export type LessonProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgress to fetch.
     */
    where?: LessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgresses to fetch.
     */
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonProgresses.
     */
    cursor?: LessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonProgresses.
     */
    distinct?: LessonProgressScalarFieldEnum | LessonProgressScalarFieldEnum[]
  }

  /**
   * LessonProgress findFirstOrThrow
   */
  export type LessonProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgress to fetch.
     */
    where?: LessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgresses to fetch.
     */
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonProgresses.
     */
    cursor?: LessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonProgresses.
     */
    distinct?: LessonProgressScalarFieldEnum | LessonProgressScalarFieldEnum[]
  }

  /**
   * LessonProgress findMany
   */
  export type LessonProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter, which LessonProgresses to fetch.
     */
    where?: LessonProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonProgresses to fetch.
     */
    orderBy?: LessonProgressOrderByWithRelationInput | LessonProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LessonProgresses.
     */
    cursor?: LessonProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonProgresses.
     */
    skip?: number
    distinct?: LessonProgressScalarFieldEnum | LessonProgressScalarFieldEnum[]
  }

  /**
   * LessonProgress create
   */
  export type LessonProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a LessonProgress.
     */
    data: XOR<LessonProgressCreateInput, LessonProgressUncheckedCreateInput>
  }

  /**
   * LessonProgress createMany
   */
  export type LessonProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LessonProgresses.
     */
    data: LessonProgressCreateManyInput | LessonProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LessonProgress createManyAndReturn
   */
  export type LessonProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * The data used to create many LessonProgresses.
     */
    data: LessonProgressCreateManyInput | LessonProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonProgress update
   */
  export type LessonProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a LessonProgress.
     */
    data: XOR<LessonProgressUpdateInput, LessonProgressUncheckedUpdateInput>
    /**
     * Choose, which LessonProgress to update.
     */
    where: LessonProgressWhereUniqueInput
  }

  /**
   * LessonProgress updateMany
   */
  export type LessonProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LessonProgresses.
     */
    data: XOR<LessonProgressUpdateManyMutationInput, LessonProgressUncheckedUpdateManyInput>
    /**
     * Filter which LessonProgresses to update
     */
    where?: LessonProgressWhereInput
    /**
     * Limit how many LessonProgresses to update.
     */
    limit?: number
  }

  /**
   * LessonProgress updateManyAndReturn
   */
  export type LessonProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * The data used to update LessonProgresses.
     */
    data: XOR<LessonProgressUpdateManyMutationInput, LessonProgressUncheckedUpdateManyInput>
    /**
     * Filter which LessonProgresses to update
     */
    where?: LessonProgressWhereInput
    /**
     * Limit how many LessonProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonProgress upsert
   */
  export type LessonProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the LessonProgress to update in case it exists.
     */
    where: LessonProgressWhereUniqueInput
    /**
     * In case the LessonProgress found by the `where` argument doesn't exist, create a new LessonProgress with this data.
     */
    create: XOR<LessonProgressCreateInput, LessonProgressUncheckedCreateInput>
    /**
     * In case the LessonProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonProgressUpdateInput, LessonProgressUncheckedUpdateInput>
  }

  /**
   * LessonProgress delete
   */
  export type LessonProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
    /**
     * Filter which LessonProgress to delete.
     */
    where: LessonProgressWhereUniqueInput
  }

  /**
   * LessonProgress deleteMany
   */
  export type LessonProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonProgresses to delete
     */
    where?: LessonProgressWhereInput
    /**
     * Limit how many LessonProgresses to delete.
     */
    limit?: number
  }

  /**
   * LessonProgress without action
   */
  export type LessonProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonProgress
     */
    select?: LessonProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LessonProgress
     */
    omit?: LessonProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonProgressInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    rating: number
    comment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    userId: string
    courseId: string
    rating: number
    comment: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "courseId" | "rating" | "comment" | "createdAt" | "updatedAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      courseId: string
      rating: number
      comment: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly userId: FieldRef<"Review", 'String'>
    readonly courseId: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Interview
   */

  export type AggregateInterview = {
    _count: InterviewCountAggregateOutputType | null
    _avg: InterviewAvgAggregateOutputType | null
    _sum: InterviewSumAggregateOutputType | null
    _min: InterviewMinAggregateOutputType | null
    _max: InterviewMaxAggregateOutputType | null
  }

  export type InterviewAvgAggregateOutputType = {
    panelCount: number | null
    duration: number | null
  }

  export type InterviewSumAggregateOutputType = {
    panelCount: number | null
    duration: number | null
  }

  export type InterviewMinAggregateOutputType = {
    id: string | null
    userId: string | null
    domain: string | null
    company: string | null
    role: string | null
    technology: string | null
    jobDescription: string | null
    resumeUrl: string | null
    difficulty: $Enums.Difficulty | null
    panelCount: number | null
    linkedCourseId: string | null
    duration: number | null
    status: $Enums.InterviewStatus | null
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type InterviewMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    domain: string | null
    company: string | null
    role: string | null
    technology: string | null
    jobDescription: string | null
    resumeUrl: string | null
    difficulty: $Enums.Difficulty | null
    panelCount: number | null
    linkedCourseId: string | null
    duration: number | null
    status: $Enums.InterviewStatus | null
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type InterviewCountAggregateOutputType = {
    id: number
    userId: number
    domain: number
    company: number
    role: number
    technology: number
    jobDescription: number
    resumeUrl: number
    difficulty: number
    panelCount: number
    linkedCourseId: number
    duration: number
    selectedAvatars: number
    status: number
    scheduledAt: number
    startedAt: number
    completedAt: number
    createdAt: number
    _all: number
  }


  export type InterviewAvgAggregateInputType = {
    panelCount?: true
    duration?: true
  }

  export type InterviewSumAggregateInputType = {
    panelCount?: true
    duration?: true
  }

  export type InterviewMinAggregateInputType = {
    id?: true
    userId?: true
    domain?: true
    company?: true
    role?: true
    technology?: true
    jobDescription?: true
    resumeUrl?: true
    difficulty?: true
    panelCount?: true
    linkedCourseId?: true
    duration?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
  }

  export type InterviewMaxAggregateInputType = {
    id?: true
    userId?: true
    domain?: true
    company?: true
    role?: true
    technology?: true
    jobDescription?: true
    resumeUrl?: true
    difficulty?: true
    panelCount?: true
    linkedCourseId?: true
    duration?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
  }

  export type InterviewCountAggregateInputType = {
    id?: true
    userId?: true
    domain?: true
    company?: true
    role?: true
    technology?: true
    jobDescription?: true
    resumeUrl?: true
    difficulty?: true
    panelCount?: true
    linkedCourseId?: true
    duration?: true
    selectedAvatars?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    _all?: true
  }

  export type InterviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interview to aggregate.
     */
    where?: InterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviews to fetch.
     */
    orderBy?: InterviewOrderByWithRelationInput | InterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interviews
    **/
    _count?: true | InterviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterviewMaxAggregateInputType
  }

  export type GetInterviewAggregateType<T extends InterviewAggregateArgs> = {
        [P in keyof T & keyof AggregateInterview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterview[P]>
      : GetScalarType<T[P], AggregateInterview[P]>
  }




  export type InterviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewWhereInput
    orderBy?: InterviewOrderByWithAggregationInput | InterviewOrderByWithAggregationInput[]
    by: InterviewScalarFieldEnum[] | InterviewScalarFieldEnum
    having?: InterviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterviewCountAggregateInputType | true
    _avg?: InterviewAvgAggregateInputType
    _sum?: InterviewSumAggregateInputType
    _min?: InterviewMinAggregateInputType
    _max?: InterviewMaxAggregateInputType
  }

  export type InterviewGroupByOutputType = {
    id: string
    userId: string
    domain: string
    company: string | null
    role: string
    technology: string | null
    jobDescription: string | null
    resumeUrl: string | null
    difficulty: $Enums.Difficulty
    panelCount: number
    linkedCourseId: string | null
    duration: number
    selectedAvatars: string[]
    status: $Enums.InterviewStatus
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date
    _count: InterviewCountAggregateOutputType | null
    _avg: InterviewAvgAggregateOutputType | null
    _sum: InterviewSumAggregateOutputType | null
    _min: InterviewMinAggregateOutputType | null
    _max: InterviewMaxAggregateOutputType | null
  }

  type GetInterviewGroupByPayload<T extends InterviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterviewGroupByOutputType[P]>
            : GetScalarType<T[P], InterviewGroupByOutputType[P]>
        }
      >
    >


  export type InterviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    domain?: boolean
    company?: boolean
    role?: boolean
    technology?: boolean
    jobDescription?: boolean
    resumeUrl?: boolean
    difficulty?: boolean
    panelCount?: boolean
    linkedCourseId?: boolean
    duration?: boolean
    selectedAvatars?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    questions?: boolean | Interview$questionsArgs<ExtArgs>
    responses?: boolean | Interview$responsesArgs<ExtArgs>
    evaluation?: boolean | Interview$evaluationArgs<ExtArgs>
    _count?: boolean | InterviewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interview"]>

  export type InterviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    domain?: boolean
    company?: boolean
    role?: boolean
    technology?: boolean
    jobDescription?: boolean
    resumeUrl?: boolean
    difficulty?: boolean
    panelCount?: boolean
    linkedCourseId?: boolean
    duration?: boolean
    selectedAvatars?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interview"]>

  export type InterviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    domain?: boolean
    company?: boolean
    role?: boolean
    technology?: boolean
    jobDescription?: boolean
    resumeUrl?: boolean
    difficulty?: boolean
    panelCount?: boolean
    linkedCourseId?: boolean
    duration?: boolean
    selectedAvatars?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interview"]>

  export type InterviewSelectScalar = {
    id?: boolean
    userId?: boolean
    domain?: boolean
    company?: boolean
    role?: boolean
    technology?: boolean
    jobDescription?: boolean
    resumeUrl?: boolean
    difficulty?: boolean
    panelCount?: boolean
    linkedCourseId?: boolean
    duration?: boolean
    selectedAvatars?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
  }

  export type InterviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "domain" | "company" | "role" | "technology" | "jobDescription" | "resumeUrl" | "difficulty" | "panelCount" | "linkedCourseId" | "duration" | "selectedAvatars" | "status" | "scheduledAt" | "startedAt" | "completedAt" | "createdAt", ExtArgs["result"]["interview"]>
  export type InterviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    questions?: boolean | Interview$questionsArgs<ExtArgs>
    responses?: boolean | Interview$responsesArgs<ExtArgs>
    evaluation?: boolean | Interview$evaluationArgs<ExtArgs>
    _count?: boolean | InterviewCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InterviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InterviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InterviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Interview"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      questions: Prisma.$InterviewQuestionPayload<ExtArgs>[]
      responses: Prisma.$InterviewResponsePayload<ExtArgs>[]
      evaluation: Prisma.$InterviewEvaluationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      domain: string
      company: string | null
      role: string
      technology: string | null
      jobDescription: string | null
      resumeUrl: string | null
      difficulty: $Enums.Difficulty
      panelCount: number
      linkedCourseId: string | null
      duration: number
      selectedAvatars: string[]
      status: $Enums.InterviewStatus
      scheduledAt: Date | null
      startedAt: Date | null
      completedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["interview"]>
    composites: {}
  }

  type InterviewGetPayload<S extends boolean | null | undefined | InterviewDefaultArgs> = $Result.GetResult<Prisma.$InterviewPayload, S>

  type InterviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterviewCountAggregateInputType | true
    }

  export interface InterviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Interview'], meta: { name: 'Interview' } }
    /**
     * Find zero or one Interview that matches the filter.
     * @param {InterviewFindUniqueArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterviewFindUniqueArgs>(args: SelectSubset<T, InterviewFindUniqueArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Interview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterviewFindUniqueOrThrowArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterviewFindUniqueOrThrowArgs>(args: SelectSubset<T, InterviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFindFirstArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterviewFindFirstArgs>(args?: SelectSubset<T, InterviewFindFirstArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFindFirstOrThrowArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterviewFindFirstOrThrowArgs>(args?: SelectSubset<T, InterviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Interviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interviews
     * const interviews = await prisma.interview.findMany()
     * 
     * // Get first 10 Interviews
     * const interviews = await prisma.interview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interviewWithIdOnly = await prisma.interview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterviewFindManyArgs>(args?: SelectSubset<T, InterviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Interview.
     * @param {InterviewCreateArgs} args - Arguments to create a Interview.
     * @example
     * // Create one Interview
     * const Interview = await prisma.interview.create({
     *   data: {
     *     // ... data to create a Interview
     *   }
     * })
     * 
     */
    create<T extends InterviewCreateArgs>(args: SelectSubset<T, InterviewCreateArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Interviews.
     * @param {InterviewCreateManyArgs} args - Arguments to create many Interviews.
     * @example
     * // Create many Interviews
     * const interview = await prisma.interview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterviewCreateManyArgs>(args?: SelectSubset<T, InterviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Interviews and returns the data saved in the database.
     * @param {InterviewCreateManyAndReturnArgs} args - Arguments to create many Interviews.
     * @example
     * // Create many Interviews
     * const interview = await prisma.interview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Interviews and only return the `id`
     * const interviewWithIdOnly = await prisma.interview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterviewCreateManyAndReturnArgs>(args?: SelectSubset<T, InterviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Interview.
     * @param {InterviewDeleteArgs} args - Arguments to delete one Interview.
     * @example
     * // Delete one Interview
     * const Interview = await prisma.interview.delete({
     *   where: {
     *     // ... filter to delete one Interview
     *   }
     * })
     * 
     */
    delete<T extends InterviewDeleteArgs>(args: SelectSubset<T, InterviewDeleteArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Interview.
     * @param {InterviewUpdateArgs} args - Arguments to update one Interview.
     * @example
     * // Update one Interview
     * const interview = await prisma.interview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterviewUpdateArgs>(args: SelectSubset<T, InterviewUpdateArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Interviews.
     * @param {InterviewDeleteManyArgs} args - Arguments to filter Interviews to delete.
     * @example
     * // Delete a few Interviews
     * const { count } = await prisma.interview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterviewDeleteManyArgs>(args?: SelectSubset<T, InterviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interviews
     * const interview = await prisma.interview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterviewUpdateManyArgs>(args: SelectSubset<T, InterviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interviews and returns the data updated in the database.
     * @param {InterviewUpdateManyAndReturnArgs} args - Arguments to update many Interviews.
     * @example
     * // Update many Interviews
     * const interview = await prisma.interview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Interviews and only return the `id`
     * const interviewWithIdOnly = await prisma.interview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterviewUpdateManyAndReturnArgs>(args: SelectSubset<T, InterviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Interview.
     * @param {InterviewUpsertArgs} args - Arguments to update or create a Interview.
     * @example
     * // Update or create a Interview
     * const interview = await prisma.interview.upsert({
     *   create: {
     *     // ... data to create a Interview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Interview we want to update
     *   }
     * })
     */
    upsert<T extends InterviewUpsertArgs>(args: SelectSubset<T, InterviewUpsertArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Interviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewCountArgs} args - Arguments to filter Interviews to count.
     * @example
     * // Count the number of Interviews
     * const count = await prisma.interview.count({
     *   where: {
     *     // ... the filter for the Interviews we want to count
     *   }
     * })
    **/
    count<T extends InterviewCountArgs>(
      args?: Subset<T, InterviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Interview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterviewAggregateArgs>(args: Subset<T, InterviewAggregateArgs>): Prisma.PrismaPromise<GetInterviewAggregateType<T>>

    /**
     * Group by Interview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterviewGroupByArgs['orderBy'] }
        : { orderBy?: InterviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Interview model
   */
  readonly fields: InterviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Interview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    questions<T extends Interview$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Interview$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    responses<T extends Interview$responsesArgs<ExtArgs> = {}>(args?: Subset<T, Interview$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    evaluation<T extends Interview$evaluationArgs<ExtArgs> = {}>(args?: Subset<T, Interview$evaluationArgs<ExtArgs>>): Prisma__InterviewEvaluationClient<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Interview model
   */
  interface InterviewFieldRefs {
    readonly id: FieldRef<"Interview", 'String'>
    readonly userId: FieldRef<"Interview", 'String'>
    readonly domain: FieldRef<"Interview", 'String'>
    readonly company: FieldRef<"Interview", 'String'>
    readonly role: FieldRef<"Interview", 'String'>
    readonly technology: FieldRef<"Interview", 'String'>
    readonly jobDescription: FieldRef<"Interview", 'String'>
    readonly resumeUrl: FieldRef<"Interview", 'String'>
    readonly difficulty: FieldRef<"Interview", 'Difficulty'>
    readonly panelCount: FieldRef<"Interview", 'Int'>
    readonly linkedCourseId: FieldRef<"Interview", 'String'>
    readonly duration: FieldRef<"Interview", 'Int'>
    readonly selectedAvatars: FieldRef<"Interview", 'String[]'>
    readonly status: FieldRef<"Interview", 'InterviewStatus'>
    readonly scheduledAt: FieldRef<"Interview", 'DateTime'>
    readonly startedAt: FieldRef<"Interview", 'DateTime'>
    readonly completedAt: FieldRef<"Interview", 'DateTime'>
    readonly createdAt: FieldRef<"Interview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Interview findUnique
   */
  export type InterviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * Filter, which Interview to fetch.
     */
    where: InterviewWhereUniqueInput
  }

  /**
   * Interview findUniqueOrThrow
   */
  export type InterviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * Filter, which Interview to fetch.
     */
    where: InterviewWhereUniqueInput
  }

  /**
   * Interview findFirst
   */
  export type InterviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * Filter, which Interview to fetch.
     */
    where?: InterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviews to fetch.
     */
    orderBy?: InterviewOrderByWithRelationInput | InterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interviews.
     */
    cursor?: InterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interviews.
     */
    distinct?: InterviewScalarFieldEnum | InterviewScalarFieldEnum[]
  }

  /**
   * Interview findFirstOrThrow
   */
  export type InterviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * Filter, which Interview to fetch.
     */
    where?: InterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviews to fetch.
     */
    orderBy?: InterviewOrderByWithRelationInput | InterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interviews.
     */
    cursor?: InterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interviews.
     */
    distinct?: InterviewScalarFieldEnum | InterviewScalarFieldEnum[]
  }

  /**
   * Interview findMany
   */
  export type InterviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * Filter, which Interviews to fetch.
     */
    where?: InterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviews to fetch.
     */
    orderBy?: InterviewOrderByWithRelationInput | InterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interviews.
     */
    cursor?: InterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviews.
     */
    skip?: number
    distinct?: InterviewScalarFieldEnum | InterviewScalarFieldEnum[]
  }

  /**
   * Interview create
   */
  export type InterviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Interview.
     */
    data: XOR<InterviewCreateInput, InterviewUncheckedCreateInput>
  }

  /**
   * Interview createMany
   */
  export type InterviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Interviews.
     */
    data: InterviewCreateManyInput | InterviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Interview createManyAndReturn
   */
  export type InterviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * The data used to create many Interviews.
     */
    data: InterviewCreateManyInput | InterviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Interview update
   */
  export type InterviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Interview.
     */
    data: XOR<InterviewUpdateInput, InterviewUncheckedUpdateInput>
    /**
     * Choose, which Interview to update.
     */
    where: InterviewWhereUniqueInput
  }

  /**
   * Interview updateMany
   */
  export type InterviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Interviews.
     */
    data: XOR<InterviewUpdateManyMutationInput, InterviewUncheckedUpdateManyInput>
    /**
     * Filter which Interviews to update
     */
    where?: InterviewWhereInput
    /**
     * Limit how many Interviews to update.
     */
    limit?: number
  }

  /**
   * Interview updateManyAndReturn
   */
  export type InterviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * The data used to update Interviews.
     */
    data: XOR<InterviewUpdateManyMutationInput, InterviewUncheckedUpdateManyInput>
    /**
     * Filter which Interviews to update
     */
    where?: InterviewWhereInput
    /**
     * Limit how many Interviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Interview upsert
   */
  export type InterviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Interview to update in case it exists.
     */
    where: InterviewWhereUniqueInput
    /**
     * In case the Interview found by the `where` argument doesn't exist, create a new Interview with this data.
     */
    create: XOR<InterviewCreateInput, InterviewUncheckedCreateInput>
    /**
     * In case the Interview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterviewUpdateInput, InterviewUncheckedUpdateInput>
  }

  /**
   * Interview delete
   */
  export type InterviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
    /**
     * Filter which Interview to delete.
     */
    where: InterviewWhereUniqueInput
  }

  /**
   * Interview deleteMany
   */
  export type InterviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interviews to delete
     */
    where?: InterviewWhereInput
    /**
     * Limit how many Interviews to delete.
     */
    limit?: number
  }

  /**
   * Interview.questions
   */
  export type Interview$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewQuestion
     */
    select?: InterviewQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewQuestion
     */
    omit?: InterviewQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewQuestionInclude<ExtArgs> | null
    where?: InterviewQuestionWhereInput
    orderBy?: InterviewQuestionOrderByWithRelationInput | InterviewQuestionOrderByWithRelationInput[]
    cursor?: InterviewQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterviewQuestionScalarFieldEnum | InterviewQuestionScalarFieldEnum[]
  }

  /**
   * Interview.responses
   */
  export type Interview$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResponse
     */
    select?: InterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewResponse
     */
    omit?: InterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResponseInclude<ExtArgs> | null
    where?: InterviewResponseWhereInput
    orderBy?: InterviewResponseOrderByWithRelationInput | InterviewResponseOrderByWithRelationInput[]
    cursor?: InterviewResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterviewResponseScalarFieldEnum | InterviewResponseScalarFieldEnum[]
  }

  /**
   * Interview.evaluation
   */
  export type Interview$evaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
    where?: InterviewEvaluationWhereInput
  }

  /**
   * Interview without action
   */
  export type InterviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewInclude<ExtArgs> | null
  }


  /**
   * Model InterviewQuestion
   */

  export type AggregateInterviewQuestion = {
    _count: InterviewQuestionCountAggregateOutputType | null
    _avg: InterviewQuestionAvgAggregateOutputType | null
    _sum: InterviewQuestionSumAggregateOutputType | null
    _min: InterviewQuestionMinAggregateOutputType | null
    _max: InterviewQuestionMaxAggregateOutputType | null
  }

  export type InterviewQuestionAvgAggregateOutputType = {
    order: number | null
  }

  export type InterviewQuestionSumAggregateOutputType = {
    order: number | null
  }

  export type InterviewQuestionMinAggregateOutputType = {
    id: string | null
    interviewId: string | null
    avatarId: string | null
    question: string | null
    type: $Enums.QuestionType | null
    order: number | null
  }

  export type InterviewQuestionMaxAggregateOutputType = {
    id: string | null
    interviewId: string | null
    avatarId: string | null
    question: string | null
    type: $Enums.QuestionType | null
    order: number | null
  }

  export type InterviewQuestionCountAggregateOutputType = {
    id: number
    interviewId: number
    avatarId: number
    question: number
    type: number
    order: number
    _all: number
  }


  export type InterviewQuestionAvgAggregateInputType = {
    order?: true
  }

  export type InterviewQuestionSumAggregateInputType = {
    order?: true
  }

  export type InterviewQuestionMinAggregateInputType = {
    id?: true
    interviewId?: true
    avatarId?: true
    question?: true
    type?: true
    order?: true
  }

  export type InterviewQuestionMaxAggregateInputType = {
    id?: true
    interviewId?: true
    avatarId?: true
    question?: true
    type?: true
    order?: true
  }

  export type InterviewQuestionCountAggregateInputType = {
    id?: true
    interviewId?: true
    avatarId?: true
    question?: true
    type?: true
    order?: true
    _all?: true
  }

  export type InterviewQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewQuestion to aggregate.
     */
    where?: InterviewQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewQuestions to fetch.
     */
    orderBy?: InterviewQuestionOrderByWithRelationInput | InterviewQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterviewQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterviewQuestions
    **/
    _count?: true | InterviewQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterviewQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterviewQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterviewQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterviewQuestionMaxAggregateInputType
  }

  export type GetInterviewQuestionAggregateType<T extends InterviewQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateInterviewQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterviewQuestion[P]>
      : GetScalarType<T[P], AggregateInterviewQuestion[P]>
  }




  export type InterviewQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewQuestionWhereInput
    orderBy?: InterviewQuestionOrderByWithAggregationInput | InterviewQuestionOrderByWithAggregationInput[]
    by: InterviewQuestionScalarFieldEnum[] | InterviewQuestionScalarFieldEnum
    having?: InterviewQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterviewQuestionCountAggregateInputType | true
    _avg?: InterviewQuestionAvgAggregateInputType
    _sum?: InterviewQuestionSumAggregateInputType
    _min?: InterviewQuestionMinAggregateInputType
    _max?: InterviewQuestionMaxAggregateInputType
  }

  export type InterviewQuestionGroupByOutputType = {
    id: string
    interviewId: string
    avatarId: string | null
    question: string
    type: $Enums.QuestionType
    order: number
    _count: InterviewQuestionCountAggregateOutputType | null
    _avg: InterviewQuestionAvgAggregateOutputType | null
    _sum: InterviewQuestionSumAggregateOutputType | null
    _min: InterviewQuestionMinAggregateOutputType | null
    _max: InterviewQuestionMaxAggregateOutputType | null
  }

  type GetInterviewQuestionGroupByPayload<T extends InterviewQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterviewQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterviewQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterviewQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], InterviewQuestionGroupByOutputType[P]>
        }
      >
    >


  export type InterviewQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interviewId?: boolean
    avatarId?: boolean
    question?: boolean
    type?: boolean
    order?: boolean
    interview?: boolean | InterviewDefaultArgs<ExtArgs>
    response?: boolean | InterviewQuestion$responseArgs<ExtArgs>
  }, ExtArgs["result"]["interviewQuestion"]>

  export type InterviewQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interviewId?: boolean
    avatarId?: boolean
    question?: boolean
    type?: boolean
    order?: boolean
    interview?: boolean | InterviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewQuestion"]>

  export type InterviewQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interviewId?: boolean
    avatarId?: boolean
    question?: boolean
    type?: boolean
    order?: boolean
    interview?: boolean | InterviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewQuestion"]>

  export type InterviewQuestionSelectScalar = {
    id?: boolean
    interviewId?: boolean
    avatarId?: boolean
    question?: boolean
    type?: boolean
    order?: boolean
  }

  export type InterviewQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "interviewId" | "avatarId" | "question" | "type" | "order", ExtArgs["result"]["interviewQuestion"]>
  export type InterviewQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | InterviewDefaultArgs<ExtArgs>
    response?: boolean | InterviewQuestion$responseArgs<ExtArgs>
  }
  export type InterviewQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | InterviewDefaultArgs<ExtArgs>
  }
  export type InterviewQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | InterviewDefaultArgs<ExtArgs>
  }

  export type $InterviewQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InterviewQuestion"
    objects: {
      interview: Prisma.$InterviewPayload<ExtArgs>
      response: Prisma.$InterviewResponsePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      interviewId: string
      avatarId: string | null
      question: string
      type: $Enums.QuestionType
      order: number
    }, ExtArgs["result"]["interviewQuestion"]>
    composites: {}
  }

  type InterviewQuestionGetPayload<S extends boolean | null | undefined | InterviewQuestionDefaultArgs> = $Result.GetResult<Prisma.$InterviewQuestionPayload, S>

  type InterviewQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterviewQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterviewQuestionCountAggregateInputType | true
    }

  export interface InterviewQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InterviewQuestion'], meta: { name: 'InterviewQuestion' } }
    /**
     * Find zero or one InterviewQuestion that matches the filter.
     * @param {InterviewQuestionFindUniqueArgs} args - Arguments to find a InterviewQuestion
     * @example
     * // Get one InterviewQuestion
     * const interviewQuestion = await prisma.interviewQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterviewQuestionFindUniqueArgs>(args: SelectSubset<T, InterviewQuestionFindUniqueArgs<ExtArgs>>): Prisma__InterviewQuestionClient<$Result.GetResult<Prisma.$InterviewQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InterviewQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterviewQuestionFindUniqueOrThrowArgs} args - Arguments to find a InterviewQuestion
     * @example
     * // Get one InterviewQuestion
     * const interviewQuestion = await prisma.interviewQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterviewQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, InterviewQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterviewQuestionClient<$Result.GetResult<Prisma.$InterviewQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterviewQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewQuestionFindFirstArgs} args - Arguments to find a InterviewQuestion
     * @example
     * // Get one InterviewQuestion
     * const interviewQuestion = await prisma.interviewQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterviewQuestionFindFirstArgs>(args?: SelectSubset<T, InterviewQuestionFindFirstArgs<ExtArgs>>): Prisma__InterviewQuestionClient<$Result.GetResult<Prisma.$InterviewQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterviewQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewQuestionFindFirstOrThrowArgs} args - Arguments to find a InterviewQuestion
     * @example
     * // Get one InterviewQuestion
     * const interviewQuestion = await prisma.interviewQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterviewQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, InterviewQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterviewQuestionClient<$Result.GetResult<Prisma.$InterviewQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InterviewQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterviewQuestions
     * const interviewQuestions = await prisma.interviewQuestion.findMany()
     * 
     * // Get first 10 InterviewQuestions
     * const interviewQuestions = await prisma.interviewQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interviewQuestionWithIdOnly = await prisma.interviewQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterviewQuestionFindManyArgs>(args?: SelectSubset<T, InterviewQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InterviewQuestion.
     * @param {InterviewQuestionCreateArgs} args - Arguments to create a InterviewQuestion.
     * @example
     * // Create one InterviewQuestion
     * const InterviewQuestion = await prisma.interviewQuestion.create({
     *   data: {
     *     // ... data to create a InterviewQuestion
     *   }
     * })
     * 
     */
    create<T extends InterviewQuestionCreateArgs>(args: SelectSubset<T, InterviewQuestionCreateArgs<ExtArgs>>): Prisma__InterviewQuestionClient<$Result.GetResult<Prisma.$InterviewQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InterviewQuestions.
     * @param {InterviewQuestionCreateManyArgs} args - Arguments to create many InterviewQuestions.
     * @example
     * // Create many InterviewQuestions
     * const interviewQuestion = await prisma.interviewQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterviewQuestionCreateManyArgs>(args?: SelectSubset<T, InterviewQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InterviewQuestions and returns the data saved in the database.
     * @param {InterviewQuestionCreateManyAndReturnArgs} args - Arguments to create many InterviewQuestions.
     * @example
     * // Create many InterviewQuestions
     * const interviewQuestion = await prisma.interviewQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InterviewQuestions and only return the `id`
     * const interviewQuestionWithIdOnly = await prisma.interviewQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterviewQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, InterviewQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InterviewQuestion.
     * @param {InterviewQuestionDeleteArgs} args - Arguments to delete one InterviewQuestion.
     * @example
     * // Delete one InterviewQuestion
     * const InterviewQuestion = await prisma.interviewQuestion.delete({
     *   where: {
     *     // ... filter to delete one InterviewQuestion
     *   }
     * })
     * 
     */
    delete<T extends InterviewQuestionDeleteArgs>(args: SelectSubset<T, InterviewQuestionDeleteArgs<ExtArgs>>): Prisma__InterviewQuestionClient<$Result.GetResult<Prisma.$InterviewQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InterviewQuestion.
     * @param {InterviewQuestionUpdateArgs} args - Arguments to update one InterviewQuestion.
     * @example
     * // Update one InterviewQuestion
     * const interviewQuestion = await prisma.interviewQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterviewQuestionUpdateArgs>(args: SelectSubset<T, InterviewQuestionUpdateArgs<ExtArgs>>): Prisma__InterviewQuestionClient<$Result.GetResult<Prisma.$InterviewQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InterviewQuestions.
     * @param {InterviewQuestionDeleteManyArgs} args - Arguments to filter InterviewQuestions to delete.
     * @example
     * // Delete a few InterviewQuestions
     * const { count } = await prisma.interviewQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterviewQuestionDeleteManyArgs>(args?: SelectSubset<T, InterviewQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterviewQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterviewQuestions
     * const interviewQuestion = await prisma.interviewQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterviewQuestionUpdateManyArgs>(args: SelectSubset<T, InterviewQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterviewQuestions and returns the data updated in the database.
     * @param {InterviewQuestionUpdateManyAndReturnArgs} args - Arguments to update many InterviewQuestions.
     * @example
     * // Update many InterviewQuestions
     * const interviewQuestion = await prisma.interviewQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InterviewQuestions and only return the `id`
     * const interviewQuestionWithIdOnly = await prisma.interviewQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterviewQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, InterviewQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InterviewQuestion.
     * @param {InterviewQuestionUpsertArgs} args - Arguments to update or create a InterviewQuestion.
     * @example
     * // Update or create a InterviewQuestion
     * const interviewQuestion = await prisma.interviewQuestion.upsert({
     *   create: {
     *     // ... data to create a InterviewQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterviewQuestion we want to update
     *   }
     * })
     */
    upsert<T extends InterviewQuestionUpsertArgs>(args: SelectSubset<T, InterviewQuestionUpsertArgs<ExtArgs>>): Prisma__InterviewQuestionClient<$Result.GetResult<Prisma.$InterviewQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InterviewQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewQuestionCountArgs} args - Arguments to filter InterviewQuestions to count.
     * @example
     * // Count the number of InterviewQuestions
     * const count = await prisma.interviewQuestion.count({
     *   where: {
     *     // ... the filter for the InterviewQuestions we want to count
     *   }
     * })
    **/
    count<T extends InterviewQuestionCountArgs>(
      args?: Subset<T, InterviewQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterviewQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterviewQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterviewQuestionAggregateArgs>(args: Subset<T, InterviewQuestionAggregateArgs>): Prisma.PrismaPromise<GetInterviewQuestionAggregateType<T>>

    /**
     * Group by InterviewQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterviewQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterviewQuestionGroupByArgs['orderBy'] }
        : { orderBy?: InterviewQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterviewQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterviewQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InterviewQuestion model
   */
  readonly fields: InterviewQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InterviewQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterviewQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interview<T extends InterviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InterviewDefaultArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    response<T extends InterviewQuestion$responseArgs<ExtArgs> = {}>(args?: Subset<T, InterviewQuestion$responseArgs<ExtArgs>>): Prisma__InterviewResponseClient<$Result.GetResult<Prisma.$InterviewResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InterviewQuestion model
   */
  interface InterviewQuestionFieldRefs {
    readonly id: FieldRef<"InterviewQuestion", 'String'>
    readonly interviewId: FieldRef<"InterviewQuestion", 'String'>
    readonly avatarId: FieldRef<"InterviewQuestion", 'String'>
    readonly question: FieldRef<"InterviewQuestion", 'String'>
    readonly type: FieldRef<"InterviewQuestion", 'QuestionType'>
    readonly order: FieldRef<"InterviewQuestion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * InterviewQuestion findUnique
   */
  export type InterviewQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewQuestion
     */
    select?: InterviewQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewQuestion
     */
    omit?: InterviewQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewQuestionInclude<ExtArgs> | null
    /**
     * Filter, which InterviewQuestion to fetch.
     */
    where: InterviewQuestionWhereUniqueInput
  }

  /**
   * InterviewQuestion findUniqueOrThrow
   */
  export type InterviewQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewQuestion
     */
    select?: InterviewQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewQuestion
     */
    omit?: InterviewQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewQuestionInclude<ExtArgs> | null
    /**
     * Filter, which InterviewQuestion to fetch.
     */
    where: InterviewQuestionWhereUniqueInput
  }

  /**
   * InterviewQuestion findFirst
   */
  export type InterviewQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewQuestion
     */
    select?: InterviewQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewQuestion
     */
    omit?: InterviewQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewQuestionInclude<ExtArgs> | null
    /**
     * Filter, which InterviewQuestion to fetch.
     */
    where?: InterviewQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewQuestions to fetch.
     */
    orderBy?: InterviewQuestionOrderByWithRelationInput | InterviewQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewQuestions.
     */
    cursor?: InterviewQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewQuestions.
     */
    distinct?: InterviewQuestionScalarFieldEnum | InterviewQuestionScalarFieldEnum[]
  }

  /**
   * InterviewQuestion findFirstOrThrow
   */
  export type InterviewQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewQuestion
     */
    select?: InterviewQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewQuestion
     */
    omit?: InterviewQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewQuestionInclude<ExtArgs> | null
    /**
     * Filter, which InterviewQuestion to fetch.
     */
    where?: InterviewQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewQuestions to fetch.
     */
    orderBy?: InterviewQuestionOrderByWithRelationInput | InterviewQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewQuestions.
     */
    cursor?: InterviewQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewQuestions.
     */
    distinct?: InterviewQuestionScalarFieldEnum | InterviewQuestionScalarFieldEnum[]
  }

  /**
   * InterviewQuestion findMany
   */
  export type InterviewQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewQuestion
     */
    select?: InterviewQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewQuestion
     */
    omit?: InterviewQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewQuestionInclude<ExtArgs> | null
    /**
     * Filter, which InterviewQuestions to fetch.
     */
    where?: InterviewQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewQuestions to fetch.
     */
    orderBy?: InterviewQuestionOrderByWithRelationInput | InterviewQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterviewQuestions.
     */
    cursor?: InterviewQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewQuestions.
     */
    skip?: number
    distinct?: InterviewQuestionScalarFieldEnum | InterviewQuestionScalarFieldEnum[]
  }

  /**
   * InterviewQuestion create
   */
  export type InterviewQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewQuestion
     */
    select?: InterviewQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewQuestion
     */
    omit?: InterviewQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a InterviewQuestion.
     */
    data: XOR<InterviewQuestionCreateInput, InterviewQuestionUncheckedCreateInput>
  }

  /**
   * InterviewQuestion createMany
   */
  export type InterviewQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InterviewQuestions.
     */
    data: InterviewQuestionCreateManyInput | InterviewQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterviewQuestion createManyAndReturn
   */
  export type InterviewQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewQuestion
     */
    select?: InterviewQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewQuestion
     */
    omit?: InterviewQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many InterviewQuestions.
     */
    data: InterviewQuestionCreateManyInput | InterviewQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterviewQuestion update
   */
  export type InterviewQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewQuestion
     */
    select?: InterviewQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewQuestion
     */
    omit?: InterviewQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a InterviewQuestion.
     */
    data: XOR<InterviewQuestionUpdateInput, InterviewQuestionUncheckedUpdateInput>
    /**
     * Choose, which InterviewQuestion to update.
     */
    where: InterviewQuestionWhereUniqueInput
  }

  /**
   * InterviewQuestion updateMany
   */
  export type InterviewQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InterviewQuestions.
     */
    data: XOR<InterviewQuestionUpdateManyMutationInput, InterviewQuestionUncheckedUpdateManyInput>
    /**
     * Filter which InterviewQuestions to update
     */
    where?: InterviewQuestionWhereInput
    /**
     * Limit how many InterviewQuestions to update.
     */
    limit?: number
  }

  /**
   * InterviewQuestion updateManyAndReturn
   */
  export type InterviewQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewQuestion
     */
    select?: InterviewQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewQuestion
     */
    omit?: InterviewQuestionOmit<ExtArgs> | null
    /**
     * The data used to update InterviewQuestions.
     */
    data: XOR<InterviewQuestionUpdateManyMutationInput, InterviewQuestionUncheckedUpdateManyInput>
    /**
     * Filter which InterviewQuestions to update
     */
    where?: InterviewQuestionWhereInput
    /**
     * Limit how many InterviewQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterviewQuestion upsert
   */
  export type InterviewQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewQuestion
     */
    select?: InterviewQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewQuestion
     */
    omit?: InterviewQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the InterviewQuestion to update in case it exists.
     */
    where: InterviewQuestionWhereUniqueInput
    /**
     * In case the InterviewQuestion found by the `where` argument doesn't exist, create a new InterviewQuestion with this data.
     */
    create: XOR<InterviewQuestionCreateInput, InterviewQuestionUncheckedCreateInput>
    /**
     * In case the InterviewQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterviewQuestionUpdateInput, InterviewQuestionUncheckedUpdateInput>
  }

  /**
   * InterviewQuestion delete
   */
  export type InterviewQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewQuestion
     */
    select?: InterviewQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewQuestion
     */
    omit?: InterviewQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewQuestionInclude<ExtArgs> | null
    /**
     * Filter which InterviewQuestion to delete.
     */
    where: InterviewQuestionWhereUniqueInput
  }

  /**
   * InterviewQuestion deleteMany
   */
  export type InterviewQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewQuestions to delete
     */
    where?: InterviewQuestionWhereInput
    /**
     * Limit how many InterviewQuestions to delete.
     */
    limit?: number
  }

  /**
   * InterviewQuestion.response
   */
  export type InterviewQuestion$responseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResponse
     */
    select?: InterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewResponse
     */
    omit?: InterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResponseInclude<ExtArgs> | null
    where?: InterviewResponseWhereInput
  }

  /**
   * InterviewQuestion without action
   */
  export type InterviewQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewQuestion
     */
    select?: InterviewQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewQuestion
     */
    omit?: InterviewQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewQuestionInclude<ExtArgs> | null
  }


  /**
   * Model InterviewResponse
   */

  export type AggregateInterviewResponse = {
    _count: InterviewResponseCountAggregateOutputType | null
    _avg: InterviewResponseAvgAggregateOutputType | null
    _sum: InterviewResponseSumAggregateOutputType | null
    _min: InterviewResponseMinAggregateOutputType | null
    _max: InterviewResponseMaxAggregateOutputType | null
  }

  export type InterviewResponseAvgAggregateOutputType = {
    duration: number | null
  }

  export type InterviewResponseSumAggregateOutputType = {
    duration: number | null
  }

  export type InterviewResponseMinAggregateOutputType = {
    id: string | null
    interviewId: string | null
    questionId: string | null
    transcript: string | null
    code: string | null
    videoUrl: string | null
    audioUrl: string | null
    duration: number | null
    respondedAt: Date | null
  }

  export type InterviewResponseMaxAggregateOutputType = {
    id: string | null
    interviewId: string | null
    questionId: string | null
    transcript: string | null
    code: string | null
    videoUrl: string | null
    audioUrl: string | null
    duration: number | null
    respondedAt: Date | null
  }

  export type InterviewResponseCountAggregateOutputType = {
    id: number
    interviewId: number
    questionId: number
    transcript: number
    code: number
    videoUrl: number
    audioUrl: number
    duration: number
    respondedAt: number
    _all: number
  }


  export type InterviewResponseAvgAggregateInputType = {
    duration?: true
  }

  export type InterviewResponseSumAggregateInputType = {
    duration?: true
  }

  export type InterviewResponseMinAggregateInputType = {
    id?: true
    interviewId?: true
    questionId?: true
    transcript?: true
    code?: true
    videoUrl?: true
    audioUrl?: true
    duration?: true
    respondedAt?: true
  }

  export type InterviewResponseMaxAggregateInputType = {
    id?: true
    interviewId?: true
    questionId?: true
    transcript?: true
    code?: true
    videoUrl?: true
    audioUrl?: true
    duration?: true
    respondedAt?: true
  }

  export type InterviewResponseCountAggregateInputType = {
    id?: true
    interviewId?: true
    questionId?: true
    transcript?: true
    code?: true
    videoUrl?: true
    audioUrl?: true
    duration?: true
    respondedAt?: true
    _all?: true
  }

  export type InterviewResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewResponse to aggregate.
     */
    where?: InterviewResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewResponses to fetch.
     */
    orderBy?: InterviewResponseOrderByWithRelationInput | InterviewResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterviewResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterviewResponses
    **/
    _count?: true | InterviewResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterviewResponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterviewResponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterviewResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterviewResponseMaxAggregateInputType
  }

  export type GetInterviewResponseAggregateType<T extends InterviewResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateInterviewResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterviewResponse[P]>
      : GetScalarType<T[P], AggregateInterviewResponse[P]>
  }




  export type InterviewResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewResponseWhereInput
    orderBy?: InterviewResponseOrderByWithAggregationInput | InterviewResponseOrderByWithAggregationInput[]
    by: InterviewResponseScalarFieldEnum[] | InterviewResponseScalarFieldEnum
    having?: InterviewResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterviewResponseCountAggregateInputType | true
    _avg?: InterviewResponseAvgAggregateInputType
    _sum?: InterviewResponseSumAggregateInputType
    _min?: InterviewResponseMinAggregateInputType
    _max?: InterviewResponseMaxAggregateInputType
  }

  export type InterviewResponseGroupByOutputType = {
    id: string
    interviewId: string
    questionId: string
    transcript: string | null
    code: string | null
    videoUrl: string | null
    audioUrl: string | null
    duration: number | null
    respondedAt: Date
    _count: InterviewResponseCountAggregateOutputType | null
    _avg: InterviewResponseAvgAggregateOutputType | null
    _sum: InterviewResponseSumAggregateOutputType | null
    _min: InterviewResponseMinAggregateOutputType | null
    _max: InterviewResponseMaxAggregateOutputType | null
  }

  type GetInterviewResponseGroupByPayload<T extends InterviewResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterviewResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterviewResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterviewResponseGroupByOutputType[P]>
            : GetScalarType<T[P], InterviewResponseGroupByOutputType[P]>
        }
      >
    >


  export type InterviewResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interviewId?: boolean
    questionId?: boolean
    transcript?: boolean
    code?: boolean
    videoUrl?: boolean
    audioUrl?: boolean
    duration?: boolean
    respondedAt?: boolean
    interview?: boolean | InterviewDefaultArgs<ExtArgs>
    question?: boolean | InterviewQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewResponse"]>

  export type InterviewResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interviewId?: boolean
    questionId?: boolean
    transcript?: boolean
    code?: boolean
    videoUrl?: boolean
    audioUrl?: boolean
    duration?: boolean
    respondedAt?: boolean
    interview?: boolean | InterviewDefaultArgs<ExtArgs>
    question?: boolean | InterviewQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewResponse"]>

  export type InterviewResponseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interviewId?: boolean
    questionId?: boolean
    transcript?: boolean
    code?: boolean
    videoUrl?: boolean
    audioUrl?: boolean
    duration?: boolean
    respondedAt?: boolean
    interview?: boolean | InterviewDefaultArgs<ExtArgs>
    question?: boolean | InterviewQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewResponse"]>

  export type InterviewResponseSelectScalar = {
    id?: boolean
    interviewId?: boolean
    questionId?: boolean
    transcript?: boolean
    code?: boolean
    videoUrl?: boolean
    audioUrl?: boolean
    duration?: boolean
    respondedAt?: boolean
  }

  export type InterviewResponseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "interviewId" | "questionId" | "transcript" | "code" | "videoUrl" | "audioUrl" | "duration" | "respondedAt", ExtArgs["result"]["interviewResponse"]>
  export type InterviewResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | InterviewDefaultArgs<ExtArgs>
    question?: boolean | InterviewQuestionDefaultArgs<ExtArgs>
  }
  export type InterviewResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | InterviewDefaultArgs<ExtArgs>
    question?: boolean | InterviewQuestionDefaultArgs<ExtArgs>
  }
  export type InterviewResponseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | InterviewDefaultArgs<ExtArgs>
    question?: boolean | InterviewQuestionDefaultArgs<ExtArgs>
  }

  export type $InterviewResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InterviewResponse"
    objects: {
      interview: Prisma.$InterviewPayload<ExtArgs>
      question: Prisma.$InterviewQuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      interviewId: string
      questionId: string
      transcript: string | null
      code: string | null
      videoUrl: string | null
      audioUrl: string | null
      duration: number | null
      respondedAt: Date
    }, ExtArgs["result"]["interviewResponse"]>
    composites: {}
  }

  type InterviewResponseGetPayload<S extends boolean | null | undefined | InterviewResponseDefaultArgs> = $Result.GetResult<Prisma.$InterviewResponsePayload, S>

  type InterviewResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterviewResponseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterviewResponseCountAggregateInputType | true
    }

  export interface InterviewResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InterviewResponse'], meta: { name: 'InterviewResponse' } }
    /**
     * Find zero or one InterviewResponse that matches the filter.
     * @param {InterviewResponseFindUniqueArgs} args - Arguments to find a InterviewResponse
     * @example
     * // Get one InterviewResponse
     * const interviewResponse = await prisma.interviewResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterviewResponseFindUniqueArgs>(args: SelectSubset<T, InterviewResponseFindUniqueArgs<ExtArgs>>): Prisma__InterviewResponseClient<$Result.GetResult<Prisma.$InterviewResponsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InterviewResponse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterviewResponseFindUniqueOrThrowArgs} args - Arguments to find a InterviewResponse
     * @example
     * // Get one InterviewResponse
     * const interviewResponse = await prisma.interviewResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterviewResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, InterviewResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterviewResponseClient<$Result.GetResult<Prisma.$InterviewResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterviewResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewResponseFindFirstArgs} args - Arguments to find a InterviewResponse
     * @example
     * // Get one InterviewResponse
     * const interviewResponse = await prisma.interviewResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterviewResponseFindFirstArgs>(args?: SelectSubset<T, InterviewResponseFindFirstArgs<ExtArgs>>): Prisma__InterviewResponseClient<$Result.GetResult<Prisma.$InterviewResponsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterviewResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewResponseFindFirstOrThrowArgs} args - Arguments to find a InterviewResponse
     * @example
     * // Get one InterviewResponse
     * const interviewResponse = await prisma.interviewResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterviewResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, InterviewResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterviewResponseClient<$Result.GetResult<Prisma.$InterviewResponsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InterviewResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterviewResponses
     * const interviewResponses = await prisma.interviewResponse.findMany()
     * 
     * // Get first 10 InterviewResponses
     * const interviewResponses = await prisma.interviewResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interviewResponseWithIdOnly = await prisma.interviewResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterviewResponseFindManyArgs>(args?: SelectSubset<T, InterviewResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InterviewResponse.
     * @param {InterviewResponseCreateArgs} args - Arguments to create a InterviewResponse.
     * @example
     * // Create one InterviewResponse
     * const InterviewResponse = await prisma.interviewResponse.create({
     *   data: {
     *     // ... data to create a InterviewResponse
     *   }
     * })
     * 
     */
    create<T extends InterviewResponseCreateArgs>(args: SelectSubset<T, InterviewResponseCreateArgs<ExtArgs>>): Prisma__InterviewResponseClient<$Result.GetResult<Prisma.$InterviewResponsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InterviewResponses.
     * @param {InterviewResponseCreateManyArgs} args - Arguments to create many InterviewResponses.
     * @example
     * // Create many InterviewResponses
     * const interviewResponse = await prisma.interviewResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterviewResponseCreateManyArgs>(args?: SelectSubset<T, InterviewResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InterviewResponses and returns the data saved in the database.
     * @param {InterviewResponseCreateManyAndReturnArgs} args - Arguments to create many InterviewResponses.
     * @example
     * // Create many InterviewResponses
     * const interviewResponse = await prisma.interviewResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InterviewResponses and only return the `id`
     * const interviewResponseWithIdOnly = await prisma.interviewResponse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterviewResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, InterviewResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewResponsePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InterviewResponse.
     * @param {InterviewResponseDeleteArgs} args - Arguments to delete one InterviewResponse.
     * @example
     * // Delete one InterviewResponse
     * const InterviewResponse = await prisma.interviewResponse.delete({
     *   where: {
     *     // ... filter to delete one InterviewResponse
     *   }
     * })
     * 
     */
    delete<T extends InterviewResponseDeleteArgs>(args: SelectSubset<T, InterviewResponseDeleteArgs<ExtArgs>>): Prisma__InterviewResponseClient<$Result.GetResult<Prisma.$InterviewResponsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InterviewResponse.
     * @param {InterviewResponseUpdateArgs} args - Arguments to update one InterviewResponse.
     * @example
     * // Update one InterviewResponse
     * const interviewResponse = await prisma.interviewResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterviewResponseUpdateArgs>(args: SelectSubset<T, InterviewResponseUpdateArgs<ExtArgs>>): Prisma__InterviewResponseClient<$Result.GetResult<Prisma.$InterviewResponsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InterviewResponses.
     * @param {InterviewResponseDeleteManyArgs} args - Arguments to filter InterviewResponses to delete.
     * @example
     * // Delete a few InterviewResponses
     * const { count } = await prisma.interviewResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterviewResponseDeleteManyArgs>(args?: SelectSubset<T, InterviewResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterviewResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterviewResponses
     * const interviewResponse = await prisma.interviewResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterviewResponseUpdateManyArgs>(args: SelectSubset<T, InterviewResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterviewResponses and returns the data updated in the database.
     * @param {InterviewResponseUpdateManyAndReturnArgs} args - Arguments to update many InterviewResponses.
     * @example
     * // Update many InterviewResponses
     * const interviewResponse = await prisma.interviewResponse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InterviewResponses and only return the `id`
     * const interviewResponseWithIdOnly = await prisma.interviewResponse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterviewResponseUpdateManyAndReturnArgs>(args: SelectSubset<T, InterviewResponseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewResponsePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InterviewResponse.
     * @param {InterviewResponseUpsertArgs} args - Arguments to update or create a InterviewResponse.
     * @example
     * // Update or create a InterviewResponse
     * const interviewResponse = await prisma.interviewResponse.upsert({
     *   create: {
     *     // ... data to create a InterviewResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterviewResponse we want to update
     *   }
     * })
     */
    upsert<T extends InterviewResponseUpsertArgs>(args: SelectSubset<T, InterviewResponseUpsertArgs<ExtArgs>>): Prisma__InterviewResponseClient<$Result.GetResult<Prisma.$InterviewResponsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InterviewResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewResponseCountArgs} args - Arguments to filter InterviewResponses to count.
     * @example
     * // Count the number of InterviewResponses
     * const count = await prisma.interviewResponse.count({
     *   where: {
     *     // ... the filter for the InterviewResponses we want to count
     *   }
     * })
    **/
    count<T extends InterviewResponseCountArgs>(
      args?: Subset<T, InterviewResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterviewResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterviewResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterviewResponseAggregateArgs>(args: Subset<T, InterviewResponseAggregateArgs>): Prisma.PrismaPromise<GetInterviewResponseAggregateType<T>>

    /**
     * Group by InterviewResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterviewResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterviewResponseGroupByArgs['orderBy'] }
        : { orderBy?: InterviewResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterviewResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterviewResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InterviewResponse model
   */
  readonly fields: InterviewResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InterviewResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterviewResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interview<T extends InterviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InterviewDefaultArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    question<T extends InterviewQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InterviewQuestionDefaultArgs<ExtArgs>>): Prisma__InterviewQuestionClient<$Result.GetResult<Prisma.$InterviewQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InterviewResponse model
   */
  interface InterviewResponseFieldRefs {
    readonly id: FieldRef<"InterviewResponse", 'String'>
    readonly interviewId: FieldRef<"InterviewResponse", 'String'>
    readonly questionId: FieldRef<"InterviewResponse", 'String'>
    readonly transcript: FieldRef<"InterviewResponse", 'String'>
    readonly code: FieldRef<"InterviewResponse", 'String'>
    readonly videoUrl: FieldRef<"InterviewResponse", 'String'>
    readonly audioUrl: FieldRef<"InterviewResponse", 'String'>
    readonly duration: FieldRef<"InterviewResponse", 'Int'>
    readonly respondedAt: FieldRef<"InterviewResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InterviewResponse findUnique
   */
  export type InterviewResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResponse
     */
    select?: InterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewResponse
     */
    omit?: InterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResponseInclude<ExtArgs> | null
    /**
     * Filter, which InterviewResponse to fetch.
     */
    where: InterviewResponseWhereUniqueInput
  }

  /**
   * InterviewResponse findUniqueOrThrow
   */
  export type InterviewResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResponse
     */
    select?: InterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewResponse
     */
    omit?: InterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResponseInclude<ExtArgs> | null
    /**
     * Filter, which InterviewResponse to fetch.
     */
    where: InterviewResponseWhereUniqueInput
  }

  /**
   * InterviewResponse findFirst
   */
  export type InterviewResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResponse
     */
    select?: InterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewResponse
     */
    omit?: InterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResponseInclude<ExtArgs> | null
    /**
     * Filter, which InterviewResponse to fetch.
     */
    where?: InterviewResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewResponses to fetch.
     */
    orderBy?: InterviewResponseOrderByWithRelationInput | InterviewResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewResponses.
     */
    cursor?: InterviewResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewResponses.
     */
    distinct?: InterviewResponseScalarFieldEnum | InterviewResponseScalarFieldEnum[]
  }

  /**
   * InterviewResponse findFirstOrThrow
   */
  export type InterviewResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResponse
     */
    select?: InterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewResponse
     */
    omit?: InterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResponseInclude<ExtArgs> | null
    /**
     * Filter, which InterviewResponse to fetch.
     */
    where?: InterviewResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewResponses to fetch.
     */
    orderBy?: InterviewResponseOrderByWithRelationInput | InterviewResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewResponses.
     */
    cursor?: InterviewResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewResponses.
     */
    distinct?: InterviewResponseScalarFieldEnum | InterviewResponseScalarFieldEnum[]
  }

  /**
   * InterviewResponse findMany
   */
  export type InterviewResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResponse
     */
    select?: InterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewResponse
     */
    omit?: InterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResponseInclude<ExtArgs> | null
    /**
     * Filter, which InterviewResponses to fetch.
     */
    where?: InterviewResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewResponses to fetch.
     */
    orderBy?: InterviewResponseOrderByWithRelationInput | InterviewResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterviewResponses.
     */
    cursor?: InterviewResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewResponses.
     */
    skip?: number
    distinct?: InterviewResponseScalarFieldEnum | InterviewResponseScalarFieldEnum[]
  }

  /**
   * InterviewResponse create
   */
  export type InterviewResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResponse
     */
    select?: InterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewResponse
     */
    omit?: InterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a InterviewResponse.
     */
    data: XOR<InterviewResponseCreateInput, InterviewResponseUncheckedCreateInput>
  }

  /**
   * InterviewResponse createMany
   */
  export type InterviewResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InterviewResponses.
     */
    data: InterviewResponseCreateManyInput | InterviewResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterviewResponse createManyAndReturn
   */
  export type InterviewResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResponse
     */
    select?: InterviewResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewResponse
     */
    omit?: InterviewResponseOmit<ExtArgs> | null
    /**
     * The data used to create many InterviewResponses.
     */
    data: InterviewResponseCreateManyInput | InterviewResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterviewResponse update
   */
  export type InterviewResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResponse
     */
    select?: InterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewResponse
     */
    omit?: InterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a InterviewResponse.
     */
    data: XOR<InterviewResponseUpdateInput, InterviewResponseUncheckedUpdateInput>
    /**
     * Choose, which InterviewResponse to update.
     */
    where: InterviewResponseWhereUniqueInput
  }

  /**
   * InterviewResponse updateMany
   */
  export type InterviewResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InterviewResponses.
     */
    data: XOR<InterviewResponseUpdateManyMutationInput, InterviewResponseUncheckedUpdateManyInput>
    /**
     * Filter which InterviewResponses to update
     */
    where?: InterviewResponseWhereInput
    /**
     * Limit how many InterviewResponses to update.
     */
    limit?: number
  }

  /**
   * InterviewResponse updateManyAndReturn
   */
  export type InterviewResponseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResponse
     */
    select?: InterviewResponseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewResponse
     */
    omit?: InterviewResponseOmit<ExtArgs> | null
    /**
     * The data used to update InterviewResponses.
     */
    data: XOR<InterviewResponseUpdateManyMutationInput, InterviewResponseUncheckedUpdateManyInput>
    /**
     * Filter which InterviewResponses to update
     */
    where?: InterviewResponseWhereInput
    /**
     * Limit how many InterviewResponses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResponseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterviewResponse upsert
   */
  export type InterviewResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResponse
     */
    select?: InterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewResponse
     */
    omit?: InterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the InterviewResponse to update in case it exists.
     */
    where: InterviewResponseWhereUniqueInput
    /**
     * In case the InterviewResponse found by the `where` argument doesn't exist, create a new InterviewResponse with this data.
     */
    create: XOR<InterviewResponseCreateInput, InterviewResponseUncheckedCreateInput>
    /**
     * In case the InterviewResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterviewResponseUpdateInput, InterviewResponseUncheckedUpdateInput>
  }

  /**
   * InterviewResponse delete
   */
  export type InterviewResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResponse
     */
    select?: InterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewResponse
     */
    omit?: InterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResponseInclude<ExtArgs> | null
    /**
     * Filter which InterviewResponse to delete.
     */
    where: InterviewResponseWhereUniqueInput
  }

  /**
   * InterviewResponse deleteMany
   */
  export type InterviewResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewResponses to delete
     */
    where?: InterviewResponseWhereInput
    /**
     * Limit how many InterviewResponses to delete.
     */
    limit?: number
  }

  /**
   * InterviewResponse without action
   */
  export type InterviewResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewResponse
     */
    select?: InterviewResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewResponse
     */
    omit?: InterviewResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewResponseInclude<ExtArgs> | null
  }


  /**
   * Model InterviewEvaluation
   */

  export type AggregateInterviewEvaluation = {
    _count: InterviewEvaluationCountAggregateOutputType | null
    _avg: InterviewEvaluationAvgAggregateOutputType | null
    _sum: InterviewEvaluationSumAggregateOutputType | null
    _min: InterviewEvaluationMinAggregateOutputType | null
    _max: InterviewEvaluationMaxAggregateOutputType | null
  }

  export type InterviewEvaluationAvgAggregateOutputType = {
    overallScore: number | null
    technicalScore: number | null
    communicationScore: number | null
    confidenceScore: number | null
    starMethodScore: number | null
  }

  export type InterviewEvaluationSumAggregateOutputType = {
    overallScore: number | null
    technicalScore: number | null
    communicationScore: number | null
    confidenceScore: number | null
    starMethodScore: number | null
  }

  export type InterviewEvaluationMinAggregateOutputType = {
    id: string | null
    interviewId: string | null
    overallScore: number | null
    technicalScore: number | null
    communicationScore: number | null
    confidenceScore: number | null
    starMethodScore: number | null
    aiInsights: string | null
    createdAt: Date | null
  }

  export type InterviewEvaluationMaxAggregateOutputType = {
    id: string | null
    interviewId: string | null
    overallScore: number | null
    technicalScore: number | null
    communicationScore: number | null
    confidenceScore: number | null
    starMethodScore: number | null
    aiInsights: string | null
    createdAt: Date | null
  }

  export type InterviewEvaluationCountAggregateOutputType = {
    id: number
    interviewId: number
    overallScore: number
    technicalScore: number
    communicationScore: number
    confidenceScore: number
    starMethodScore: number
    strengths: number
    weaknesses: number
    recommendations: number
    aiInsights: number
    createdAt: number
    _all: number
  }


  export type InterviewEvaluationAvgAggregateInputType = {
    overallScore?: true
    technicalScore?: true
    communicationScore?: true
    confidenceScore?: true
    starMethodScore?: true
  }

  export type InterviewEvaluationSumAggregateInputType = {
    overallScore?: true
    technicalScore?: true
    communicationScore?: true
    confidenceScore?: true
    starMethodScore?: true
  }

  export type InterviewEvaluationMinAggregateInputType = {
    id?: true
    interviewId?: true
    overallScore?: true
    technicalScore?: true
    communicationScore?: true
    confidenceScore?: true
    starMethodScore?: true
    aiInsights?: true
    createdAt?: true
  }

  export type InterviewEvaluationMaxAggregateInputType = {
    id?: true
    interviewId?: true
    overallScore?: true
    technicalScore?: true
    communicationScore?: true
    confidenceScore?: true
    starMethodScore?: true
    aiInsights?: true
    createdAt?: true
  }

  export type InterviewEvaluationCountAggregateInputType = {
    id?: true
    interviewId?: true
    overallScore?: true
    technicalScore?: true
    communicationScore?: true
    confidenceScore?: true
    starMethodScore?: true
    strengths?: true
    weaknesses?: true
    recommendations?: true
    aiInsights?: true
    createdAt?: true
    _all?: true
  }

  export type InterviewEvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewEvaluation to aggregate.
     */
    where?: InterviewEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewEvaluations to fetch.
     */
    orderBy?: InterviewEvaluationOrderByWithRelationInput | InterviewEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterviewEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterviewEvaluations
    **/
    _count?: true | InterviewEvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterviewEvaluationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterviewEvaluationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterviewEvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterviewEvaluationMaxAggregateInputType
  }

  export type GetInterviewEvaluationAggregateType<T extends InterviewEvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateInterviewEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterviewEvaluation[P]>
      : GetScalarType<T[P], AggregateInterviewEvaluation[P]>
  }




  export type InterviewEvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewEvaluationWhereInput
    orderBy?: InterviewEvaluationOrderByWithAggregationInput | InterviewEvaluationOrderByWithAggregationInput[]
    by: InterviewEvaluationScalarFieldEnum[] | InterviewEvaluationScalarFieldEnum
    having?: InterviewEvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterviewEvaluationCountAggregateInputType | true
    _avg?: InterviewEvaluationAvgAggregateInputType
    _sum?: InterviewEvaluationSumAggregateInputType
    _min?: InterviewEvaluationMinAggregateInputType
    _max?: InterviewEvaluationMaxAggregateInputType
  }

  export type InterviewEvaluationGroupByOutputType = {
    id: string
    interviewId: string
    overallScore: number
    technicalScore: number
    communicationScore: number
    confidenceScore: number
    starMethodScore: number
    strengths: JsonValue
    weaknesses: JsonValue
    recommendations: JsonValue
    aiInsights: string | null
    createdAt: Date
    _count: InterviewEvaluationCountAggregateOutputType | null
    _avg: InterviewEvaluationAvgAggregateOutputType | null
    _sum: InterviewEvaluationSumAggregateOutputType | null
    _min: InterviewEvaluationMinAggregateOutputType | null
    _max: InterviewEvaluationMaxAggregateOutputType | null
  }

  type GetInterviewEvaluationGroupByPayload<T extends InterviewEvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterviewEvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterviewEvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterviewEvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], InterviewEvaluationGroupByOutputType[P]>
        }
      >
    >


  export type InterviewEvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interviewId?: boolean
    overallScore?: boolean
    technicalScore?: boolean
    communicationScore?: boolean
    confidenceScore?: boolean
    starMethodScore?: boolean
    strengths?: boolean
    weaknesses?: boolean
    recommendations?: boolean
    aiInsights?: boolean
    createdAt?: boolean
    interview?: boolean | InterviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewEvaluation"]>

  export type InterviewEvaluationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interviewId?: boolean
    overallScore?: boolean
    technicalScore?: boolean
    communicationScore?: boolean
    confidenceScore?: boolean
    starMethodScore?: boolean
    strengths?: boolean
    weaknesses?: boolean
    recommendations?: boolean
    aiInsights?: boolean
    createdAt?: boolean
    interview?: boolean | InterviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewEvaluation"]>

  export type InterviewEvaluationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interviewId?: boolean
    overallScore?: boolean
    technicalScore?: boolean
    communicationScore?: boolean
    confidenceScore?: boolean
    starMethodScore?: boolean
    strengths?: boolean
    weaknesses?: boolean
    recommendations?: boolean
    aiInsights?: boolean
    createdAt?: boolean
    interview?: boolean | InterviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewEvaluation"]>

  export type InterviewEvaluationSelectScalar = {
    id?: boolean
    interviewId?: boolean
    overallScore?: boolean
    technicalScore?: boolean
    communicationScore?: boolean
    confidenceScore?: boolean
    starMethodScore?: boolean
    strengths?: boolean
    weaknesses?: boolean
    recommendations?: boolean
    aiInsights?: boolean
    createdAt?: boolean
  }

  export type InterviewEvaluationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "interviewId" | "overallScore" | "technicalScore" | "communicationScore" | "confidenceScore" | "starMethodScore" | "strengths" | "weaknesses" | "recommendations" | "aiInsights" | "createdAt", ExtArgs["result"]["interviewEvaluation"]>
  export type InterviewEvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | InterviewDefaultArgs<ExtArgs>
  }
  export type InterviewEvaluationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | InterviewDefaultArgs<ExtArgs>
  }
  export type InterviewEvaluationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interview?: boolean | InterviewDefaultArgs<ExtArgs>
  }

  export type $InterviewEvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InterviewEvaluation"
    objects: {
      interview: Prisma.$InterviewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      interviewId: string
      overallScore: number
      technicalScore: number
      communicationScore: number
      confidenceScore: number
      starMethodScore: number
      strengths: Prisma.JsonValue
      weaknesses: Prisma.JsonValue
      recommendations: Prisma.JsonValue
      aiInsights: string | null
      createdAt: Date
    }, ExtArgs["result"]["interviewEvaluation"]>
    composites: {}
  }

  type InterviewEvaluationGetPayload<S extends boolean | null | undefined | InterviewEvaluationDefaultArgs> = $Result.GetResult<Prisma.$InterviewEvaluationPayload, S>

  type InterviewEvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterviewEvaluationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterviewEvaluationCountAggregateInputType | true
    }

  export interface InterviewEvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InterviewEvaluation'], meta: { name: 'InterviewEvaluation' } }
    /**
     * Find zero or one InterviewEvaluation that matches the filter.
     * @param {InterviewEvaluationFindUniqueArgs} args - Arguments to find a InterviewEvaluation
     * @example
     * // Get one InterviewEvaluation
     * const interviewEvaluation = await prisma.interviewEvaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterviewEvaluationFindUniqueArgs>(args: SelectSubset<T, InterviewEvaluationFindUniqueArgs<ExtArgs>>): Prisma__InterviewEvaluationClient<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InterviewEvaluation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterviewEvaluationFindUniqueOrThrowArgs} args - Arguments to find a InterviewEvaluation
     * @example
     * // Get one InterviewEvaluation
     * const interviewEvaluation = await prisma.interviewEvaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterviewEvaluationFindUniqueOrThrowArgs>(args: SelectSubset<T, InterviewEvaluationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterviewEvaluationClient<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterviewEvaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewEvaluationFindFirstArgs} args - Arguments to find a InterviewEvaluation
     * @example
     * // Get one InterviewEvaluation
     * const interviewEvaluation = await prisma.interviewEvaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterviewEvaluationFindFirstArgs>(args?: SelectSubset<T, InterviewEvaluationFindFirstArgs<ExtArgs>>): Prisma__InterviewEvaluationClient<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterviewEvaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewEvaluationFindFirstOrThrowArgs} args - Arguments to find a InterviewEvaluation
     * @example
     * // Get one InterviewEvaluation
     * const interviewEvaluation = await prisma.interviewEvaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterviewEvaluationFindFirstOrThrowArgs>(args?: SelectSubset<T, InterviewEvaluationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterviewEvaluationClient<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InterviewEvaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewEvaluationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterviewEvaluations
     * const interviewEvaluations = await prisma.interviewEvaluation.findMany()
     * 
     * // Get first 10 InterviewEvaluations
     * const interviewEvaluations = await prisma.interviewEvaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interviewEvaluationWithIdOnly = await prisma.interviewEvaluation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterviewEvaluationFindManyArgs>(args?: SelectSubset<T, InterviewEvaluationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InterviewEvaluation.
     * @param {InterviewEvaluationCreateArgs} args - Arguments to create a InterviewEvaluation.
     * @example
     * // Create one InterviewEvaluation
     * const InterviewEvaluation = await prisma.interviewEvaluation.create({
     *   data: {
     *     // ... data to create a InterviewEvaluation
     *   }
     * })
     * 
     */
    create<T extends InterviewEvaluationCreateArgs>(args: SelectSubset<T, InterviewEvaluationCreateArgs<ExtArgs>>): Prisma__InterviewEvaluationClient<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InterviewEvaluations.
     * @param {InterviewEvaluationCreateManyArgs} args - Arguments to create many InterviewEvaluations.
     * @example
     * // Create many InterviewEvaluations
     * const interviewEvaluation = await prisma.interviewEvaluation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterviewEvaluationCreateManyArgs>(args?: SelectSubset<T, InterviewEvaluationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InterviewEvaluations and returns the data saved in the database.
     * @param {InterviewEvaluationCreateManyAndReturnArgs} args - Arguments to create many InterviewEvaluations.
     * @example
     * // Create many InterviewEvaluations
     * const interviewEvaluation = await prisma.interviewEvaluation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InterviewEvaluations and only return the `id`
     * const interviewEvaluationWithIdOnly = await prisma.interviewEvaluation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterviewEvaluationCreateManyAndReturnArgs>(args?: SelectSubset<T, InterviewEvaluationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InterviewEvaluation.
     * @param {InterviewEvaluationDeleteArgs} args - Arguments to delete one InterviewEvaluation.
     * @example
     * // Delete one InterviewEvaluation
     * const InterviewEvaluation = await prisma.interviewEvaluation.delete({
     *   where: {
     *     // ... filter to delete one InterviewEvaluation
     *   }
     * })
     * 
     */
    delete<T extends InterviewEvaluationDeleteArgs>(args: SelectSubset<T, InterviewEvaluationDeleteArgs<ExtArgs>>): Prisma__InterviewEvaluationClient<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InterviewEvaluation.
     * @param {InterviewEvaluationUpdateArgs} args - Arguments to update one InterviewEvaluation.
     * @example
     * // Update one InterviewEvaluation
     * const interviewEvaluation = await prisma.interviewEvaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterviewEvaluationUpdateArgs>(args: SelectSubset<T, InterviewEvaluationUpdateArgs<ExtArgs>>): Prisma__InterviewEvaluationClient<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InterviewEvaluations.
     * @param {InterviewEvaluationDeleteManyArgs} args - Arguments to filter InterviewEvaluations to delete.
     * @example
     * // Delete a few InterviewEvaluations
     * const { count } = await prisma.interviewEvaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterviewEvaluationDeleteManyArgs>(args?: SelectSubset<T, InterviewEvaluationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterviewEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewEvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterviewEvaluations
     * const interviewEvaluation = await prisma.interviewEvaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterviewEvaluationUpdateManyArgs>(args: SelectSubset<T, InterviewEvaluationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterviewEvaluations and returns the data updated in the database.
     * @param {InterviewEvaluationUpdateManyAndReturnArgs} args - Arguments to update many InterviewEvaluations.
     * @example
     * // Update many InterviewEvaluations
     * const interviewEvaluation = await prisma.interviewEvaluation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InterviewEvaluations and only return the `id`
     * const interviewEvaluationWithIdOnly = await prisma.interviewEvaluation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterviewEvaluationUpdateManyAndReturnArgs>(args: SelectSubset<T, InterviewEvaluationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InterviewEvaluation.
     * @param {InterviewEvaluationUpsertArgs} args - Arguments to update or create a InterviewEvaluation.
     * @example
     * // Update or create a InterviewEvaluation
     * const interviewEvaluation = await prisma.interviewEvaluation.upsert({
     *   create: {
     *     // ... data to create a InterviewEvaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterviewEvaluation we want to update
     *   }
     * })
     */
    upsert<T extends InterviewEvaluationUpsertArgs>(args: SelectSubset<T, InterviewEvaluationUpsertArgs<ExtArgs>>): Prisma__InterviewEvaluationClient<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InterviewEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewEvaluationCountArgs} args - Arguments to filter InterviewEvaluations to count.
     * @example
     * // Count the number of InterviewEvaluations
     * const count = await prisma.interviewEvaluation.count({
     *   where: {
     *     // ... the filter for the InterviewEvaluations we want to count
     *   }
     * })
    **/
    count<T extends InterviewEvaluationCountArgs>(
      args?: Subset<T, InterviewEvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterviewEvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterviewEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewEvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterviewEvaluationAggregateArgs>(args: Subset<T, InterviewEvaluationAggregateArgs>): Prisma.PrismaPromise<GetInterviewEvaluationAggregateType<T>>

    /**
     * Group by InterviewEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewEvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterviewEvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterviewEvaluationGroupByArgs['orderBy'] }
        : { orderBy?: InterviewEvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterviewEvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterviewEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InterviewEvaluation model
   */
  readonly fields: InterviewEvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InterviewEvaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterviewEvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interview<T extends InterviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InterviewDefaultArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InterviewEvaluation model
   */
  interface InterviewEvaluationFieldRefs {
    readonly id: FieldRef<"InterviewEvaluation", 'String'>
    readonly interviewId: FieldRef<"InterviewEvaluation", 'String'>
    readonly overallScore: FieldRef<"InterviewEvaluation", 'Int'>
    readonly technicalScore: FieldRef<"InterviewEvaluation", 'Int'>
    readonly communicationScore: FieldRef<"InterviewEvaluation", 'Int'>
    readonly confidenceScore: FieldRef<"InterviewEvaluation", 'Int'>
    readonly starMethodScore: FieldRef<"InterviewEvaluation", 'Int'>
    readonly strengths: FieldRef<"InterviewEvaluation", 'Json'>
    readonly weaknesses: FieldRef<"InterviewEvaluation", 'Json'>
    readonly recommendations: FieldRef<"InterviewEvaluation", 'Json'>
    readonly aiInsights: FieldRef<"InterviewEvaluation", 'String'>
    readonly createdAt: FieldRef<"InterviewEvaluation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InterviewEvaluation findUnique
   */
  export type InterviewEvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which InterviewEvaluation to fetch.
     */
    where: InterviewEvaluationWhereUniqueInput
  }

  /**
   * InterviewEvaluation findUniqueOrThrow
   */
  export type InterviewEvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which InterviewEvaluation to fetch.
     */
    where: InterviewEvaluationWhereUniqueInput
  }

  /**
   * InterviewEvaluation findFirst
   */
  export type InterviewEvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which InterviewEvaluation to fetch.
     */
    where?: InterviewEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewEvaluations to fetch.
     */
    orderBy?: InterviewEvaluationOrderByWithRelationInput | InterviewEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewEvaluations.
     */
    cursor?: InterviewEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewEvaluations.
     */
    distinct?: InterviewEvaluationScalarFieldEnum | InterviewEvaluationScalarFieldEnum[]
  }

  /**
   * InterviewEvaluation findFirstOrThrow
   */
  export type InterviewEvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which InterviewEvaluation to fetch.
     */
    where?: InterviewEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewEvaluations to fetch.
     */
    orderBy?: InterviewEvaluationOrderByWithRelationInput | InterviewEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewEvaluations.
     */
    cursor?: InterviewEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewEvaluations.
     */
    distinct?: InterviewEvaluationScalarFieldEnum | InterviewEvaluationScalarFieldEnum[]
  }

  /**
   * InterviewEvaluation findMany
   */
  export type InterviewEvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which InterviewEvaluations to fetch.
     */
    where?: InterviewEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewEvaluations to fetch.
     */
    orderBy?: InterviewEvaluationOrderByWithRelationInput | InterviewEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterviewEvaluations.
     */
    cursor?: InterviewEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewEvaluations.
     */
    skip?: number
    distinct?: InterviewEvaluationScalarFieldEnum | InterviewEvaluationScalarFieldEnum[]
  }

  /**
   * InterviewEvaluation create
   */
  export type InterviewEvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a InterviewEvaluation.
     */
    data: XOR<InterviewEvaluationCreateInput, InterviewEvaluationUncheckedCreateInput>
  }

  /**
   * InterviewEvaluation createMany
   */
  export type InterviewEvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InterviewEvaluations.
     */
    data: InterviewEvaluationCreateManyInput | InterviewEvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterviewEvaluation createManyAndReturn
   */
  export type InterviewEvaluationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * The data used to create many InterviewEvaluations.
     */
    data: InterviewEvaluationCreateManyInput | InterviewEvaluationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterviewEvaluation update
   */
  export type InterviewEvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a InterviewEvaluation.
     */
    data: XOR<InterviewEvaluationUpdateInput, InterviewEvaluationUncheckedUpdateInput>
    /**
     * Choose, which InterviewEvaluation to update.
     */
    where: InterviewEvaluationWhereUniqueInput
  }

  /**
   * InterviewEvaluation updateMany
   */
  export type InterviewEvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InterviewEvaluations.
     */
    data: XOR<InterviewEvaluationUpdateManyMutationInput, InterviewEvaluationUncheckedUpdateManyInput>
    /**
     * Filter which InterviewEvaluations to update
     */
    where?: InterviewEvaluationWhereInput
    /**
     * Limit how many InterviewEvaluations to update.
     */
    limit?: number
  }

  /**
   * InterviewEvaluation updateManyAndReturn
   */
  export type InterviewEvaluationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * The data used to update InterviewEvaluations.
     */
    data: XOR<InterviewEvaluationUpdateManyMutationInput, InterviewEvaluationUncheckedUpdateManyInput>
    /**
     * Filter which InterviewEvaluations to update
     */
    where?: InterviewEvaluationWhereInput
    /**
     * Limit how many InterviewEvaluations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterviewEvaluation upsert
   */
  export type InterviewEvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the InterviewEvaluation to update in case it exists.
     */
    where: InterviewEvaluationWhereUniqueInput
    /**
     * In case the InterviewEvaluation found by the `where` argument doesn't exist, create a new InterviewEvaluation with this data.
     */
    create: XOR<InterviewEvaluationCreateInput, InterviewEvaluationUncheckedCreateInput>
    /**
     * In case the InterviewEvaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterviewEvaluationUpdateInput, InterviewEvaluationUncheckedUpdateInput>
  }

  /**
   * InterviewEvaluation delete
   */
  export type InterviewEvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
    /**
     * Filter which InterviewEvaluation to delete.
     */
    where: InterviewEvaluationWhereUniqueInput
  }

  /**
   * InterviewEvaluation deleteMany
   */
  export type InterviewEvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewEvaluations to delete
     */
    where?: InterviewEvaluationWhereInput
    /**
     * Limit how many InterviewEvaluations to delete.
     */
    limit?: number
  }

  /**
   * InterviewEvaluation without action
   */
  export type InterviewEvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
  }


  /**
   * Model Avatar
   */

  export type AggregateAvatar = {
    _count: AvatarCountAggregateOutputType | null
    _min: AvatarMinAggregateOutputType | null
    _max: AvatarMaxAggregateOutputType | null
  }

  export type AvatarMinAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    personality: string | null
    avatarUrl: string | null
    voiceId: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type AvatarMaxAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    personality: string | null
    avatarUrl: string | null
    voiceId: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type AvatarCountAggregateOutputType = {
    id: number
    name: number
    role: number
    personality: number
    avatarUrl: number
    voiceId: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type AvatarMinAggregateInputType = {
    id?: true
    name?: true
    role?: true
    personality?: true
    avatarUrl?: true
    voiceId?: true
    isActive?: true
    createdAt?: true
  }

  export type AvatarMaxAggregateInputType = {
    id?: true
    name?: true
    role?: true
    personality?: true
    avatarUrl?: true
    voiceId?: true
    isActive?: true
    createdAt?: true
  }

  export type AvatarCountAggregateInputType = {
    id?: true
    name?: true
    role?: true
    personality?: true
    avatarUrl?: true
    voiceId?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type AvatarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Avatar to aggregate.
     */
    where?: AvatarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avatars to fetch.
     */
    orderBy?: AvatarOrderByWithRelationInput | AvatarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvatarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avatars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avatars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Avatars
    **/
    _count?: true | AvatarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvatarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvatarMaxAggregateInputType
  }

  export type GetAvatarAggregateType<T extends AvatarAggregateArgs> = {
        [P in keyof T & keyof AggregateAvatar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvatar[P]>
      : GetScalarType<T[P], AggregateAvatar[P]>
  }




  export type AvatarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvatarWhereInput
    orderBy?: AvatarOrderByWithAggregationInput | AvatarOrderByWithAggregationInput[]
    by: AvatarScalarFieldEnum[] | AvatarScalarFieldEnum
    having?: AvatarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvatarCountAggregateInputType | true
    _min?: AvatarMinAggregateInputType
    _max?: AvatarMaxAggregateInputType
  }

  export type AvatarGroupByOutputType = {
    id: string
    name: string
    role: string
    personality: string
    avatarUrl: string
    voiceId: string | null
    isActive: boolean
    createdAt: Date
    _count: AvatarCountAggregateOutputType | null
    _min: AvatarMinAggregateOutputType | null
    _max: AvatarMaxAggregateOutputType | null
  }

  type GetAvatarGroupByPayload<T extends AvatarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvatarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvatarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvatarGroupByOutputType[P]>
            : GetScalarType<T[P], AvatarGroupByOutputType[P]>
        }
      >
    >


  export type AvatarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    personality?: boolean
    avatarUrl?: boolean
    voiceId?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["avatar"]>

  export type AvatarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    personality?: boolean
    avatarUrl?: boolean
    voiceId?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["avatar"]>

  export type AvatarSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    personality?: boolean
    avatarUrl?: boolean
    voiceId?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["avatar"]>

  export type AvatarSelectScalar = {
    id?: boolean
    name?: boolean
    role?: boolean
    personality?: boolean
    avatarUrl?: boolean
    voiceId?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type AvatarOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "role" | "personality" | "avatarUrl" | "voiceId" | "isActive" | "createdAt", ExtArgs["result"]["avatar"]>

  export type $AvatarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Avatar"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      role: string
      personality: string
      avatarUrl: string
      voiceId: string | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["avatar"]>
    composites: {}
  }

  type AvatarGetPayload<S extends boolean | null | undefined | AvatarDefaultArgs> = $Result.GetResult<Prisma.$AvatarPayload, S>

  type AvatarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AvatarFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AvatarCountAggregateInputType | true
    }

  export interface AvatarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Avatar'], meta: { name: 'Avatar' } }
    /**
     * Find zero or one Avatar that matches the filter.
     * @param {AvatarFindUniqueArgs} args - Arguments to find a Avatar
     * @example
     * // Get one Avatar
     * const avatar = await prisma.avatar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvatarFindUniqueArgs>(args: SelectSubset<T, AvatarFindUniqueArgs<ExtArgs>>): Prisma__AvatarClient<$Result.GetResult<Prisma.$AvatarPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Avatar that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AvatarFindUniqueOrThrowArgs} args - Arguments to find a Avatar
     * @example
     * // Get one Avatar
     * const avatar = await prisma.avatar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvatarFindUniqueOrThrowArgs>(args: SelectSubset<T, AvatarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvatarClient<$Result.GetResult<Prisma.$AvatarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Avatar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarFindFirstArgs} args - Arguments to find a Avatar
     * @example
     * // Get one Avatar
     * const avatar = await prisma.avatar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvatarFindFirstArgs>(args?: SelectSubset<T, AvatarFindFirstArgs<ExtArgs>>): Prisma__AvatarClient<$Result.GetResult<Prisma.$AvatarPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Avatar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarFindFirstOrThrowArgs} args - Arguments to find a Avatar
     * @example
     * // Get one Avatar
     * const avatar = await prisma.avatar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvatarFindFirstOrThrowArgs>(args?: SelectSubset<T, AvatarFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvatarClient<$Result.GetResult<Prisma.$AvatarPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Avatars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Avatars
     * const avatars = await prisma.avatar.findMany()
     * 
     * // Get first 10 Avatars
     * const avatars = await prisma.avatar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const avatarWithIdOnly = await prisma.avatar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AvatarFindManyArgs>(args?: SelectSubset<T, AvatarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvatarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Avatar.
     * @param {AvatarCreateArgs} args - Arguments to create a Avatar.
     * @example
     * // Create one Avatar
     * const Avatar = await prisma.avatar.create({
     *   data: {
     *     // ... data to create a Avatar
     *   }
     * })
     * 
     */
    create<T extends AvatarCreateArgs>(args: SelectSubset<T, AvatarCreateArgs<ExtArgs>>): Prisma__AvatarClient<$Result.GetResult<Prisma.$AvatarPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Avatars.
     * @param {AvatarCreateManyArgs} args - Arguments to create many Avatars.
     * @example
     * // Create many Avatars
     * const avatar = await prisma.avatar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvatarCreateManyArgs>(args?: SelectSubset<T, AvatarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Avatars and returns the data saved in the database.
     * @param {AvatarCreateManyAndReturnArgs} args - Arguments to create many Avatars.
     * @example
     * // Create many Avatars
     * const avatar = await prisma.avatar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Avatars and only return the `id`
     * const avatarWithIdOnly = await prisma.avatar.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AvatarCreateManyAndReturnArgs>(args?: SelectSubset<T, AvatarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvatarPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Avatar.
     * @param {AvatarDeleteArgs} args - Arguments to delete one Avatar.
     * @example
     * // Delete one Avatar
     * const Avatar = await prisma.avatar.delete({
     *   where: {
     *     // ... filter to delete one Avatar
     *   }
     * })
     * 
     */
    delete<T extends AvatarDeleteArgs>(args: SelectSubset<T, AvatarDeleteArgs<ExtArgs>>): Prisma__AvatarClient<$Result.GetResult<Prisma.$AvatarPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Avatar.
     * @param {AvatarUpdateArgs} args - Arguments to update one Avatar.
     * @example
     * // Update one Avatar
     * const avatar = await prisma.avatar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvatarUpdateArgs>(args: SelectSubset<T, AvatarUpdateArgs<ExtArgs>>): Prisma__AvatarClient<$Result.GetResult<Prisma.$AvatarPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Avatars.
     * @param {AvatarDeleteManyArgs} args - Arguments to filter Avatars to delete.
     * @example
     * // Delete a few Avatars
     * const { count } = await prisma.avatar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvatarDeleteManyArgs>(args?: SelectSubset<T, AvatarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Avatars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Avatars
     * const avatar = await prisma.avatar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvatarUpdateManyArgs>(args: SelectSubset<T, AvatarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Avatars and returns the data updated in the database.
     * @param {AvatarUpdateManyAndReturnArgs} args - Arguments to update many Avatars.
     * @example
     * // Update many Avatars
     * const avatar = await prisma.avatar.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Avatars and only return the `id`
     * const avatarWithIdOnly = await prisma.avatar.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AvatarUpdateManyAndReturnArgs>(args: SelectSubset<T, AvatarUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvatarPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Avatar.
     * @param {AvatarUpsertArgs} args - Arguments to update or create a Avatar.
     * @example
     * // Update or create a Avatar
     * const avatar = await prisma.avatar.upsert({
     *   create: {
     *     // ... data to create a Avatar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Avatar we want to update
     *   }
     * })
     */
    upsert<T extends AvatarUpsertArgs>(args: SelectSubset<T, AvatarUpsertArgs<ExtArgs>>): Prisma__AvatarClient<$Result.GetResult<Prisma.$AvatarPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Avatars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarCountArgs} args - Arguments to filter Avatars to count.
     * @example
     * // Count the number of Avatars
     * const count = await prisma.avatar.count({
     *   where: {
     *     // ... the filter for the Avatars we want to count
     *   }
     * })
    **/
    count<T extends AvatarCountArgs>(
      args?: Subset<T, AvatarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvatarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Avatar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvatarAggregateArgs>(args: Subset<T, AvatarAggregateArgs>): Prisma.PrismaPromise<GetAvatarAggregateType<T>>

    /**
     * Group by Avatar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvatarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvatarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvatarGroupByArgs['orderBy'] }
        : { orderBy?: AvatarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvatarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvatarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Avatar model
   */
  readonly fields: AvatarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Avatar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvatarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Avatar model
   */
  interface AvatarFieldRefs {
    readonly id: FieldRef<"Avatar", 'String'>
    readonly name: FieldRef<"Avatar", 'String'>
    readonly role: FieldRef<"Avatar", 'String'>
    readonly personality: FieldRef<"Avatar", 'String'>
    readonly avatarUrl: FieldRef<"Avatar", 'String'>
    readonly voiceId: FieldRef<"Avatar", 'String'>
    readonly isActive: FieldRef<"Avatar", 'Boolean'>
    readonly createdAt: FieldRef<"Avatar", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Avatar findUnique
   */
  export type AvatarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avatar
     */
    select?: AvatarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avatar
     */
    omit?: AvatarOmit<ExtArgs> | null
    /**
     * Filter, which Avatar to fetch.
     */
    where: AvatarWhereUniqueInput
  }

  /**
   * Avatar findUniqueOrThrow
   */
  export type AvatarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avatar
     */
    select?: AvatarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avatar
     */
    omit?: AvatarOmit<ExtArgs> | null
    /**
     * Filter, which Avatar to fetch.
     */
    where: AvatarWhereUniqueInput
  }

  /**
   * Avatar findFirst
   */
  export type AvatarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avatar
     */
    select?: AvatarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avatar
     */
    omit?: AvatarOmit<ExtArgs> | null
    /**
     * Filter, which Avatar to fetch.
     */
    where?: AvatarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avatars to fetch.
     */
    orderBy?: AvatarOrderByWithRelationInput | AvatarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Avatars.
     */
    cursor?: AvatarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avatars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avatars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Avatars.
     */
    distinct?: AvatarScalarFieldEnum | AvatarScalarFieldEnum[]
  }

  /**
   * Avatar findFirstOrThrow
   */
  export type AvatarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avatar
     */
    select?: AvatarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avatar
     */
    omit?: AvatarOmit<ExtArgs> | null
    /**
     * Filter, which Avatar to fetch.
     */
    where?: AvatarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avatars to fetch.
     */
    orderBy?: AvatarOrderByWithRelationInput | AvatarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Avatars.
     */
    cursor?: AvatarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avatars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avatars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Avatars.
     */
    distinct?: AvatarScalarFieldEnum | AvatarScalarFieldEnum[]
  }

  /**
   * Avatar findMany
   */
  export type AvatarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avatar
     */
    select?: AvatarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avatar
     */
    omit?: AvatarOmit<ExtArgs> | null
    /**
     * Filter, which Avatars to fetch.
     */
    where?: AvatarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avatars to fetch.
     */
    orderBy?: AvatarOrderByWithRelationInput | AvatarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Avatars.
     */
    cursor?: AvatarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avatars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avatars.
     */
    skip?: number
    distinct?: AvatarScalarFieldEnum | AvatarScalarFieldEnum[]
  }

  /**
   * Avatar create
   */
  export type AvatarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avatar
     */
    select?: AvatarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avatar
     */
    omit?: AvatarOmit<ExtArgs> | null
    /**
     * The data needed to create a Avatar.
     */
    data: XOR<AvatarCreateInput, AvatarUncheckedCreateInput>
  }

  /**
   * Avatar createMany
   */
  export type AvatarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Avatars.
     */
    data: AvatarCreateManyInput | AvatarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Avatar createManyAndReturn
   */
  export type AvatarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avatar
     */
    select?: AvatarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Avatar
     */
    omit?: AvatarOmit<ExtArgs> | null
    /**
     * The data used to create many Avatars.
     */
    data: AvatarCreateManyInput | AvatarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Avatar update
   */
  export type AvatarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avatar
     */
    select?: AvatarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avatar
     */
    omit?: AvatarOmit<ExtArgs> | null
    /**
     * The data needed to update a Avatar.
     */
    data: XOR<AvatarUpdateInput, AvatarUncheckedUpdateInput>
    /**
     * Choose, which Avatar to update.
     */
    where: AvatarWhereUniqueInput
  }

  /**
   * Avatar updateMany
   */
  export type AvatarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Avatars.
     */
    data: XOR<AvatarUpdateManyMutationInput, AvatarUncheckedUpdateManyInput>
    /**
     * Filter which Avatars to update
     */
    where?: AvatarWhereInput
    /**
     * Limit how many Avatars to update.
     */
    limit?: number
  }

  /**
   * Avatar updateManyAndReturn
   */
  export type AvatarUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avatar
     */
    select?: AvatarSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Avatar
     */
    omit?: AvatarOmit<ExtArgs> | null
    /**
     * The data used to update Avatars.
     */
    data: XOR<AvatarUpdateManyMutationInput, AvatarUncheckedUpdateManyInput>
    /**
     * Filter which Avatars to update
     */
    where?: AvatarWhereInput
    /**
     * Limit how many Avatars to update.
     */
    limit?: number
  }

  /**
   * Avatar upsert
   */
  export type AvatarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avatar
     */
    select?: AvatarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avatar
     */
    omit?: AvatarOmit<ExtArgs> | null
    /**
     * The filter to search for the Avatar to update in case it exists.
     */
    where: AvatarWhereUniqueInput
    /**
     * In case the Avatar found by the `where` argument doesn't exist, create a new Avatar with this data.
     */
    create: XOR<AvatarCreateInput, AvatarUncheckedCreateInput>
    /**
     * In case the Avatar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvatarUpdateInput, AvatarUncheckedUpdateInput>
  }

  /**
   * Avatar delete
   */
  export type AvatarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avatar
     */
    select?: AvatarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avatar
     */
    omit?: AvatarOmit<ExtArgs> | null
    /**
     * Filter which Avatar to delete.
     */
    where: AvatarWhereUniqueInput
  }

  /**
   * Avatar deleteMany
   */
  export type AvatarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Avatars to delete
     */
    where?: AvatarWhereInput
    /**
     * Limit how many Avatars to delete.
     */
    limit?: number
  }

  /**
   * Avatar without action
   */
  export type AvatarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avatar
     */
    select?: AvatarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avatar
     */
    omit?: AvatarOmit<ExtArgs> | null
  }


  /**
   * Model KnowledgeBase
   */

  export type AggregateKnowledgeBase = {
    _count: KnowledgeBaseCountAggregateOutputType | null
    _min: KnowledgeBaseMinAggregateOutputType | null
    _max: KnowledgeBaseMaxAggregateOutputType | null
  }

  export type KnowledgeBaseMinAggregateOutputType = {
    id: string | null
    domain: string | null
    topic: string | null
    content: string | null
    answer: string | null
    difficulty: $Enums.Difficulty | null
    type: $Enums.QuestionType | null
    codeSnippet: string | null
    status: $Enums.KnowledgeStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeBaseMaxAggregateOutputType = {
    id: string | null
    domain: string | null
    topic: string | null
    content: string | null
    answer: string | null
    difficulty: $Enums.Difficulty | null
    type: $Enums.QuestionType | null
    codeSnippet: string | null
    status: $Enums.KnowledgeStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeBaseCountAggregateOutputType = {
    id: number
    domain: number
    topic: number
    content: number
    answer: number
    difficulty: number
    type: number
    codeSnippet: number
    tags: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KnowledgeBaseMinAggregateInputType = {
    id?: true
    domain?: true
    topic?: true
    content?: true
    answer?: true
    difficulty?: true
    type?: true
    codeSnippet?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeBaseMaxAggregateInputType = {
    id?: true
    domain?: true
    topic?: true
    content?: true
    answer?: true
    difficulty?: true
    type?: true
    codeSnippet?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeBaseCountAggregateInputType = {
    id?: true
    domain?: true
    topic?: true
    content?: true
    answer?: true
    difficulty?: true
    type?: true
    codeSnippet?: true
    tags?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KnowledgeBaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeBase to aggregate.
     */
    where?: KnowledgeBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBases to fetch.
     */
    orderBy?: KnowledgeBaseOrderByWithRelationInput | KnowledgeBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeBases
    **/
    _count?: true | KnowledgeBaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeBaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeBaseMaxAggregateInputType
  }

  export type GetKnowledgeBaseAggregateType<T extends KnowledgeBaseAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeBase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeBase[P]>
      : GetScalarType<T[P], AggregateKnowledgeBase[P]>
  }




  export type KnowledgeBaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeBaseWhereInput
    orderBy?: KnowledgeBaseOrderByWithAggregationInput | KnowledgeBaseOrderByWithAggregationInput[]
    by: KnowledgeBaseScalarFieldEnum[] | KnowledgeBaseScalarFieldEnum
    having?: KnowledgeBaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeBaseCountAggregateInputType | true
    _min?: KnowledgeBaseMinAggregateInputType
    _max?: KnowledgeBaseMaxAggregateInputType
  }

  export type KnowledgeBaseGroupByOutputType = {
    id: string
    domain: string
    topic: string
    content: string
    answer: string | null
    difficulty: $Enums.Difficulty
    type: $Enums.QuestionType
    codeSnippet: string | null
    tags: JsonValue | null
    status: $Enums.KnowledgeStatus
    createdAt: Date
    updatedAt: Date
    _count: KnowledgeBaseCountAggregateOutputType | null
    _min: KnowledgeBaseMinAggregateOutputType | null
    _max: KnowledgeBaseMaxAggregateOutputType | null
  }

  type GetKnowledgeBaseGroupByPayload<T extends KnowledgeBaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeBaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeBaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeBaseGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeBaseGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeBaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domain?: boolean
    topic?: boolean
    content?: boolean
    answer?: boolean
    difficulty?: boolean
    type?: boolean
    codeSnippet?: boolean
    tags?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["knowledgeBase"]>

  export type KnowledgeBaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domain?: boolean
    topic?: boolean
    content?: boolean
    answer?: boolean
    difficulty?: boolean
    type?: boolean
    codeSnippet?: boolean
    tags?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["knowledgeBase"]>

  export type KnowledgeBaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domain?: boolean
    topic?: boolean
    content?: boolean
    answer?: boolean
    difficulty?: boolean
    type?: boolean
    codeSnippet?: boolean
    tags?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["knowledgeBase"]>

  export type KnowledgeBaseSelectScalar = {
    id?: boolean
    domain?: boolean
    topic?: boolean
    content?: boolean
    answer?: boolean
    difficulty?: boolean
    type?: boolean
    codeSnippet?: boolean
    tags?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KnowledgeBaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domain" | "topic" | "content" | "answer" | "difficulty" | "type" | "codeSnippet" | "tags" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["knowledgeBase"]>

  export type $KnowledgeBasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeBase"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      domain: string
      topic: string
      content: string
      answer: string | null
      difficulty: $Enums.Difficulty
      type: $Enums.QuestionType
      codeSnippet: string | null
      tags: Prisma.JsonValue | null
      status: $Enums.KnowledgeStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["knowledgeBase"]>
    composites: {}
  }

  type KnowledgeBaseGetPayload<S extends boolean | null | undefined | KnowledgeBaseDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeBasePayload, S>

  type KnowledgeBaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KnowledgeBaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KnowledgeBaseCountAggregateInputType | true
    }

  export interface KnowledgeBaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeBase'], meta: { name: 'KnowledgeBase' } }
    /**
     * Find zero or one KnowledgeBase that matches the filter.
     * @param {KnowledgeBaseFindUniqueArgs} args - Arguments to find a KnowledgeBase
     * @example
     * // Get one KnowledgeBase
     * const knowledgeBase = await prisma.knowledgeBase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeBaseFindUniqueArgs>(args: SelectSubset<T, KnowledgeBaseFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KnowledgeBase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KnowledgeBaseFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeBase
     * @example
     * // Get one KnowledgeBase
     * const knowledgeBase = await prisma.knowledgeBase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeBaseFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeBaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeBase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseFindFirstArgs} args - Arguments to find a KnowledgeBase
     * @example
     * // Get one KnowledgeBase
     * const knowledgeBase = await prisma.knowledgeBase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeBaseFindFirstArgs>(args?: SelectSubset<T, KnowledgeBaseFindFirstArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeBase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseFindFirstOrThrowArgs} args - Arguments to find a KnowledgeBase
     * @example
     * // Get one KnowledgeBase
     * const knowledgeBase = await prisma.knowledgeBase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeBaseFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeBaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KnowledgeBases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeBases
     * const knowledgeBases = await prisma.knowledgeBase.findMany()
     * 
     * // Get first 10 KnowledgeBases
     * const knowledgeBases = await prisma.knowledgeBase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeBaseWithIdOnly = await prisma.knowledgeBase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeBaseFindManyArgs>(args?: SelectSubset<T, KnowledgeBaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KnowledgeBase.
     * @param {KnowledgeBaseCreateArgs} args - Arguments to create a KnowledgeBase.
     * @example
     * // Create one KnowledgeBase
     * const KnowledgeBase = await prisma.knowledgeBase.create({
     *   data: {
     *     // ... data to create a KnowledgeBase
     *   }
     * })
     * 
     */
    create<T extends KnowledgeBaseCreateArgs>(args: SelectSubset<T, KnowledgeBaseCreateArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KnowledgeBases.
     * @param {KnowledgeBaseCreateManyArgs} args - Arguments to create many KnowledgeBases.
     * @example
     * // Create many KnowledgeBases
     * const knowledgeBase = await prisma.knowledgeBase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeBaseCreateManyArgs>(args?: SelectSubset<T, KnowledgeBaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KnowledgeBases and returns the data saved in the database.
     * @param {KnowledgeBaseCreateManyAndReturnArgs} args - Arguments to create many KnowledgeBases.
     * @example
     * // Create many KnowledgeBases
     * const knowledgeBase = await prisma.knowledgeBase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KnowledgeBases and only return the `id`
     * const knowledgeBaseWithIdOnly = await prisma.knowledgeBase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KnowledgeBaseCreateManyAndReturnArgs>(args?: SelectSubset<T, KnowledgeBaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KnowledgeBase.
     * @param {KnowledgeBaseDeleteArgs} args - Arguments to delete one KnowledgeBase.
     * @example
     * // Delete one KnowledgeBase
     * const KnowledgeBase = await prisma.knowledgeBase.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeBase
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeBaseDeleteArgs>(args: SelectSubset<T, KnowledgeBaseDeleteArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KnowledgeBase.
     * @param {KnowledgeBaseUpdateArgs} args - Arguments to update one KnowledgeBase.
     * @example
     * // Update one KnowledgeBase
     * const knowledgeBase = await prisma.knowledgeBase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeBaseUpdateArgs>(args: SelectSubset<T, KnowledgeBaseUpdateArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KnowledgeBases.
     * @param {KnowledgeBaseDeleteManyArgs} args - Arguments to filter KnowledgeBases to delete.
     * @example
     * // Delete a few KnowledgeBases
     * const { count } = await prisma.knowledgeBase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeBaseDeleteManyArgs>(args?: SelectSubset<T, KnowledgeBaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeBases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeBases
     * const knowledgeBase = await prisma.knowledgeBase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeBaseUpdateManyArgs>(args: SelectSubset<T, KnowledgeBaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeBases and returns the data updated in the database.
     * @param {KnowledgeBaseUpdateManyAndReturnArgs} args - Arguments to update many KnowledgeBases.
     * @example
     * // Update many KnowledgeBases
     * const knowledgeBase = await prisma.knowledgeBase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KnowledgeBases and only return the `id`
     * const knowledgeBaseWithIdOnly = await prisma.knowledgeBase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KnowledgeBaseUpdateManyAndReturnArgs>(args: SelectSubset<T, KnowledgeBaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KnowledgeBase.
     * @param {KnowledgeBaseUpsertArgs} args - Arguments to update or create a KnowledgeBase.
     * @example
     * // Update or create a KnowledgeBase
     * const knowledgeBase = await prisma.knowledgeBase.upsert({
     *   create: {
     *     // ... data to create a KnowledgeBase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeBase we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeBaseUpsertArgs>(args: SelectSubset<T, KnowledgeBaseUpsertArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KnowledgeBases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseCountArgs} args - Arguments to filter KnowledgeBases to count.
     * @example
     * // Count the number of KnowledgeBases
     * const count = await prisma.knowledgeBase.count({
     *   where: {
     *     // ... the filter for the KnowledgeBases we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeBaseCountArgs>(
      args?: Subset<T, KnowledgeBaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeBaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeBase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeBaseAggregateArgs>(args: Subset<T, KnowledgeBaseAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeBaseAggregateType<T>>

    /**
     * Group by KnowledgeBase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeBaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeBaseGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeBaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeBaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeBaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeBase model
   */
  readonly fields: KnowledgeBaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeBase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeBaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeBase model
   */
  interface KnowledgeBaseFieldRefs {
    readonly id: FieldRef<"KnowledgeBase", 'String'>
    readonly domain: FieldRef<"KnowledgeBase", 'String'>
    readonly topic: FieldRef<"KnowledgeBase", 'String'>
    readonly content: FieldRef<"KnowledgeBase", 'String'>
    readonly answer: FieldRef<"KnowledgeBase", 'String'>
    readonly difficulty: FieldRef<"KnowledgeBase", 'Difficulty'>
    readonly type: FieldRef<"KnowledgeBase", 'QuestionType'>
    readonly codeSnippet: FieldRef<"KnowledgeBase", 'String'>
    readonly tags: FieldRef<"KnowledgeBase", 'Json'>
    readonly status: FieldRef<"KnowledgeBase", 'KnowledgeStatus'>
    readonly createdAt: FieldRef<"KnowledgeBase", 'DateTime'>
    readonly updatedAt: FieldRef<"KnowledgeBase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeBase findUnique
   */
  export type KnowledgeBaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * Filter, which KnowledgeBase to fetch.
     */
    where: KnowledgeBaseWhereUniqueInput
  }

  /**
   * KnowledgeBase findUniqueOrThrow
   */
  export type KnowledgeBaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * Filter, which KnowledgeBase to fetch.
     */
    where: KnowledgeBaseWhereUniqueInput
  }

  /**
   * KnowledgeBase findFirst
   */
  export type KnowledgeBaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * Filter, which KnowledgeBase to fetch.
     */
    where?: KnowledgeBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBases to fetch.
     */
    orderBy?: KnowledgeBaseOrderByWithRelationInput | KnowledgeBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeBases.
     */
    cursor?: KnowledgeBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeBases.
     */
    distinct?: KnowledgeBaseScalarFieldEnum | KnowledgeBaseScalarFieldEnum[]
  }

  /**
   * KnowledgeBase findFirstOrThrow
   */
  export type KnowledgeBaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * Filter, which KnowledgeBase to fetch.
     */
    where?: KnowledgeBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBases to fetch.
     */
    orderBy?: KnowledgeBaseOrderByWithRelationInput | KnowledgeBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeBases.
     */
    cursor?: KnowledgeBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeBases.
     */
    distinct?: KnowledgeBaseScalarFieldEnum | KnowledgeBaseScalarFieldEnum[]
  }

  /**
   * KnowledgeBase findMany
   */
  export type KnowledgeBaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * Filter, which KnowledgeBases to fetch.
     */
    where?: KnowledgeBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBases to fetch.
     */
    orderBy?: KnowledgeBaseOrderByWithRelationInput | KnowledgeBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeBases.
     */
    cursor?: KnowledgeBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBases.
     */
    skip?: number
    distinct?: KnowledgeBaseScalarFieldEnum | KnowledgeBaseScalarFieldEnum[]
  }

  /**
   * KnowledgeBase create
   */
  export type KnowledgeBaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeBase.
     */
    data: XOR<KnowledgeBaseCreateInput, KnowledgeBaseUncheckedCreateInput>
  }

  /**
   * KnowledgeBase createMany
   */
  export type KnowledgeBaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeBases.
     */
    data: KnowledgeBaseCreateManyInput | KnowledgeBaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeBase createManyAndReturn
   */
  export type KnowledgeBaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * The data used to create many KnowledgeBases.
     */
    data: KnowledgeBaseCreateManyInput | KnowledgeBaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeBase update
   */
  export type KnowledgeBaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeBase.
     */
    data: XOR<KnowledgeBaseUpdateInput, KnowledgeBaseUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeBase to update.
     */
    where: KnowledgeBaseWhereUniqueInput
  }

  /**
   * KnowledgeBase updateMany
   */
  export type KnowledgeBaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeBases.
     */
    data: XOR<KnowledgeBaseUpdateManyMutationInput, KnowledgeBaseUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeBases to update
     */
    where?: KnowledgeBaseWhereInput
    /**
     * Limit how many KnowledgeBases to update.
     */
    limit?: number
  }

  /**
   * KnowledgeBase updateManyAndReturn
   */
  export type KnowledgeBaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * The data used to update KnowledgeBases.
     */
    data: XOR<KnowledgeBaseUpdateManyMutationInput, KnowledgeBaseUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeBases to update
     */
    where?: KnowledgeBaseWhereInput
    /**
     * Limit how many KnowledgeBases to update.
     */
    limit?: number
  }

  /**
   * KnowledgeBase upsert
   */
  export type KnowledgeBaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeBase to update in case it exists.
     */
    where: KnowledgeBaseWhereUniqueInput
    /**
     * In case the KnowledgeBase found by the `where` argument doesn't exist, create a new KnowledgeBase with this data.
     */
    create: XOR<KnowledgeBaseCreateInput, KnowledgeBaseUncheckedCreateInput>
    /**
     * In case the KnowledgeBase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeBaseUpdateInput, KnowledgeBaseUncheckedUpdateInput>
  }

  /**
   * KnowledgeBase delete
   */
  export type KnowledgeBaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * Filter which KnowledgeBase to delete.
     */
    where: KnowledgeBaseWhereUniqueInput
  }

  /**
   * KnowledgeBase deleteMany
   */
  export type KnowledgeBaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeBases to delete
     */
    where?: KnowledgeBaseWhereInput
    /**
     * Limit how many KnowledgeBases to delete.
     */
    limit?: number
  }

  /**
   * KnowledgeBase without action
   */
  export type KnowledgeBaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
  }


  /**
   * Model SystemPrompt
   */

  export type AggregateSystemPrompt = {
    _count: SystemPromptCountAggregateOutputType | null
    _min: SystemPromptMinAggregateOutputType | null
    _max: SystemPromptMaxAggregateOutputType | null
  }

  export type SystemPromptMinAggregateOutputType = {
    id: string | null
    role: string | null
    prompt: string | null
    isActive: boolean | null
    updatedAt: Date | null
  }

  export type SystemPromptMaxAggregateOutputType = {
    id: string | null
    role: string | null
    prompt: string | null
    isActive: boolean | null
    updatedAt: Date | null
  }

  export type SystemPromptCountAggregateOutputType = {
    id: number
    role: number
    prompt: number
    isActive: number
    updatedAt: number
    _all: number
  }


  export type SystemPromptMinAggregateInputType = {
    id?: true
    role?: true
    prompt?: true
    isActive?: true
    updatedAt?: true
  }

  export type SystemPromptMaxAggregateInputType = {
    id?: true
    role?: true
    prompt?: true
    isActive?: true
    updatedAt?: true
  }

  export type SystemPromptCountAggregateInputType = {
    id?: true
    role?: true
    prompt?: true
    isActive?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemPromptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemPrompt to aggregate.
     */
    where?: SystemPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemPrompts to fetch.
     */
    orderBy?: SystemPromptOrderByWithRelationInput | SystemPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemPrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemPrompts
    **/
    _count?: true | SystemPromptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemPromptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemPromptMaxAggregateInputType
  }

  export type GetSystemPromptAggregateType<T extends SystemPromptAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemPrompt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemPrompt[P]>
      : GetScalarType<T[P], AggregateSystemPrompt[P]>
  }




  export type SystemPromptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemPromptWhereInput
    orderBy?: SystemPromptOrderByWithAggregationInput | SystemPromptOrderByWithAggregationInput[]
    by: SystemPromptScalarFieldEnum[] | SystemPromptScalarFieldEnum
    having?: SystemPromptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemPromptCountAggregateInputType | true
    _min?: SystemPromptMinAggregateInputType
    _max?: SystemPromptMaxAggregateInputType
  }

  export type SystemPromptGroupByOutputType = {
    id: string
    role: string
    prompt: string
    isActive: boolean
    updatedAt: Date
    _count: SystemPromptCountAggregateOutputType | null
    _min: SystemPromptMinAggregateOutputType | null
    _max: SystemPromptMaxAggregateOutputType | null
  }

  type GetSystemPromptGroupByPayload<T extends SystemPromptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemPromptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemPromptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemPromptGroupByOutputType[P]>
            : GetScalarType<T[P], SystemPromptGroupByOutputType[P]>
        }
      >
    >


  export type SystemPromptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    prompt?: boolean
    isActive?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemPrompt"]>

  export type SystemPromptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    prompt?: boolean
    isActive?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemPrompt"]>

  export type SystemPromptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    prompt?: boolean
    isActive?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemPrompt"]>

  export type SystemPromptSelectScalar = {
    id?: boolean
    role?: boolean
    prompt?: boolean
    isActive?: boolean
    updatedAt?: boolean
  }

  export type SystemPromptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role" | "prompt" | "isActive" | "updatedAt", ExtArgs["result"]["systemPrompt"]>

  export type $SystemPromptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemPrompt"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role: string
      prompt: string
      isActive: boolean
      updatedAt: Date
    }, ExtArgs["result"]["systemPrompt"]>
    composites: {}
  }

  type SystemPromptGetPayload<S extends boolean | null | undefined | SystemPromptDefaultArgs> = $Result.GetResult<Prisma.$SystemPromptPayload, S>

  type SystemPromptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemPromptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemPromptCountAggregateInputType | true
    }

  export interface SystemPromptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemPrompt'], meta: { name: 'SystemPrompt' } }
    /**
     * Find zero or one SystemPrompt that matches the filter.
     * @param {SystemPromptFindUniqueArgs} args - Arguments to find a SystemPrompt
     * @example
     * // Get one SystemPrompt
     * const systemPrompt = await prisma.systemPrompt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemPromptFindUniqueArgs>(args: SelectSubset<T, SystemPromptFindUniqueArgs<ExtArgs>>): Prisma__SystemPromptClient<$Result.GetResult<Prisma.$SystemPromptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemPrompt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemPromptFindUniqueOrThrowArgs} args - Arguments to find a SystemPrompt
     * @example
     * // Get one SystemPrompt
     * const systemPrompt = await prisma.systemPrompt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemPromptFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemPromptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemPromptClient<$Result.GetResult<Prisma.$SystemPromptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemPrompt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPromptFindFirstArgs} args - Arguments to find a SystemPrompt
     * @example
     * // Get one SystemPrompt
     * const systemPrompt = await prisma.systemPrompt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemPromptFindFirstArgs>(args?: SelectSubset<T, SystemPromptFindFirstArgs<ExtArgs>>): Prisma__SystemPromptClient<$Result.GetResult<Prisma.$SystemPromptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemPrompt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPromptFindFirstOrThrowArgs} args - Arguments to find a SystemPrompt
     * @example
     * // Get one SystemPrompt
     * const systemPrompt = await prisma.systemPrompt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemPromptFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemPromptFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemPromptClient<$Result.GetResult<Prisma.$SystemPromptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemPrompts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPromptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemPrompts
     * const systemPrompts = await prisma.systemPrompt.findMany()
     * 
     * // Get first 10 SystemPrompts
     * const systemPrompts = await prisma.systemPrompt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemPromptWithIdOnly = await prisma.systemPrompt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemPromptFindManyArgs>(args?: SelectSubset<T, SystemPromptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemPromptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemPrompt.
     * @param {SystemPromptCreateArgs} args - Arguments to create a SystemPrompt.
     * @example
     * // Create one SystemPrompt
     * const SystemPrompt = await prisma.systemPrompt.create({
     *   data: {
     *     // ... data to create a SystemPrompt
     *   }
     * })
     * 
     */
    create<T extends SystemPromptCreateArgs>(args: SelectSubset<T, SystemPromptCreateArgs<ExtArgs>>): Prisma__SystemPromptClient<$Result.GetResult<Prisma.$SystemPromptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemPrompts.
     * @param {SystemPromptCreateManyArgs} args - Arguments to create many SystemPrompts.
     * @example
     * // Create many SystemPrompts
     * const systemPrompt = await prisma.systemPrompt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemPromptCreateManyArgs>(args?: SelectSubset<T, SystemPromptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemPrompts and returns the data saved in the database.
     * @param {SystemPromptCreateManyAndReturnArgs} args - Arguments to create many SystemPrompts.
     * @example
     * // Create many SystemPrompts
     * const systemPrompt = await prisma.systemPrompt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemPrompts and only return the `id`
     * const systemPromptWithIdOnly = await prisma.systemPrompt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemPromptCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemPromptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemPromptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemPrompt.
     * @param {SystemPromptDeleteArgs} args - Arguments to delete one SystemPrompt.
     * @example
     * // Delete one SystemPrompt
     * const SystemPrompt = await prisma.systemPrompt.delete({
     *   where: {
     *     // ... filter to delete one SystemPrompt
     *   }
     * })
     * 
     */
    delete<T extends SystemPromptDeleteArgs>(args: SelectSubset<T, SystemPromptDeleteArgs<ExtArgs>>): Prisma__SystemPromptClient<$Result.GetResult<Prisma.$SystemPromptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemPrompt.
     * @param {SystemPromptUpdateArgs} args - Arguments to update one SystemPrompt.
     * @example
     * // Update one SystemPrompt
     * const systemPrompt = await prisma.systemPrompt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemPromptUpdateArgs>(args: SelectSubset<T, SystemPromptUpdateArgs<ExtArgs>>): Prisma__SystemPromptClient<$Result.GetResult<Prisma.$SystemPromptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemPrompts.
     * @param {SystemPromptDeleteManyArgs} args - Arguments to filter SystemPrompts to delete.
     * @example
     * // Delete a few SystemPrompts
     * const { count } = await prisma.systemPrompt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemPromptDeleteManyArgs>(args?: SelectSubset<T, SystemPromptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemPrompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPromptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemPrompts
     * const systemPrompt = await prisma.systemPrompt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemPromptUpdateManyArgs>(args: SelectSubset<T, SystemPromptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemPrompts and returns the data updated in the database.
     * @param {SystemPromptUpdateManyAndReturnArgs} args - Arguments to update many SystemPrompts.
     * @example
     * // Update many SystemPrompts
     * const systemPrompt = await prisma.systemPrompt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemPrompts and only return the `id`
     * const systemPromptWithIdOnly = await prisma.systemPrompt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemPromptUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemPromptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemPromptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemPrompt.
     * @param {SystemPromptUpsertArgs} args - Arguments to update or create a SystemPrompt.
     * @example
     * // Update or create a SystemPrompt
     * const systemPrompt = await prisma.systemPrompt.upsert({
     *   create: {
     *     // ... data to create a SystemPrompt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemPrompt we want to update
     *   }
     * })
     */
    upsert<T extends SystemPromptUpsertArgs>(args: SelectSubset<T, SystemPromptUpsertArgs<ExtArgs>>): Prisma__SystemPromptClient<$Result.GetResult<Prisma.$SystemPromptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemPrompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPromptCountArgs} args - Arguments to filter SystemPrompts to count.
     * @example
     * // Count the number of SystemPrompts
     * const count = await prisma.systemPrompt.count({
     *   where: {
     *     // ... the filter for the SystemPrompts we want to count
     *   }
     * })
    **/
    count<T extends SystemPromptCountArgs>(
      args?: Subset<T, SystemPromptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemPromptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemPrompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPromptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemPromptAggregateArgs>(args: Subset<T, SystemPromptAggregateArgs>): Prisma.PrismaPromise<GetSystemPromptAggregateType<T>>

    /**
     * Group by SystemPrompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemPromptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemPromptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemPromptGroupByArgs['orderBy'] }
        : { orderBy?: SystemPromptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemPromptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemPromptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemPrompt model
   */
  readonly fields: SystemPromptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemPrompt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemPromptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemPrompt model
   */
  interface SystemPromptFieldRefs {
    readonly id: FieldRef<"SystemPrompt", 'String'>
    readonly role: FieldRef<"SystemPrompt", 'String'>
    readonly prompt: FieldRef<"SystemPrompt", 'String'>
    readonly isActive: FieldRef<"SystemPrompt", 'Boolean'>
    readonly updatedAt: FieldRef<"SystemPrompt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemPrompt findUnique
   */
  export type SystemPromptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPrompt
     */
    select?: SystemPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPrompt
     */
    omit?: SystemPromptOmit<ExtArgs> | null
    /**
     * Filter, which SystemPrompt to fetch.
     */
    where: SystemPromptWhereUniqueInput
  }

  /**
   * SystemPrompt findUniqueOrThrow
   */
  export type SystemPromptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPrompt
     */
    select?: SystemPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPrompt
     */
    omit?: SystemPromptOmit<ExtArgs> | null
    /**
     * Filter, which SystemPrompt to fetch.
     */
    where: SystemPromptWhereUniqueInput
  }

  /**
   * SystemPrompt findFirst
   */
  export type SystemPromptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPrompt
     */
    select?: SystemPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPrompt
     */
    omit?: SystemPromptOmit<ExtArgs> | null
    /**
     * Filter, which SystemPrompt to fetch.
     */
    where?: SystemPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemPrompts to fetch.
     */
    orderBy?: SystemPromptOrderByWithRelationInput | SystemPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemPrompts.
     */
    cursor?: SystemPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemPrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemPrompts.
     */
    distinct?: SystemPromptScalarFieldEnum | SystemPromptScalarFieldEnum[]
  }

  /**
   * SystemPrompt findFirstOrThrow
   */
  export type SystemPromptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPrompt
     */
    select?: SystemPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPrompt
     */
    omit?: SystemPromptOmit<ExtArgs> | null
    /**
     * Filter, which SystemPrompt to fetch.
     */
    where?: SystemPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemPrompts to fetch.
     */
    orderBy?: SystemPromptOrderByWithRelationInput | SystemPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemPrompts.
     */
    cursor?: SystemPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemPrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemPrompts.
     */
    distinct?: SystemPromptScalarFieldEnum | SystemPromptScalarFieldEnum[]
  }

  /**
   * SystemPrompt findMany
   */
  export type SystemPromptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPrompt
     */
    select?: SystemPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPrompt
     */
    omit?: SystemPromptOmit<ExtArgs> | null
    /**
     * Filter, which SystemPrompts to fetch.
     */
    where?: SystemPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemPrompts to fetch.
     */
    orderBy?: SystemPromptOrderByWithRelationInput | SystemPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemPrompts.
     */
    cursor?: SystemPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemPrompts.
     */
    skip?: number
    distinct?: SystemPromptScalarFieldEnum | SystemPromptScalarFieldEnum[]
  }

  /**
   * SystemPrompt create
   */
  export type SystemPromptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPrompt
     */
    select?: SystemPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPrompt
     */
    omit?: SystemPromptOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemPrompt.
     */
    data: XOR<SystemPromptCreateInput, SystemPromptUncheckedCreateInput>
  }

  /**
   * SystemPrompt createMany
   */
  export type SystemPromptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemPrompts.
     */
    data: SystemPromptCreateManyInput | SystemPromptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemPrompt createManyAndReturn
   */
  export type SystemPromptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPrompt
     */
    select?: SystemPromptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPrompt
     */
    omit?: SystemPromptOmit<ExtArgs> | null
    /**
     * The data used to create many SystemPrompts.
     */
    data: SystemPromptCreateManyInput | SystemPromptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemPrompt update
   */
  export type SystemPromptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPrompt
     */
    select?: SystemPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPrompt
     */
    omit?: SystemPromptOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemPrompt.
     */
    data: XOR<SystemPromptUpdateInput, SystemPromptUncheckedUpdateInput>
    /**
     * Choose, which SystemPrompt to update.
     */
    where: SystemPromptWhereUniqueInput
  }

  /**
   * SystemPrompt updateMany
   */
  export type SystemPromptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemPrompts.
     */
    data: XOR<SystemPromptUpdateManyMutationInput, SystemPromptUncheckedUpdateManyInput>
    /**
     * Filter which SystemPrompts to update
     */
    where?: SystemPromptWhereInput
    /**
     * Limit how many SystemPrompts to update.
     */
    limit?: number
  }

  /**
   * SystemPrompt updateManyAndReturn
   */
  export type SystemPromptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPrompt
     */
    select?: SystemPromptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPrompt
     */
    omit?: SystemPromptOmit<ExtArgs> | null
    /**
     * The data used to update SystemPrompts.
     */
    data: XOR<SystemPromptUpdateManyMutationInput, SystemPromptUncheckedUpdateManyInput>
    /**
     * Filter which SystemPrompts to update
     */
    where?: SystemPromptWhereInput
    /**
     * Limit how many SystemPrompts to update.
     */
    limit?: number
  }

  /**
   * SystemPrompt upsert
   */
  export type SystemPromptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPrompt
     */
    select?: SystemPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPrompt
     */
    omit?: SystemPromptOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemPrompt to update in case it exists.
     */
    where: SystemPromptWhereUniqueInput
    /**
     * In case the SystemPrompt found by the `where` argument doesn't exist, create a new SystemPrompt with this data.
     */
    create: XOR<SystemPromptCreateInput, SystemPromptUncheckedCreateInput>
    /**
     * In case the SystemPrompt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemPromptUpdateInput, SystemPromptUncheckedUpdateInput>
  }

  /**
   * SystemPrompt delete
   */
  export type SystemPromptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPrompt
     */
    select?: SystemPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPrompt
     */
    omit?: SystemPromptOmit<ExtArgs> | null
    /**
     * Filter which SystemPrompt to delete.
     */
    where: SystemPromptWhereUniqueInput
  }

  /**
   * SystemPrompt deleteMany
   */
  export type SystemPromptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemPrompts to delete
     */
    where?: SystemPromptWhereInput
    /**
     * Limit how many SystemPrompts to delete.
     */
    limit?: number
  }

  /**
   * SystemPrompt without action
   */
  export type SystemPromptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemPrompt
     */
    select?: SystemPromptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemPrompt
     */
    omit?: SystemPromptOmit<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    paymentId: string | null
    signature: string | null
    amount: number | null
    currency: string | null
    status: string | null
    userId: string | null
    courseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    paymentId: string | null
    signature: string | null
    amount: number | null
    currency: string | null
    status: string | null
    userId: string | null
    courseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    orderId: number
    paymentId: number
    signature: number
    amount: number
    currency: number
    status: number
    userId: number
    courseId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    orderId?: true
    paymentId?: true
    signature?: true
    amount?: true
    currency?: true
    status?: true
    userId?: true
    courseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    orderId?: true
    paymentId?: true
    signature?: true
    amount?: true
    currency?: true
    status?: true
    userId?: true
    courseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    orderId?: true
    paymentId?: true
    signature?: true
    amount?: true
    currency?: true
    status?: true
    userId?: true
    courseId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    orderId: string
    paymentId: string | null
    signature: string | null
    amount: number
    currency: string
    status: string
    userId: string
    courseId: string
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    paymentId?: boolean
    signature?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    userId?: boolean
    courseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    paymentId?: boolean
    signature?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    userId?: boolean
    courseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    paymentId?: boolean
    signature?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    userId?: boolean
    courseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    orderId?: boolean
    paymentId?: boolean
    signature?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    userId?: boolean
    courseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "paymentId" | "signature" | "amount" | "currency" | "status" | "userId" | "courseId" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      paymentId: string | null
      signature: string | null
      amount: number
      currency: string
      status: string
      userId: string
      courseId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly orderId: FieldRef<"Payment", 'String'>
    readonly paymentId: FieldRef<"Payment", 'String'>
    readonly signature: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'String'>
    readonly courseId: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model ForumCategory
   */

  export type AggregateForumCategory = {
    _count: ForumCategoryCountAggregateOutputType | null
    _min: ForumCategoryMinAggregateOutputType | null
    _max: ForumCategoryMaxAggregateOutputType | null
  }

  export type ForumCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    slug: string | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    slug: string | null
    icon: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    slug: number
    icon: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ForumCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ForumCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumCategory to aggregate.
     */
    where?: ForumCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumCategories to fetch.
     */
    orderBy?: ForumCategoryOrderByWithRelationInput | ForumCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumCategories
    **/
    _count?: true | ForumCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumCategoryMaxAggregateInputType
  }

  export type GetForumCategoryAggregateType<T extends ForumCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateForumCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumCategory[P]>
      : GetScalarType<T[P], AggregateForumCategory[P]>
  }




  export type ForumCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumCategoryWhereInput
    orderBy?: ForumCategoryOrderByWithAggregationInput | ForumCategoryOrderByWithAggregationInput[]
    by: ForumCategoryScalarFieldEnum[] | ForumCategoryScalarFieldEnum
    having?: ForumCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumCategoryCountAggregateInputType | true
    _min?: ForumCategoryMinAggregateInputType
    _max?: ForumCategoryMaxAggregateInputType
  }

  export type ForumCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    slug: string
    icon: string | null
    createdAt: Date
    updatedAt: Date
    _count: ForumCategoryCountAggregateOutputType | null
    _min: ForumCategoryMinAggregateOutputType | null
    _max: ForumCategoryMaxAggregateOutputType | null
  }

  type GetForumCategoryGroupByPayload<T extends ForumCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ForumCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ForumCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posts?: boolean | ForumCategory$postsArgs<ExtArgs>
    _count?: boolean | ForumCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumCategory"]>

  export type ForumCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["forumCategory"]>

  export type ForumCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["forumCategory"]>

  export type ForumCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ForumCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "slug" | "icon" | "createdAt" | "updatedAt", ExtArgs["result"]["forumCategory"]>
  export type ForumCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | ForumCategory$postsArgs<ExtArgs>
    _count?: boolean | ForumCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ForumCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ForumCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ForumCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForumCategory"
    objects: {
      posts: Prisma.$ForumPostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      slug: string
      icon: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["forumCategory"]>
    composites: {}
  }

  type ForumCategoryGetPayload<S extends boolean | null | undefined | ForumCategoryDefaultArgs> = $Result.GetResult<Prisma.$ForumCategoryPayload, S>

  type ForumCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ForumCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ForumCategoryCountAggregateInputType | true
    }

  export interface ForumCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumCategory'], meta: { name: 'ForumCategory' } }
    /**
     * Find zero or one ForumCategory that matches the filter.
     * @param {ForumCategoryFindUniqueArgs} args - Arguments to find a ForumCategory
     * @example
     * // Get one ForumCategory
     * const forumCategory = await prisma.forumCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumCategoryFindUniqueArgs>(args: SelectSubset<T, ForumCategoryFindUniqueArgs<ExtArgs>>): Prisma__ForumCategoryClient<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ForumCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ForumCategoryFindUniqueOrThrowArgs} args - Arguments to find a ForumCategory
     * @example
     * // Get one ForumCategory
     * const forumCategory = await prisma.forumCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumCategoryClient<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCategoryFindFirstArgs} args - Arguments to find a ForumCategory
     * @example
     * // Get one ForumCategory
     * const forumCategory = await prisma.forumCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumCategoryFindFirstArgs>(args?: SelectSubset<T, ForumCategoryFindFirstArgs<ExtArgs>>): Prisma__ForumCategoryClient<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCategoryFindFirstOrThrowArgs} args - Arguments to find a ForumCategory
     * @example
     * // Get one ForumCategory
     * const forumCategory = await prisma.forumCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumCategoryClient<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ForumCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumCategories
     * const forumCategories = await prisma.forumCategory.findMany()
     * 
     * // Get first 10 ForumCategories
     * const forumCategories = await prisma.forumCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumCategoryWithIdOnly = await prisma.forumCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumCategoryFindManyArgs>(args?: SelectSubset<T, ForumCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ForumCategory.
     * @param {ForumCategoryCreateArgs} args - Arguments to create a ForumCategory.
     * @example
     * // Create one ForumCategory
     * const ForumCategory = await prisma.forumCategory.create({
     *   data: {
     *     // ... data to create a ForumCategory
     *   }
     * })
     * 
     */
    create<T extends ForumCategoryCreateArgs>(args: SelectSubset<T, ForumCategoryCreateArgs<ExtArgs>>): Prisma__ForumCategoryClient<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ForumCategories.
     * @param {ForumCategoryCreateManyArgs} args - Arguments to create many ForumCategories.
     * @example
     * // Create many ForumCategories
     * const forumCategory = await prisma.forumCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumCategoryCreateManyArgs>(args?: SelectSubset<T, ForumCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumCategories and returns the data saved in the database.
     * @param {ForumCategoryCreateManyAndReturnArgs} args - Arguments to create many ForumCategories.
     * @example
     * // Create many ForumCategories
     * const forumCategory = await prisma.forumCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumCategories and only return the `id`
     * const forumCategoryWithIdOnly = await prisma.forumCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ForumCategory.
     * @param {ForumCategoryDeleteArgs} args - Arguments to delete one ForumCategory.
     * @example
     * // Delete one ForumCategory
     * const ForumCategory = await prisma.forumCategory.delete({
     *   where: {
     *     // ... filter to delete one ForumCategory
     *   }
     * })
     * 
     */
    delete<T extends ForumCategoryDeleteArgs>(args: SelectSubset<T, ForumCategoryDeleteArgs<ExtArgs>>): Prisma__ForumCategoryClient<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ForumCategory.
     * @param {ForumCategoryUpdateArgs} args - Arguments to update one ForumCategory.
     * @example
     * // Update one ForumCategory
     * const forumCategory = await prisma.forumCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumCategoryUpdateArgs>(args: SelectSubset<T, ForumCategoryUpdateArgs<ExtArgs>>): Prisma__ForumCategoryClient<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ForumCategories.
     * @param {ForumCategoryDeleteManyArgs} args - Arguments to filter ForumCategories to delete.
     * @example
     * // Delete a few ForumCategories
     * const { count } = await prisma.forumCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumCategoryDeleteManyArgs>(args?: SelectSubset<T, ForumCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumCategories
     * const forumCategory = await prisma.forumCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumCategoryUpdateManyArgs>(args: SelectSubset<T, ForumCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumCategories and returns the data updated in the database.
     * @param {ForumCategoryUpdateManyAndReturnArgs} args - Arguments to update many ForumCategories.
     * @example
     * // Update many ForumCategories
     * const forumCategory = await prisma.forumCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ForumCategories and only return the `id`
     * const forumCategoryWithIdOnly = await prisma.forumCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ForumCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ForumCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ForumCategory.
     * @param {ForumCategoryUpsertArgs} args - Arguments to update or create a ForumCategory.
     * @example
     * // Update or create a ForumCategory
     * const forumCategory = await prisma.forumCategory.upsert({
     *   create: {
     *     // ... data to create a ForumCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumCategory we want to update
     *   }
     * })
     */
    upsert<T extends ForumCategoryUpsertArgs>(args: SelectSubset<T, ForumCategoryUpsertArgs<ExtArgs>>): Prisma__ForumCategoryClient<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ForumCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCategoryCountArgs} args - Arguments to filter ForumCategories to count.
     * @example
     * // Count the number of ForumCategories
     * const count = await prisma.forumCategory.count({
     *   where: {
     *     // ... the filter for the ForumCategories we want to count
     *   }
     * })
    **/
    count<T extends ForumCategoryCountArgs>(
      args?: Subset<T, ForumCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumCategoryAggregateArgs>(args: Subset<T, ForumCategoryAggregateArgs>): Prisma.PrismaPromise<GetForumCategoryAggregateType<T>>

    /**
     * Group by ForumCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ForumCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForumCategory model
   */
  readonly fields: ForumCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends ForumCategory$postsArgs<ExtArgs> = {}>(args?: Subset<T, ForumCategory$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForumCategory model
   */
  interface ForumCategoryFieldRefs {
    readonly id: FieldRef<"ForumCategory", 'String'>
    readonly name: FieldRef<"ForumCategory", 'String'>
    readonly description: FieldRef<"ForumCategory", 'String'>
    readonly slug: FieldRef<"ForumCategory", 'String'>
    readonly icon: FieldRef<"ForumCategory", 'String'>
    readonly createdAt: FieldRef<"ForumCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ForumCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ForumCategory findUnique
   */
  export type ForumCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumCategory
     */
    omit?: ForumCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ForumCategory to fetch.
     */
    where: ForumCategoryWhereUniqueInput
  }

  /**
   * ForumCategory findUniqueOrThrow
   */
  export type ForumCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumCategory
     */
    omit?: ForumCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ForumCategory to fetch.
     */
    where: ForumCategoryWhereUniqueInput
  }

  /**
   * ForumCategory findFirst
   */
  export type ForumCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumCategory
     */
    omit?: ForumCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ForumCategory to fetch.
     */
    where?: ForumCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumCategories to fetch.
     */
    orderBy?: ForumCategoryOrderByWithRelationInput | ForumCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumCategories.
     */
    cursor?: ForumCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumCategories.
     */
    distinct?: ForumCategoryScalarFieldEnum | ForumCategoryScalarFieldEnum[]
  }

  /**
   * ForumCategory findFirstOrThrow
   */
  export type ForumCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumCategory
     */
    omit?: ForumCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ForumCategory to fetch.
     */
    where?: ForumCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumCategories to fetch.
     */
    orderBy?: ForumCategoryOrderByWithRelationInput | ForumCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumCategories.
     */
    cursor?: ForumCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumCategories.
     */
    distinct?: ForumCategoryScalarFieldEnum | ForumCategoryScalarFieldEnum[]
  }

  /**
   * ForumCategory findMany
   */
  export type ForumCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumCategory
     */
    omit?: ForumCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ForumCategories to fetch.
     */
    where?: ForumCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumCategories to fetch.
     */
    orderBy?: ForumCategoryOrderByWithRelationInput | ForumCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumCategories.
     */
    cursor?: ForumCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumCategories.
     */
    skip?: number
    distinct?: ForumCategoryScalarFieldEnum | ForumCategoryScalarFieldEnum[]
  }

  /**
   * ForumCategory create
   */
  export type ForumCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumCategory
     */
    omit?: ForumCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumCategory.
     */
    data: XOR<ForumCategoryCreateInput, ForumCategoryUncheckedCreateInput>
  }

  /**
   * ForumCategory createMany
   */
  export type ForumCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumCategories.
     */
    data: ForumCategoryCreateManyInput | ForumCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForumCategory createManyAndReturn
   */
  export type ForumCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ForumCategory
     */
    omit?: ForumCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ForumCategories.
     */
    data: ForumCategoryCreateManyInput | ForumCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForumCategory update
   */
  export type ForumCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumCategory
     */
    omit?: ForumCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumCategory.
     */
    data: XOR<ForumCategoryUpdateInput, ForumCategoryUncheckedUpdateInput>
    /**
     * Choose, which ForumCategory to update.
     */
    where: ForumCategoryWhereUniqueInput
  }

  /**
   * ForumCategory updateMany
   */
  export type ForumCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumCategories.
     */
    data: XOR<ForumCategoryUpdateManyMutationInput, ForumCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ForumCategories to update
     */
    where?: ForumCategoryWhereInput
    /**
     * Limit how many ForumCategories to update.
     */
    limit?: number
  }

  /**
   * ForumCategory updateManyAndReturn
   */
  export type ForumCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ForumCategory
     */
    omit?: ForumCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ForumCategories.
     */
    data: XOR<ForumCategoryUpdateManyMutationInput, ForumCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ForumCategories to update
     */
    where?: ForumCategoryWhereInput
    /**
     * Limit how many ForumCategories to update.
     */
    limit?: number
  }

  /**
   * ForumCategory upsert
   */
  export type ForumCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumCategory
     */
    omit?: ForumCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumCategory to update in case it exists.
     */
    where: ForumCategoryWhereUniqueInput
    /**
     * In case the ForumCategory found by the `where` argument doesn't exist, create a new ForumCategory with this data.
     */
    create: XOR<ForumCategoryCreateInput, ForumCategoryUncheckedCreateInput>
    /**
     * In case the ForumCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumCategoryUpdateInput, ForumCategoryUncheckedUpdateInput>
  }

  /**
   * ForumCategory delete
   */
  export type ForumCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumCategory
     */
    omit?: ForumCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCategoryInclude<ExtArgs> | null
    /**
     * Filter which ForumCategory to delete.
     */
    where: ForumCategoryWhereUniqueInput
  }

  /**
   * ForumCategory deleteMany
   */
  export type ForumCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumCategories to delete
     */
    where?: ForumCategoryWhereInput
    /**
     * Limit how many ForumCategories to delete.
     */
    limit?: number
  }

  /**
   * ForumCategory.posts
   */
  export type ForumCategory$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    where?: ForumPostWhereInput
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    cursor?: ForumPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * ForumCategory without action
   */
  export type ForumCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCategory
     */
    select?: ForumCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumCategory
     */
    omit?: ForumCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ForumPost
   */

  export type AggregateForumPost = {
    _count: ForumPostCountAggregateOutputType | null
    _avg: ForumPostAvgAggregateOutputType | null
    _sum: ForumPostSumAggregateOutputType | null
    _min: ForumPostMinAggregateOutputType | null
    _max: ForumPostMaxAggregateOutputType | null
  }

  export type ForumPostAvgAggregateOutputType = {
    likes: number | null
    views: number | null
  }

  export type ForumPostSumAggregateOutputType = {
    likes: number | null
    views: number | null
  }

  export type ForumPostMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    slug: string | null
    authorId: string | null
    categoryId: string | null
    likes: number | null
    views: number | null
    isPinned: boolean | null
    isSolved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumPostMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    slug: string | null
    authorId: string | null
    categoryId: string | null
    likes: number | null
    views: number | null
    isPinned: boolean | null
    isSolved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumPostCountAggregateOutputType = {
    id: number
    title: number
    content: number
    slug: number
    authorId: number
    categoryId: number
    likes: number
    views: number
    isPinned: number
    isSolved: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ForumPostAvgAggregateInputType = {
    likes?: true
    views?: true
  }

  export type ForumPostSumAggregateInputType = {
    likes?: true
    views?: true
  }

  export type ForumPostMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    slug?: true
    authorId?: true
    categoryId?: true
    likes?: true
    views?: true
    isPinned?: true
    isSolved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumPostMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    slug?: true
    authorId?: true
    categoryId?: true
    likes?: true
    views?: true
    isPinned?: true
    isSolved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumPostCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    slug?: true
    authorId?: true
    categoryId?: true
    likes?: true
    views?: true
    isPinned?: true
    isSolved?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ForumPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumPost to aggregate.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumPosts
    **/
    _count?: true | ForumPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ForumPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ForumPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumPostMaxAggregateInputType
  }

  export type GetForumPostAggregateType<T extends ForumPostAggregateArgs> = {
        [P in keyof T & keyof AggregateForumPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumPost[P]>
      : GetScalarType<T[P], AggregateForumPost[P]>
  }




  export type ForumPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumPostWhereInput
    orderBy?: ForumPostOrderByWithAggregationInput | ForumPostOrderByWithAggregationInput[]
    by: ForumPostScalarFieldEnum[] | ForumPostScalarFieldEnum
    having?: ForumPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumPostCountAggregateInputType | true
    _avg?: ForumPostAvgAggregateInputType
    _sum?: ForumPostSumAggregateInputType
    _min?: ForumPostMinAggregateInputType
    _max?: ForumPostMaxAggregateInputType
  }

  export type ForumPostGroupByOutputType = {
    id: string
    title: string
    content: string
    slug: string
    authorId: string
    categoryId: string
    likes: number
    views: number
    isPinned: boolean
    isSolved: boolean
    createdAt: Date
    updatedAt: Date
    _count: ForumPostCountAggregateOutputType | null
    _avg: ForumPostAvgAggregateOutputType | null
    _sum: ForumPostSumAggregateOutputType | null
    _min: ForumPostMinAggregateOutputType | null
    _max: ForumPostMaxAggregateOutputType | null
  }

  type GetForumPostGroupByPayload<T extends ForumPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumPostGroupByOutputType[P]>
            : GetScalarType<T[P], ForumPostGroupByOutputType[P]>
        }
      >
    >


  export type ForumPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    slug?: boolean
    authorId?: boolean
    categoryId?: boolean
    likes?: boolean
    views?: boolean
    isPinned?: boolean
    isSolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | ForumCategoryDefaultArgs<ExtArgs>
    comments?: boolean | ForumPost$commentsArgs<ExtArgs>
    _count?: boolean | ForumPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumPost"]>

  export type ForumPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    slug?: boolean
    authorId?: boolean
    categoryId?: boolean
    likes?: boolean
    views?: boolean
    isPinned?: boolean
    isSolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | ForumCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumPost"]>

  export type ForumPostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    slug?: boolean
    authorId?: boolean
    categoryId?: boolean
    likes?: boolean
    views?: boolean
    isPinned?: boolean
    isSolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | ForumCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumPost"]>

  export type ForumPostSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    slug?: boolean
    authorId?: boolean
    categoryId?: boolean
    likes?: boolean
    views?: boolean
    isPinned?: boolean
    isSolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ForumPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "slug" | "authorId" | "categoryId" | "likes" | "views" | "isPinned" | "isSolved" | "createdAt" | "updatedAt", ExtArgs["result"]["forumPost"]>
  export type ForumPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | ForumCategoryDefaultArgs<ExtArgs>
    comments?: boolean | ForumPost$commentsArgs<ExtArgs>
    _count?: boolean | ForumPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ForumPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | ForumCategoryDefaultArgs<ExtArgs>
  }
  export type ForumPostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | ForumCategoryDefaultArgs<ExtArgs>
  }

  export type $ForumPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForumPost"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      category: Prisma.$ForumCategoryPayload<ExtArgs>
      comments: Prisma.$ForumCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      slug: string
      authorId: string
      categoryId: string
      likes: number
      views: number
      isPinned: boolean
      isSolved: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["forumPost"]>
    composites: {}
  }

  type ForumPostGetPayload<S extends boolean | null | undefined | ForumPostDefaultArgs> = $Result.GetResult<Prisma.$ForumPostPayload, S>

  type ForumPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ForumPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ForumPostCountAggregateInputType | true
    }

  export interface ForumPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumPost'], meta: { name: 'ForumPost' } }
    /**
     * Find zero or one ForumPost that matches the filter.
     * @param {ForumPostFindUniqueArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumPostFindUniqueArgs>(args: SelectSubset<T, ForumPostFindUniqueArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ForumPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ForumPostFindUniqueOrThrowArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumPostFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostFindFirstArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumPostFindFirstArgs>(args?: SelectSubset<T, ForumPostFindFirstArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostFindFirstOrThrowArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumPostFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ForumPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumPosts
     * const forumPosts = await prisma.forumPost.findMany()
     * 
     * // Get first 10 ForumPosts
     * const forumPosts = await prisma.forumPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumPostWithIdOnly = await prisma.forumPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumPostFindManyArgs>(args?: SelectSubset<T, ForumPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ForumPost.
     * @param {ForumPostCreateArgs} args - Arguments to create a ForumPost.
     * @example
     * // Create one ForumPost
     * const ForumPost = await prisma.forumPost.create({
     *   data: {
     *     // ... data to create a ForumPost
     *   }
     * })
     * 
     */
    create<T extends ForumPostCreateArgs>(args: SelectSubset<T, ForumPostCreateArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ForumPosts.
     * @param {ForumPostCreateManyArgs} args - Arguments to create many ForumPosts.
     * @example
     * // Create many ForumPosts
     * const forumPost = await prisma.forumPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumPostCreateManyArgs>(args?: SelectSubset<T, ForumPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumPosts and returns the data saved in the database.
     * @param {ForumPostCreateManyAndReturnArgs} args - Arguments to create many ForumPosts.
     * @example
     * // Create many ForumPosts
     * const forumPost = await prisma.forumPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumPosts and only return the `id`
     * const forumPostWithIdOnly = await prisma.forumPost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumPostCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ForumPost.
     * @param {ForumPostDeleteArgs} args - Arguments to delete one ForumPost.
     * @example
     * // Delete one ForumPost
     * const ForumPost = await prisma.forumPost.delete({
     *   where: {
     *     // ... filter to delete one ForumPost
     *   }
     * })
     * 
     */
    delete<T extends ForumPostDeleteArgs>(args: SelectSubset<T, ForumPostDeleteArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ForumPost.
     * @param {ForumPostUpdateArgs} args - Arguments to update one ForumPost.
     * @example
     * // Update one ForumPost
     * const forumPost = await prisma.forumPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumPostUpdateArgs>(args: SelectSubset<T, ForumPostUpdateArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ForumPosts.
     * @param {ForumPostDeleteManyArgs} args - Arguments to filter ForumPosts to delete.
     * @example
     * // Delete a few ForumPosts
     * const { count } = await prisma.forumPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumPostDeleteManyArgs>(args?: SelectSubset<T, ForumPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumPosts
     * const forumPost = await prisma.forumPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumPostUpdateManyArgs>(args: SelectSubset<T, ForumPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumPosts and returns the data updated in the database.
     * @param {ForumPostUpdateManyAndReturnArgs} args - Arguments to update many ForumPosts.
     * @example
     * // Update many ForumPosts
     * const forumPost = await prisma.forumPost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ForumPosts and only return the `id`
     * const forumPostWithIdOnly = await prisma.forumPost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ForumPostUpdateManyAndReturnArgs>(args: SelectSubset<T, ForumPostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ForumPost.
     * @param {ForumPostUpsertArgs} args - Arguments to update or create a ForumPost.
     * @example
     * // Update or create a ForumPost
     * const forumPost = await prisma.forumPost.upsert({
     *   create: {
     *     // ... data to create a ForumPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumPost we want to update
     *   }
     * })
     */
    upsert<T extends ForumPostUpsertArgs>(args: SelectSubset<T, ForumPostUpsertArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ForumPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostCountArgs} args - Arguments to filter ForumPosts to count.
     * @example
     * // Count the number of ForumPosts
     * const count = await prisma.forumPost.count({
     *   where: {
     *     // ... the filter for the ForumPosts we want to count
     *   }
     * })
    **/
    count<T extends ForumPostCountArgs>(
      args?: Subset<T, ForumPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumPostAggregateArgs>(args: Subset<T, ForumPostAggregateArgs>): Prisma.PrismaPromise<GetForumPostAggregateType<T>>

    /**
     * Group by ForumPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumPostGroupByArgs['orderBy'] }
        : { orderBy?: ForumPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForumPost model
   */
  readonly fields: ForumPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends ForumCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForumCategoryDefaultArgs<ExtArgs>>): Prisma__ForumCategoryClient<$Result.GetResult<Prisma.$ForumCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    comments<T extends ForumPost$commentsArgs<ExtArgs> = {}>(args?: Subset<T, ForumPost$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForumPost model
   */
  interface ForumPostFieldRefs {
    readonly id: FieldRef<"ForumPost", 'String'>
    readonly title: FieldRef<"ForumPost", 'String'>
    readonly content: FieldRef<"ForumPost", 'String'>
    readonly slug: FieldRef<"ForumPost", 'String'>
    readonly authorId: FieldRef<"ForumPost", 'String'>
    readonly categoryId: FieldRef<"ForumPost", 'String'>
    readonly likes: FieldRef<"ForumPost", 'Int'>
    readonly views: FieldRef<"ForumPost", 'Int'>
    readonly isPinned: FieldRef<"ForumPost", 'Boolean'>
    readonly isSolved: FieldRef<"ForumPost", 'Boolean'>
    readonly createdAt: FieldRef<"ForumPost", 'DateTime'>
    readonly updatedAt: FieldRef<"ForumPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ForumPost findUnique
   */
  export type ForumPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where: ForumPostWhereUniqueInput
  }

  /**
   * ForumPost findUniqueOrThrow
   */
  export type ForumPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where: ForumPostWhereUniqueInput
  }

  /**
   * ForumPost findFirst
   */
  export type ForumPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumPosts.
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumPosts.
     */
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * ForumPost findFirstOrThrow
   */
  export type ForumPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumPosts.
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumPosts.
     */
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * ForumPost findMany
   */
  export type ForumPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPosts to fetch.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumPosts.
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * ForumPost create
   */
  export type ForumPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumPost.
     */
    data: XOR<ForumPostCreateInput, ForumPostUncheckedCreateInput>
  }

  /**
   * ForumPost createMany
   */
  export type ForumPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumPosts.
     */
    data: ForumPostCreateManyInput | ForumPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForumPost createManyAndReturn
   */
  export type ForumPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * The data used to create many ForumPosts.
     */
    data: ForumPostCreateManyInput | ForumPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumPost update
   */
  export type ForumPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumPost.
     */
    data: XOR<ForumPostUpdateInput, ForumPostUncheckedUpdateInput>
    /**
     * Choose, which ForumPost to update.
     */
    where: ForumPostWhereUniqueInput
  }

  /**
   * ForumPost updateMany
   */
  export type ForumPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumPosts.
     */
    data: XOR<ForumPostUpdateManyMutationInput, ForumPostUncheckedUpdateManyInput>
    /**
     * Filter which ForumPosts to update
     */
    where?: ForumPostWhereInput
    /**
     * Limit how many ForumPosts to update.
     */
    limit?: number
  }

  /**
   * ForumPost updateManyAndReturn
   */
  export type ForumPostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * The data used to update ForumPosts.
     */
    data: XOR<ForumPostUpdateManyMutationInput, ForumPostUncheckedUpdateManyInput>
    /**
     * Filter which ForumPosts to update
     */
    where?: ForumPostWhereInput
    /**
     * Limit how many ForumPosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumPost upsert
   */
  export type ForumPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumPost to update in case it exists.
     */
    where: ForumPostWhereUniqueInput
    /**
     * In case the ForumPost found by the `where` argument doesn't exist, create a new ForumPost with this data.
     */
    create: XOR<ForumPostCreateInput, ForumPostUncheckedCreateInput>
    /**
     * In case the ForumPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumPostUpdateInput, ForumPostUncheckedUpdateInput>
  }

  /**
   * ForumPost delete
   */
  export type ForumPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter which ForumPost to delete.
     */
    where: ForumPostWhereUniqueInput
  }

  /**
   * ForumPost deleteMany
   */
  export type ForumPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumPosts to delete
     */
    where?: ForumPostWhereInput
    /**
     * Limit how many ForumPosts to delete.
     */
    limit?: number
  }

  /**
   * ForumPost.comments
   */
  export type ForumPost$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComment
     */
    omit?: ForumCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    where?: ForumCommentWhereInput
    orderBy?: ForumCommentOrderByWithRelationInput | ForumCommentOrderByWithRelationInput[]
    cursor?: ForumCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumCommentScalarFieldEnum | ForumCommentScalarFieldEnum[]
  }

  /**
   * ForumPost without action
   */
  export type ForumPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumPost
     */
    omit?: ForumPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
  }


  /**
   * Model ForumComment
   */

  export type AggregateForumComment = {
    _count: ForumCommentCountAggregateOutputType | null
    _avg: ForumCommentAvgAggregateOutputType | null
    _sum: ForumCommentSumAggregateOutputType | null
    _min: ForumCommentMinAggregateOutputType | null
    _max: ForumCommentMaxAggregateOutputType | null
  }

  export type ForumCommentAvgAggregateOutputType = {
    likes: number | null
  }

  export type ForumCommentSumAggregateOutputType = {
    likes: number | null
  }

  export type ForumCommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    postId: string | null
    authorId: string | null
    parentId: string | null
    isSolution: boolean | null
    likes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumCommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    postId: string | null
    authorId: string | null
    parentId: string | null
    isSolution: boolean | null
    likes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumCommentCountAggregateOutputType = {
    id: number
    content: number
    postId: number
    authorId: number
    parentId: number
    isSolution: number
    likes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ForumCommentAvgAggregateInputType = {
    likes?: true
  }

  export type ForumCommentSumAggregateInputType = {
    likes?: true
  }

  export type ForumCommentMinAggregateInputType = {
    id?: true
    content?: true
    postId?: true
    authorId?: true
    parentId?: true
    isSolution?: true
    likes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumCommentMaxAggregateInputType = {
    id?: true
    content?: true
    postId?: true
    authorId?: true
    parentId?: true
    isSolution?: true
    likes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumCommentCountAggregateInputType = {
    id?: true
    content?: true
    postId?: true
    authorId?: true
    parentId?: true
    isSolution?: true
    likes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ForumCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumComment to aggregate.
     */
    where?: ForumCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumComments to fetch.
     */
    orderBy?: ForumCommentOrderByWithRelationInput | ForumCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumComments
    **/
    _count?: true | ForumCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ForumCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ForumCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumCommentMaxAggregateInputType
  }

  export type GetForumCommentAggregateType<T extends ForumCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateForumComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumComment[P]>
      : GetScalarType<T[P], AggregateForumComment[P]>
  }




  export type ForumCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumCommentWhereInput
    orderBy?: ForumCommentOrderByWithAggregationInput | ForumCommentOrderByWithAggregationInput[]
    by: ForumCommentScalarFieldEnum[] | ForumCommentScalarFieldEnum
    having?: ForumCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumCommentCountAggregateInputType | true
    _avg?: ForumCommentAvgAggregateInputType
    _sum?: ForumCommentSumAggregateInputType
    _min?: ForumCommentMinAggregateInputType
    _max?: ForumCommentMaxAggregateInputType
  }

  export type ForumCommentGroupByOutputType = {
    id: string
    content: string
    postId: string
    authorId: string
    parentId: string | null
    isSolution: boolean
    likes: number
    createdAt: Date
    updatedAt: Date
    _count: ForumCommentCountAggregateOutputType | null
    _avg: ForumCommentAvgAggregateOutputType | null
    _sum: ForumCommentSumAggregateOutputType | null
    _min: ForumCommentMinAggregateOutputType | null
    _max: ForumCommentMaxAggregateOutputType | null
  }

  type GetForumCommentGroupByPayload<T extends ForumCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumCommentGroupByOutputType[P]>
            : GetScalarType<T[P], ForumCommentGroupByOutputType[P]>
        }
      >
    >


  export type ForumCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    postId?: boolean
    authorId?: boolean
    parentId?: boolean
    isSolution?: boolean
    likes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | ForumPostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumComment"]>

  export type ForumCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    postId?: boolean
    authorId?: boolean
    parentId?: boolean
    isSolution?: boolean
    likes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | ForumPostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumComment"]>

  export type ForumCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    postId?: boolean
    authorId?: boolean
    parentId?: boolean
    isSolution?: boolean
    likes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | ForumPostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumComment"]>

  export type ForumCommentSelectScalar = {
    id?: boolean
    content?: boolean
    postId?: boolean
    authorId?: boolean
    parentId?: boolean
    isSolution?: boolean
    likes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ForumCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "postId" | "authorId" | "parentId" | "isSolution" | "likes" | "createdAt" | "updatedAt", ExtArgs["result"]["forumComment"]>
  export type ForumCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | ForumPostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ForumCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | ForumPostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ForumCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | ForumPostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ForumCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForumComment"
    objects: {
      post: Prisma.$ForumPostPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      postId: string
      authorId: string
      parentId: string | null
      isSolution: boolean
      likes: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["forumComment"]>
    composites: {}
  }

  type ForumCommentGetPayload<S extends boolean | null | undefined | ForumCommentDefaultArgs> = $Result.GetResult<Prisma.$ForumCommentPayload, S>

  type ForumCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ForumCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ForumCommentCountAggregateInputType | true
    }

  export interface ForumCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumComment'], meta: { name: 'ForumComment' } }
    /**
     * Find zero or one ForumComment that matches the filter.
     * @param {ForumCommentFindUniqueArgs} args - Arguments to find a ForumComment
     * @example
     * // Get one ForumComment
     * const forumComment = await prisma.forumComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumCommentFindUniqueArgs>(args: SelectSubset<T, ForumCommentFindUniqueArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ForumComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ForumCommentFindUniqueOrThrowArgs} args - Arguments to find a ForumComment
     * @example
     * // Get one ForumComment
     * const forumComment = await prisma.forumComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentFindFirstArgs} args - Arguments to find a ForumComment
     * @example
     * // Get one ForumComment
     * const forumComment = await prisma.forumComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumCommentFindFirstArgs>(args?: SelectSubset<T, ForumCommentFindFirstArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ForumComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentFindFirstOrThrowArgs} args - Arguments to find a ForumComment
     * @example
     * // Get one ForumComment
     * const forumComment = await prisma.forumComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ForumComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumComments
     * const forumComments = await prisma.forumComment.findMany()
     * 
     * // Get first 10 ForumComments
     * const forumComments = await prisma.forumComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumCommentWithIdOnly = await prisma.forumComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumCommentFindManyArgs>(args?: SelectSubset<T, ForumCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ForumComment.
     * @param {ForumCommentCreateArgs} args - Arguments to create a ForumComment.
     * @example
     * // Create one ForumComment
     * const ForumComment = await prisma.forumComment.create({
     *   data: {
     *     // ... data to create a ForumComment
     *   }
     * })
     * 
     */
    create<T extends ForumCommentCreateArgs>(args: SelectSubset<T, ForumCommentCreateArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ForumComments.
     * @param {ForumCommentCreateManyArgs} args - Arguments to create many ForumComments.
     * @example
     * // Create many ForumComments
     * const forumComment = await prisma.forumComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumCommentCreateManyArgs>(args?: SelectSubset<T, ForumCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumComments and returns the data saved in the database.
     * @param {ForumCommentCreateManyAndReturnArgs} args - Arguments to create many ForumComments.
     * @example
     * // Create many ForumComments
     * const forumComment = await prisma.forumComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumComments and only return the `id`
     * const forumCommentWithIdOnly = await prisma.forumComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ForumComment.
     * @param {ForumCommentDeleteArgs} args - Arguments to delete one ForumComment.
     * @example
     * // Delete one ForumComment
     * const ForumComment = await prisma.forumComment.delete({
     *   where: {
     *     // ... filter to delete one ForumComment
     *   }
     * })
     * 
     */
    delete<T extends ForumCommentDeleteArgs>(args: SelectSubset<T, ForumCommentDeleteArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ForumComment.
     * @param {ForumCommentUpdateArgs} args - Arguments to update one ForumComment.
     * @example
     * // Update one ForumComment
     * const forumComment = await prisma.forumComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumCommentUpdateArgs>(args: SelectSubset<T, ForumCommentUpdateArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ForumComments.
     * @param {ForumCommentDeleteManyArgs} args - Arguments to filter ForumComments to delete.
     * @example
     * // Delete a few ForumComments
     * const { count } = await prisma.forumComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumCommentDeleteManyArgs>(args?: SelectSubset<T, ForumCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumComments
     * const forumComment = await prisma.forumComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumCommentUpdateManyArgs>(args: SelectSubset<T, ForumCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumComments and returns the data updated in the database.
     * @param {ForumCommentUpdateManyAndReturnArgs} args - Arguments to update many ForumComments.
     * @example
     * // Update many ForumComments
     * const forumComment = await prisma.forumComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ForumComments and only return the `id`
     * const forumCommentWithIdOnly = await prisma.forumComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ForumCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, ForumCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ForumComment.
     * @param {ForumCommentUpsertArgs} args - Arguments to update or create a ForumComment.
     * @example
     * // Update or create a ForumComment
     * const forumComment = await prisma.forumComment.upsert({
     *   create: {
     *     // ... data to create a ForumComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumComment we want to update
     *   }
     * })
     */
    upsert<T extends ForumCommentUpsertArgs>(args: SelectSubset<T, ForumCommentUpsertArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ForumComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentCountArgs} args - Arguments to filter ForumComments to count.
     * @example
     * // Count the number of ForumComments
     * const count = await prisma.forumComment.count({
     *   where: {
     *     // ... the filter for the ForumComments we want to count
     *   }
     * })
    **/
    count<T extends ForumCommentCountArgs>(
      args?: Subset<T, ForumCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumCommentAggregateArgs>(args: Subset<T, ForumCommentAggregateArgs>): Prisma.PrismaPromise<GetForumCommentAggregateType<T>>

    /**
     * Group by ForumComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumCommentGroupByArgs['orderBy'] }
        : { orderBy?: ForumCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForumComment model
   */
  readonly fields: ForumCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends ForumPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForumPostDefaultArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForumComment model
   */
  interface ForumCommentFieldRefs {
    readonly id: FieldRef<"ForumComment", 'String'>
    readonly content: FieldRef<"ForumComment", 'String'>
    readonly postId: FieldRef<"ForumComment", 'String'>
    readonly authorId: FieldRef<"ForumComment", 'String'>
    readonly parentId: FieldRef<"ForumComment", 'String'>
    readonly isSolution: FieldRef<"ForumComment", 'Boolean'>
    readonly likes: FieldRef<"ForumComment", 'Int'>
    readonly createdAt: FieldRef<"ForumComment", 'DateTime'>
    readonly updatedAt: FieldRef<"ForumComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ForumComment findUnique
   */
  export type ForumCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComment
     */
    omit?: ForumCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * Filter, which ForumComment to fetch.
     */
    where: ForumCommentWhereUniqueInput
  }

  /**
   * ForumComment findUniqueOrThrow
   */
  export type ForumCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComment
     */
    omit?: ForumCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * Filter, which ForumComment to fetch.
     */
    where: ForumCommentWhereUniqueInput
  }

  /**
   * ForumComment findFirst
   */
  export type ForumCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComment
     */
    omit?: ForumCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * Filter, which ForumComment to fetch.
     */
    where?: ForumCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumComments to fetch.
     */
    orderBy?: ForumCommentOrderByWithRelationInput | ForumCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumComments.
     */
    cursor?: ForumCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumComments.
     */
    distinct?: ForumCommentScalarFieldEnum | ForumCommentScalarFieldEnum[]
  }

  /**
   * ForumComment findFirstOrThrow
   */
  export type ForumCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComment
     */
    omit?: ForumCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * Filter, which ForumComment to fetch.
     */
    where?: ForumCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumComments to fetch.
     */
    orderBy?: ForumCommentOrderByWithRelationInput | ForumCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumComments.
     */
    cursor?: ForumCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumComments.
     */
    distinct?: ForumCommentScalarFieldEnum | ForumCommentScalarFieldEnum[]
  }

  /**
   * ForumComment findMany
   */
  export type ForumCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComment
     */
    omit?: ForumCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * Filter, which ForumComments to fetch.
     */
    where?: ForumCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumComments to fetch.
     */
    orderBy?: ForumCommentOrderByWithRelationInput | ForumCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumComments.
     */
    cursor?: ForumCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumComments.
     */
    skip?: number
    distinct?: ForumCommentScalarFieldEnum | ForumCommentScalarFieldEnum[]
  }

  /**
   * ForumComment create
   */
  export type ForumCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComment
     */
    omit?: ForumCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumComment.
     */
    data: XOR<ForumCommentCreateInput, ForumCommentUncheckedCreateInput>
  }

  /**
   * ForumComment createMany
   */
  export type ForumCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumComments.
     */
    data: ForumCommentCreateManyInput | ForumCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForumComment createManyAndReturn
   */
  export type ForumCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComment
     */
    omit?: ForumCommentOmit<ExtArgs> | null
    /**
     * The data used to create many ForumComments.
     */
    data: ForumCommentCreateManyInput | ForumCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumComment update
   */
  export type ForumCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComment
     */
    omit?: ForumCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumComment.
     */
    data: XOR<ForumCommentUpdateInput, ForumCommentUncheckedUpdateInput>
    /**
     * Choose, which ForumComment to update.
     */
    where: ForumCommentWhereUniqueInput
  }

  /**
   * ForumComment updateMany
   */
  export type ForumCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumComments.
     */
    data: XOR<ForumCommentUpdateManyMutationInput, ForumCommentUncheckedUpdateManyInput>
    /**
     * Filter which ForumComments to update
     */
    where?: ForumCommentWhereInput
    /**
     * Limit how many ForumComments to update.
     */
    limit?: number
  }

  /**
   * ForumComment updateManyAndReturn
   */
  export type ForumCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComment
     */
    omit?: ForumCommentOmit<ExtArgs> | null
    /**
     * The data used to update ForumComments.
     */
    data: XOR<ForumCommentUpdateManyMutationInput, ForumCommentUncheckedUpdateManyInput>
    /**
     * Filter which ForumComments to update
     */
    where?: ForumCommentWhereInput
    /**
     * Limit how many ForumComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumComment upsert
   */
  export type ForumCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComment
     */
    omit?: ForumCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumComment to update in case it exists.
     */
    where: ForumCommentWhereUniqueInput
    /**
     * In case the ForumComment found by the `where` argument doesn't exist, create a new ForumComment with this data.
     */
    create: XOR<ForumCommentCreateInput, ForumCommentUncheckedCreateInput>
    /**
     * In case the ForumComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumCommentUpdateInput, ForumCommentUncheckedUpdateInput>
  }

  /**
   * ForumComment delete
   */
  export type ForumCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComment
     */
    omit?: ForumCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * Filter which ForumComment to delete.
     */
    where: ForumCommentWhereUniqueInput
  }

  /**
   * ForumComment deleteMany
   */
  export type ForumCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumComments to delete
     */
    where?: ForumCommentWhereInput
    /**
     * Limit how many ForumComments to delete.
     */
    limit?: number
  }

  /**
   * ForumComment without action
   */
  export type ForumCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ForumComment
     */
    omit?: ForumCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    name: string | null
    isGroup: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    isGroup: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    name: number
    isGroup: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    name?: true
    isGroup?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    name?: true
    isGroup?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    name?: true
    isGroup?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    name: string | null
    isGroup: boolean
    createdAt: Date
    updatedAt: Date
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isGroup?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    participants?: boolean | Conversation$participantsArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isGroup?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isGroup?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    name?: boolean
    isGroup?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "isGroup" | "createdAt" | "updatedAt", ExtArgs["result"]["conversation"]>
  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | Conversation$participantsArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      participants: Prisma.$UserPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      isGroup: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {ConversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participants<T extends Conversation$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly name: FieldRef<"Conversation", 'String'>
    readonly isGroup: FieldRef<"Conversation", 'Boolean'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation updateManyAndReturn
   */
  export type ConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to delete.
     */
    limit?: number
  }

  /**
   * Conversation.participants
   */
  export type Conversation$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    senderId: number
    content: number
    readBy: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    readBy?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    conversationId: string
    senderId: string
    content: string
    readBy: JsonValue | null
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    readBy?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    readBy?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    readBy?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    readBy?: boolean
    createdAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "senderId" | "content" | "readBy" | "createdAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      senderId: string
      content: string
      readBy: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly readBy: FieldRef<"Message", 'Json'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Certificate
   */

  export type AggregateCertificate = {
    _count: CertificateCountAggregateOutputType | null
    _avg: CertificateAvgAggregateOutputType | null
    _sum: CertificateSumAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  export type CertificateAvgAggregateOutputType = {
    score: number | null
  }

  export type CertificateSumAggregateOutputType = {
    score: number | null
  }

  export type CertificateMinAggregateOutputType = {
    id: string | null
    uniqueId: string | null
    userId: string | null
    courseId: string | null
    enrollmentId: string | null
    studentName: string | null
    courseName: string | null
    courseCategory: string | null
    issueDate: Date | null
    expiryDate: Date | null
    templateId: string | null
    signatureUrl: string | null
    signatoryName: string | null
    signatoryTitle: string | null
    verificationUrl: string | null
    isValid: boolean | null
    grade: string | null
    score: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CertificateMaxAggregateOutputType = {
    id: string | null
    uniqueId: string | null
    userId: string | null
    courseId: string | null
    enrollmentId: string | null
    studentName: string | null
    courseName: string | null
    courseCategory: string | null
    issueDate: Date | null
    expiryDate: Date | null
    templateId: string | null
    signatureUrl: string | null
    signatoryName: string | null
    signatoryTitle: string | null
    verificationUrl: string | null
    isValid: boolean | null
    grade: string | null
    score: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CertificateCountAggregateOutputType = {
    id: number
    uniqueId: number
    userId: number
    courseId: number
    enrollmentId: number
    studentName: number
    courseName: number
    courseCategory: number
    issueDate: number
    expiryDate: number
    templateId: number
    signatureUrl: number
    signatoryName: number
    signatoryTitle: number
    verificationUrl: number
    isValid: number
    grade: number
    score: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CertificateAvgAggregateInputType = {
    score?: true
  }

  export type CertificateSumAggregateInputType = {
    score?: true
  }

  export type CertificateMinAggregateInputType = {
    id?: true
    uniqueId?: true
    userId?: true
    courseId?: true
    enrollmentId?: true
    studentName?: true
    courseName?: true
    courseCategory?: true
    issueDate?: true
    expiryDate?: true
    templateId?: true
    signatureUrl?: true
    signatoryName?: true
    signatoryTitle?: true
    verificationUrl?: true
    isValid?: true
    grade?: true
    score?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CertificateMaxAggregateInputType = {
    id?: true
    uniqueId?: true
    userId?: true
    courseId?: true
    enrollmentId?: true
    studentName?: true
    courseName?: true
    courseCategory?: true
    issueDate?: true
    expiryDate?: true
    templateId?: true
    signatureUrl?: true
    signatoryName?: true
    signatoryTitle?: true
    verificationUrl?: true
    isValid?: true
    grade?: true
    score?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CertificateCountAggregateInputType = {
    id?: true
    uniqueId?: true
    userId?: true
    courseId?: true
    enrollmentId?: true
    studentName?: true
    courseName?: true
    courseCategory?: true
    issueDate?: true
    expiryDate?: true
    templateId?: true
    signatureUrl?: true
    signatoryName?: true
    signatoryTitle?: true
    verificationUrl?: true
    isValid?: true
    grade?: true
    score?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CertificateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificate to aggregate.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certificates
    **/
    _count?: true | CertificateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificateMaxAggregateInputType
  }

  export type GetCertificateAggregateType<T extends CertificateAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificate[P]>
      : GetScalarType<T[P], AggregateCertificate[P]>
  }




  export type CertificateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithAggregationInput | CertificateOrderByWithAggregationInput[]
    by: CertificateScalarFieldEnum[] | CertificateScalarFieldEnum
    having?: CertificateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificateCountAggregateInputType | true
    _avg?: CertificateAvgAggregateInputType
    _sum?: CertificateSumAggregateInputType
    _min?: CertificateMinAggregateInputType
    _max?: CertificateMaxAggregateInputType
  }

  export type CertificateGroupByOutputType = {
    id: string
    uniqueId: string
    userId: string
    courseId: string
    enrollmentId: string
    studentName: string
    courseName: string
    courseCategory: string | null
    issueDate: Date
    expiryDate: Date | null
    templateId: string | null
    signatureUrl: string | null
    signatoryName: string | null
    signatoryTitle: string | null
    verificationUrl: string | null
    isValid: boolean
    grade: string | null
    score: number | null
    createdAt: Date
    updatedAt: Date
    _count: CertificateCountAggregateOutputType | null
    _avg: CertificateAvgAggregateOutputType | null
    _sum: CertificateSumAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  type GetCertificateGroupByPayload<T extends CertificateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificateGroupByOutputType[P]>
            : GetScalarType<T[P], CertificateGroupByOutputType[P]>
        }
      >
    >


  export type CertificateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uniqueId?: boolean
    userId?: boolean
    courseId?: boolean
    enrollmentId?: boolean
    studentName?: boolean
    courseName?: boolean
    courseCategory?: boolean
    issueDate?: boolean
    expiryDate?: boolean
    templateId?: boolean
    signatureUrl?: boolean
    signatoryName?: boolean
    signatoryTitle?: boolean
    verificationUrl?: boolean
    isValid?: boolean
    grade?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | Certificate$templateArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uniqueId?: boolean
    userId?: boolean
    courseId?: boolean
    enrollmentId?: boolean
    studentName?: boolean
    courseName?: boolean
    courseCategory?: boolean
    issueDate?: boolean
    expiryDate?: boolean
    templateId?: boolean
    signatureUrl?: boolean
    signatoryName?: boolean
    signatoryTitle?: boolean
    verificationUrl?: boolean
    isValid?: boolean
    grade?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | Certificate$templateArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uniqueId?: boolean
    userId?: boolean
    courseId?: boolean
    enrollmentId?: boolean
    studentName?: boolean
    courseName?: boolean
    courseCategory?: boolean
    issueDate?: boolean
    expiryDate?: boolean
    templateId?: boolean
    signatureUrl?: boolean
    signatoryName?: boolean
    signatoryTitle?: boolean
    verificationUrl?: boolean
    isValid?: boolean
    grade?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | Certificate$templateArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectScalar = {
    id?: boolean
    uniqueId?: boolean
    userId?: boolean
    courseId?: boolean
    enrollmentId?: boolean
    studentName?: boolean
    courseName?: boolean
    courseCategory?: boolean
    issueDate?: boolean
    expiryDate?: boolean
    templateId?: boolean
    signatureUrl?: boolean
    signatoryName?: boolean
    signatoryTitle?: boolean
    verificationUrl?: boolean
    isValid?: boolean
    grade?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CertificateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uniqueId" | "userId" | "courseId" | "enrollmentId" | "studentName" | "courseName" | "courseCategory" | "issueDate" | "expiryDate" | "templateId" | "signatureUrl" | "signatoryName" | "signatoryTitle" | "verificationUrl" | "isValid" | "grade" | "score" | "createdAt" | "updatedAt", ExtArgs["result"]["certificate"]>
  export type CertificateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | Certificate$templateArgs<ExtArgs>
  }
  export type CertificateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | Certificate$templateArgs<ExtArgs>
  }
  export type CertificateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | Certificate$templateArgs<ExtArgs>
  }

  export type $CertificatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certificate"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      template: Prisma.$CertificateTemplatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uniqueId: string
      userId: string
      courseId: string
      enrollmentId: string
      studentName: string
      courseName: string
      courseCategory: string | null
      issueDate: Date
      expiryDate: Date | null
      templateId: string | null
      signatureUrl: string | null
      signatoryName: string | null
      signatoryTitle: string | null
      verificationUrl: string | null
      isValid: boolean
      grade: string | null
      score: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["certificate"]>
    composites: {}
  }

  type CertificateGetPayload<S extends boolean | null | undefined | CertificateDefaultArgs> = $Result.GetResult<Prisma.$CertificatePayload, S>

  type CertificateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CertificateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CertificateCountAggregateInputType | true
    }

  export interface CertificateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certificate'], meta: { name: 'Certificate' } }
    /**
     * Find zero or one Certificate that matches the filter.
     * @param {CertificateFindUniqueArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificateFindUniqueArgs>(args: SelectSubset<T, CertificateFindUniqueArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Certificate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CertificateFindUniqueOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificateFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certificate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificateFindFirstArgs>(args?: SelectSubset<T, CertificateFindFirstArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certificate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificateFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificates
     * const certificates = await prisma.certificate.findMany()
     * 
     * // Get first 10 Certificates
     * const certificates = await prisma.certificate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificateWithIdOnly = await prisma.certificate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificateFindManyArgs>(args?: SelectSubset<T, CertificateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Certificate.
     * @param {CertificateCreateArgs} args - Arguments to create a Certificate.
     * @example
     * // Create one Certificate
     * const Certificate = await prisma.certificate.create({
     *   data: {
     *     // ... data to create a Certificate
     *   }
     * })
     * 
     */
    create<T extends CertificateCreateArgs>(args: SelectSubset<T, CertificateCreateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Certificates.
     * @param {CertificateCreateManyArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificateCreateManyArgs>(args?: SelectSubset<T, CertificateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certificates and returns the data saved in the database.
     * @param {CertificateCreateManyAndReturnArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certificates and only return the `id`
     * const certificateWithIdOnly = await prisma.certificate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificateCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Certificate.
     * @param {CertificateDeleteArgs} args - Arguments to delete one Certificate.
     * @example
     * // Delete one Certificate
     * const Certificate = await prisma.certificate.delete({
     *   where: {
     *     // ... filter to delete one Certificate
     *   }
     * })
     * 
     */
    delete<T extends CertificateDeleteArgs>(args: SelectSubset<T, CertificateDeleteArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Certificate.
     * @param {CertificateUpdateArgs} args - Arguments to update one Certificate.
     * @example
     * // Update one Certificate
     * const certificate = await prisma.certificate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificateUpdateArgs>(args: SelectSubset<T, CertificateUpdateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Certificates.
     * @param {CertificateDeleteManyArgs} args - Arguments to filter Certificates to delete.
     * @example
     * // Delete a few Certificates
     * const { count } = await prisma.certificate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificateDeleteManyArgs>(args?: SelectSubset<T, CertificateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificateUpdateManyArgs>(args: SelectSubset<T, CertificateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates and returns the data updated in the database.
     * @param {CertificateUpdateManyAndReturnArgs} args - Arguments to update many Certificates.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Certificates and only return the `id`
     * const certificateWithIdOnly = await prisma.certificate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CertificateUpdateManyAndReturnArgs>(args: SelectSubset<T, CertificateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Certificate.
     * @param {CertificateUpsertArgs} args - Arguments to update or create a Certificate.
     * @example
     * // Update or create a Certificate
     * const certificate = await prisma.certificate.upsert({
     *   create: {
     *     // ... data to create a Certificate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificate we want to update
     *   }
     * })
     */
    upsert<T extends CertificateUpsertArgs>(args: SelectSubset<T, CertificateUpsertArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateCountArgs} args - Arguments to filter Certificates to count.
     * @example
     * // Count the number of Certificates
     * const count = await prisma.certificate.count({
     *   where: {
     *     // ... the filter for the Certificates we want to count
     *   }
     * })
    **/
    count<T extends CertificateCountArgs>(
      args?: Subset<T, CertificateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificateAggregateArgs>(args: Subset<T, CertificateAggregateArgs>): Prisma.PrismaPromise<GetCertificateAggregateType<T>>

    /**
     * Group by Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificateGroupByArgs['orderBy'] }
        : { orderBy?: CertificateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certificate model
   */
  readonly fields: CertificateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certificate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    template<T extends Certificate$templateArgs<ExtArgs> = {}>(args?: Subset<T, Certificate$templateArgs<ExtArgs>>): Prisma__CertificateTemplateClient<$Result.GetResult<Prisma.$CertificateTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Certificate model
   */
  interface CertificateFieldRefs {
    readonly id: FieldRef<"Certificate", 'String'>
    readonly uniqueId: FieldRef<"Certificate", 'String'>
    readonly userId: FieldRef<"Certificate", 'String'>
    readonly courseId: FieldRef<"Certificate", 'String'>
    readonly enrollmentId: FieldRef<"Certificate", 'String'>
    readonly studentName: FieldRef<"Certificate", 'String'>
    readonly courseName: FieldRef<"Certificate", 'String'>
    readonly courseCategory: FieldRef<"Certificate", 'String'>
    readonly issueDate: FieldRef<"Certificate", 'DateTime'>
    readonly expiryDate: FieldRef<"Certificate", 'DateTime'>
    readonly templateId: FieldRef<"Certificate", 'String'>
    readonly signatureUrl: FieldRef<"Certificate", 'String'>
    readonly signatoryName: FieldRef<"Certificate", 'String'>
    readonly signatoryTitle: FieldRef<"Certificate", 'String'>
    readonly verificationUrl: FieldRef<"Certificate", 'String'>
    readonly isValid: FieldRef<"Certificate", 'Boolean'>
    readonly grade: FieldRef<"Certificate", 'String'>
    readonly score: FieldRef<"Certificate", 'Float'>
    readonly createdAt: FieldRef<"Certificate", 'DateTime'>
    readonly updatedAt: FieldRef<"Certificate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Certificate findUnique
   */
  export type CertificateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findUniqueOrThrow
   */
  export type CertificateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findFirst
   */
  export type CertificateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findFirstOrThrow
   */
  export type CertificateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findMany
   */
  export type CertificateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificates to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate create
   */
  export type CertificateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to create a Certificate.
     */
    data: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
  }

  /**
   * Certificate createMany
   */
  export type CertificateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Certificate createManyAndReturn
   */
  export type CertificateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certificate update
   */
  export type CertificateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to update a Certificate.
     */
    data: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
    /**
     * Choose, which Certificate to update.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate updateMany
   */
  export type CertificateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput
    /**
     * Limit how many Certificates to update.
     */
    limit?: number
  }

  /**
   * Certificate updateManyAndReturn
   */
  export type CertificateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput
    /**
     * Limit how many Certificates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certificate upsert
   */
  export type CertificateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The filter to search for the Certificate to update in case it exists.
     */
    where: CertificateWhereUniqueInput
    /**
     * In case the Certificate found by the `where` argument doesn't exist, create a new Certificate with this data.
     */
    create: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
    /**
     * In case the Certificate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
  }

  /**
   * Certificate delete
   */
  export type CertificateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter which Certificate to delete.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate deleteMany
   */
  export type CertificateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificates to delete
     */
    where?: CertificateWhereInput
    /**
     * Limit how many Certificates to delete.
     */
    limit?: number
  }

  /**
   * Certificate.template
   */
  export type Certificate$templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateTemplate
     */
    select?: CertificateTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateTemplate
     */
    omit?: CertificateTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateTemplateInclude<ExtArgs> | null
    where?: CertificateTemplateWhereInput
  }

  /**
   * Certificate without action
   */
  export type CertificateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
  }


  /**
   * Model CertificateTemplate
   */

  export type AggregateCertificateTemplate = {
    _count: CertificateTemplateCountAggregateOutputType | null
    _min: CertificateTemplateMinAggregateOutputType | null
    _max: CertificateTemplateMaxAggregateOutputType | null
  }

  export type CertificateTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    designUrl: string | null
    previewUrl: string | null
    isDefault: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CertificateTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    designUrl: string | null
    previewUrl: string | null
    isDefault: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CertificateTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    designUrl: number
    previewUrl: number
    isDefault: number
    isActive: number
    layout: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CertificateTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    designUrl?: true
    previewUrl?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CertificateTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    designUrl?: true
    previewUrl?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CertificateTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    designUrl?: true
    previewUrl?: true
    isDefault?: true
    isActive?: true
    layout?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CertificateTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CertificateTemplate to aggregate.
     */
    where?: CertificateTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificateTemplates to fetch.
     */
    orderBy?: CertificateTemplateOrderByWithRelationInput | CertificateTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificateTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificateTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificateTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CertificateTemplates
    **/
    _count?: true | CertificateTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificateTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificateTemplateMaxAggregateInputType
  }

  export type GetCertificateTemplateAggregateType<T extends CertificateTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificateTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificateTemplate[P]>
      : GetScalarType<T[P], AggregateCertificateTemplate[P]>
  }




  export type CertificateTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateTemplateWhereInput
    orderBy?: CertificateTemplateOrderByWithAggregationInput | CertificateTemplateOrderByWithAggregationInput[]
    by: CertificateTemplateScalarFieldEnum[] | CertificateTemplateScalarFieldEnum
    having?: CertificateTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificateTemplateCountAggregateInputType | true
    _min?: CertificateTemplateMinAggregateInputType
    _max?: CertificateTemplateMaxAggregateInputType
  }

  export type CertificateTemplateGroupByOutputType = {
    id: string
    name: string
    description: string | null
    designUrl: string
    previewUrl: string | null
    isDefault: boolean
    isActive: boolean
    layout: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CertificateTemplateCountAggregateOutputType | null
    _min: CertificateTemplateMinAggregateOutputType | null
    _max: CertificateTemplateMaxAggregateOutputType | null
  }

  type GetCertificateTemplateGroupByPayload<T extends CertificateTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificateTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificateTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificateTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], CertificateTemplateGroupByOutputType[P]>
        }
      >
    >


  export type CertificateTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    designUrl?: boolean
    previewUrl?: boolean
    isDefault?: boolean
    isActive?: boolean
    layout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    certificates?: boolean | CertificateTemplate$certificatesArgs<ExtArgs>
    _count?: boolean | CertificateTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificateTemplate"]>

  export type CertificateTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    designUrl?: boolean
    previewUrl?: boolean
    isDefault?: boolean
    isActive?: boolean
    layout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["certificateTemplate"]>

  export type CertificateTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    designUrl?: boolean
    previewUrl?: boolean
    isDefault?: boolean
    isActive?: boolean
    layout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["certificateTemplate"]>

  export type CertificateTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    designUrl?: boolean
    previewUrl?: boolean
    isDefault?: boolean
    isActive?: boolean
    layout?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CertificateTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "designUrl" | "previewUrl" | "isDefault" | "isActive" | "layout" | "createdAt" | "updatedAt", ExtArgs["result"]["certificateTemplate"]>
  export type CertificateTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificates?: boolean | CertificateTemplate$certificatesArgs<ExtArgs>
    _count?: boolean | CertificateTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CertificateTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CertificateTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CertificateTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CertificateTemplate"
    objects: {
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      designUrl: string
      previewUrl: string | null
      isDefault: boolean
      isActive: boolean
      layout: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["certificateTemplate"]>
    composites: {}
  }

  type CertificateTemplateGetPayload<S extends boolean | null | undefined | CertificateTemplateDefaultArgs> = $Result.GetResult<Prisma.$CertificateTemplatePayload, S>

  type CertificateTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CertificateTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CertificateTemplateCountAggregateInputType | true
    }

  export interface CertificateTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CertificateTemplate'], meta: { name: 'CertificateTemplate' } }
    /**
     * Find zero or one CertificateTemplate that matches the filter.
     * @param {CertificateTemplateFindUniqueArgs} args - Arguments to find a CertificateTemplate
     * @example
     * // Get one CertificateTemplate
     * const certificateTemplate = await prisma.certificateTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificateTemplateFindUniqueArgs>(args: SelectSubset<T, CertificateTemplateFindUniqueArgs<ExtArgs>>): Prisma__CertificateTemplateClient<$Result.GetResult<Prisma.$CertificateTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CertificateTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CertificateTemplateFindUniqueOrThrowArgs} args - Arguments to find a CertificateTemplate
     * @example
     * // Get one CertificateTemplate
     * const certificateTemplate = await prisma.certificateTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificateTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificateTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificateTemplateClient<$Result.GetResult<Prisma.$CertificateTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CertificateTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateTemplateFindFirstArgs} args - Arguments to find a CertificateTemplate
     * @example
     * // Get one CertificateTemplate
     * const certificateTemplate = await prisma.certificateTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificateTemplateFindFirstArgs>(args?: SelectSubset<T, CertificateTemplateFindFirstArgs<ExtArgs>>): Prisma__CertificateTemplateClient<$Result.GetResult<Prisma.$CertificateTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CertificateTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateTemplateFindFirstOrThrowArgs} args - Arguments to find a CertificateTemplate
     * @example
     * // Get one CertificateTemplate
     * const certificateTemplate = await prisma.certificateTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificateTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificateTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificateTemplateClient<$Result.GetResult<Prisma.$CertificateTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CertificateTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CertificateTemplates
     * const certificateTemplates = await prisma.certificateTemplate.findMany()
     * 
     * // Get first 10 CertificateTemplates
     * const certificateTemplates = await prisma.certificateTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificateTemplateWithIdOnly = await prisma.certificateTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificateTemplateFindManyArgs>(args?: SelectSubset<T, CertificateTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificateTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CertificateTemplate.
     * @param {CertificateTemplateCreateArgs} args - Arguments to create a CertificateTemplate.
     * @example
     * // Create one CertificateTemplate
     * const CertificateTemplate = await prisma.certificateTemplate.create({
     *   data: {
     *     // ... data to create a CertificateTemplate
     *   }
     * })
     * 
     */
    create<T extends CertificateTemplateCreateArgs>(args: SelectSubset<T, CertificateTemplateCreateArgs<ExtArgs>>): Prisma__CertificateTemplateClient<$Result.GetResult<Prisma.$CertificateTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CertificateTemplates.
     * @param {CertificateTemplateCreateManyArgs} args - Arguments to create many CertificateTemplates.
     * @example
     * // Create many CertificateTemplates
     * const certificateTemplate = await prisma.certificateTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificateTemplateCreateManyArgs>(args?: SelectSubset<T, CertificateTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CertificateTemplates and returns the data saved in the database.
     * @param {CertificateTemplateCreateManyAndReturnArgs} args - Arguments to create many CertificateTemplates.
     * @example
     * // Create many CertificateTemplates
     * const certificateTemplate = await prisma.certificateTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CertificateTemplates and only return the `id`
     * const certificateTemplateWithIdOnly = await prisma.certificateTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificateTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificateTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificateTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CertificateTemplate.
     * @param {CertificateTemplateDeleteArgs} args - Arguments to delete one CertificateTemplate.
     * @example
     * // Delete one CertificateTemplate
     * const CertificateTemplate = await prisma.certificateTemplate.delete({
     *   where: {
     *     // ... filter to delete one CertificateTemplate
     *   }
     * })
     * 
     */
    delete<T extends CertificateTemplateDeleteArgs>(args: SelectSubset<T, CertificateTemplateDeleteArgs<ExtArgs>>): Prisma__CertificateTemplateClient<$Result.GetResult<Prisma.$CertificateTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CertificateTemplate.
     * @param {CertificateTemplateUpdateArgs} args - Arguments to update one CertificateTemplate.
     * @example
     * // Update one CertificateTemplate
     * const certificateTemplate = await prisma.certificateTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificateTemplateUpdateArgs>(args: SelectSubset<T, CertificateTemplateUpdateArgs<ExtArgs>>): Prisma__CertificateTemplateClient<$Result.GetResult<Prisma.$CertificateTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CertificateTemplates.
     * @param {CertificateTemplateDeleteManyArgs} args - Arguments to filter CertificateTemplates to delete.
     * @example
     * // Delete a few CertificateTemplates
     * const { count } = await prisma.certificateTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificateTemplateDeleteManyArgs>(args?: SelectSubset<T, CertificateTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CertificateTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CertificateTemplates
     * const certificateTemplate = await prisma.certificateTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificateTemplateUpdateManyArgs>(args: SelectSubset<T, CertificateTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CertificateTemplates and returns the data updated in the database.
     * @param {CertificateTemplateUpdateManyAndReturnArgs} args - Arguments to update many CertificateTemplates.
     * @example
     * // Update many CertificateTemplates
     * const certificateTemplate = await prisma.certificateTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CertificateTemplates and only return the `id`
     * const certificateTemplateWithIdOnly = await prisma.certificateTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CertificateTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, CertificateTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificateTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CertificateTemplate.
     * @param {CertificateTemplateUpsertArgs} args - Arguments to update or create a CertificateTemplate.
     * @example
     * // Update or create a CertificateTemplate
     * const certificateTemplate = await prisma.certificateTemplate.upsert({
     *   create: {
     *     // ... data to create a CertificateTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CertificateTemplate we want to update
     *   }
     * })
     */
    upsert<T extends CertificateTemplateUpsertArgs>(args: SelectSubset<T, CertificateTemplateUpsertArgs<ExtArgs>>): Prisma__CertificateTemplateClient<$Result.GetResult<Prisma.$CertificateTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CertificateTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateTemplateCountArgs} args - Arguments to filter CertificateTemplates to count.
     * @example
     * // Count the number of CertificateTemplates
     * const count = await prisma.certificateTemplate.count({
     *   where: {
     *     // ... the filter for the CertificateTemplates we want to count
     *   }
     * })
    **/
    count<T extends CertificateTemplateCountArgs>(
      args?: Subset<T, CertificateTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificateTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CertificateTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificateTemplateAggregateArgs>(args: Subset<T, CertificateTemplateAggregateArgs>): Prisma.PrismaPromise<GetCertificateTemplateAggregateType<T>>

    /**
     * Group by CertificateTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificateTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificateTemplateGroupByArgs['orderBy'] }
        : { orderBy?: CertificateTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificateTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificateTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CertificateTemplate model
   */
  readonly fields: CertificateTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CertificateTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificateTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    certificates<T extends CertificateTemplate$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, CertificateTemplate$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CertificateTemplate model
   */
  interface CertificateTemplateFieldRefs {
    readonly id: FieldRef<"CertificateTemplate", 'String'>
    readonly name: FieldRef<"CertificateTemplate", 'String'>
    readonly description: FieldRef<"CertificateTemplate", 'String'>
    readonly designUrl: FieldRef<"CertificateTemplate", 'String'>
    readonly previewUrl: FieldRef<"CertificateTemplate", 'String'>
    readonly isDefault: FieldRef<"CertificateTemplate", 'Boolean'>
    readonly isActive: FieldRef<"CertificateTemplate", 'Boolean'>
    readonly layout: FieldRef<"CertificateTemplate", 'Json'>
    readonly createdAt: FieldRef<"CertificateTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"CertificateTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CertificateTemplate findUnique
   */
  export type CertificateTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateTemplate
     */
    select?: CertificateTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateTemplate
     */
    omit?: CertificateTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateTemplateInclude<ExtArgs> | null
    /**
     * Filter, which CertificateTemplate to fetch.
     */
    where: CertificateTemplateWhereUniqueInput
  }

  /**
   * CertificateTemplate findUniqueOrThrow
   */
  export type CertificateTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateTemplate
     */
    select?: CertificateTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateTemplate
     */
    omit?: CertificateTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateTemplateInclude<ExtArgs> | null
    /**
     * Filter, which CertificateTemplate to fetch.
     */
    where: CertificateTemplateWhereUniqueInput
  }

  /**
   * CertificateTemplate findFirst
   */
  export type CertificateTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateTemplate
     */
    select?: CertificateTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateTemplate
     */
    omit?: CertificateTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateTemplateInclude<ExtArgs> | null
    /**
     * Filter, which CertificateTemplate to fetch.
     */
    where?: CertificateTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificateTemplates to fetch.
     */
    orderBy?: CertificateTemplateOrderByWithRelationInput | CertificateTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CertificateTemplates.
     */
    cursor?: CertificateTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificateTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificateTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CertificateTemplates.
     */
    distinct?: CertificateTemplateScalarFieldEnum | CertificateTemplateScalarFieldEnum[]
  }

  /**
   * CertificateTemplate findFirstOrThrow
   */
  export type CertificateTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateTemplate
     */
    select?: CertificateTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateTemplate
     */
    omit?: CertificateTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateTemplateInclude<ExtArgs> | null
    /**
     * Filter, which CertificateTemplate to fetch.
     */
    where?: CertificateTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificateTemplates to fetch.
     */
    orderBy?: CertificateTemplateOrderByWithRelationInput | CertificateTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CertificateTemplates.
     */
    cursor?: CertificateTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificateTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificateTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CertificateTemplates.
     */
    distinct?: CertificateTemplateScalarFieldEnum | CertificateTemplateScalarFieldEnum[]
  }

  /**
   * CertificateTemplate findMany
   */
  export type CertificateTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateTemplate
     */
    select?: CertificateTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateTemplate
     */
    omit?: CertificateTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateTemplateInclude<ExtArgs> | null
    /**
     * Filter, which CertificateTemplates to fetch.
     */
    where?: CertificateTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificateTemplates to fetch.
     */
    orderBy?: CertificateTemplateOrderByWithRelationInput | CertificateTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CertificateTemplates.
     */
    cursor?: CertificateTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificateTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificateTemplates.
     */
    skip?: number
    distinct?: CertificateTemplateScalarFieldEnum | CertificateTemplateScalarFieldEnum[]
  }

  /**
   * CertificateTemplate create
   */
  export type CertificateTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateTemplate
     */
    select?: CertificateTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateTemplate
     */
    omit?: CertificateTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a CertificateTemplate.
     */
    data: XOR<CertificateTemplateCreateInput, CertificateTemplateUncheckedCreateInput>
  }

  /**
   * CertificateTemplate createMany
   */
  export type CertificateTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CertificateTemplates.
     */
    data: CertificateTemplateCreateManyInput | CertificateTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CertificateTemplate createManyAndReturn
   */
  export type CertificateTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateTemplate
     */
    select?: CertificateTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateTemplate
     */
    omit?: CertificateTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many CertificateTemplates.
     */
    data: CertificateTemplateCreateManyInput | CertificateTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CertificateTemplate update
   */
  export type CertificateTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateTemplate
     */
    select?: CertificateTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateTemplate
     */
    omit?: CertificateTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a CertificateTemplate.
     */
    data: XOR<CertificateTemplateUpdateInput, CertificateTemplateUncheckedUpdateInput>
    /**
     * Choose, which CertificateTemplate to update.
     */
    where: CertificateTemplateWhereUniqueInput
  }

  /**
   * CertificateTemplate updateMany
   */
  export type CertificateTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CertificateTemplates.
     */
    data: XOR<CertificateTemplateUpdateManyMutationInput, CertificateTemplateUncheckedUpdateManyInput>
    /**
     * Filter which CertificateTemplates to update
     */
    where?: CertificateTemplateWhereInput
    /**
     * Limit how many CertificateTemplates to update.
     */
    limit?: number
  }

  /**
   * CertificateTemplate updateManyAndReturn
   */
  export type CertificateTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateTemplate
     */
    select?: CertificateTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateTemplate
     */
    omit?: CertificateTemplateOmit<ExtArgs> | null
    /**
     * The data used to update CertificateTemplates.
     */
    data: XOR<CertificateTemplateUpdateManyMutationInput, CertificateTemplateUncheckedUpdateManyInput>
    /**
     * Filter which CertificateTemplates to update
     */
    where?: CertificateTemplateWhereInput
    /**
     * Limit how many CertificateTemplates to update.
     */
    limit?: number
  }

  /**
   * CertificateTemplate upsert
   */
  export type CertificateTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateTemplate
     */
    select?: CertificateTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateTemplate
     */
    omit?: CertificateTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the CertificateTemplate to update in case it exists.
     */
    where: CertificateTemplateWhereUniqueInput
    /**
     * In case the CertificateTemplate found by the `where` argument doesn't exist, create a new CertificateTemplate with this data.
     */
    create: XOR<CertificateTemplateCreateInput, CertificateTemplateUncheckedCreateInput>
    /**
     * In case the CertificateTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificateTemplateUpdateInput, CertificateTemplateUncheckedUpdateInput>
  }

  /**
   * CertificateTemplate delete
   */
  export type CertificateTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateTemplate
     */
    select?: CertificateTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateTemplate
     */
    omit?: CertificateTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateTemplateInclude<ExtArgs> | null
    /**
     * Filter which CertificateTemplate to delete.
     */
    where: CertificateTemplateWhereUniqueInput
  }

  /**
   * CertificateTemplate deleteMany
   */
  export type CertificateTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CertificateTemplates to delete
     */
    where?: CertificateTemplateWhereInput
    /**
     * Limit how many CertificateTemplates to delete.
     */
    limit?: number
  }

  /**
   * CertificateTemplate.certificates
   */
  export type CertificateTemplate$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * CertificateTemplate without action
   */
  export type CertificateTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateTemplate
     */
    select?: CertificateTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateTemplate
     */
    omit?: CertificateTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateTemplateInclude<ExtArgs> | null
  }


  /**
   * Model CertificateSettings
   */

  export type AggregateCertificateSettings = {
    _count: CertificateSettingsCountAggregateOutputType | null
    _avg: CertificateSettingsAvgAggregateOutputType | null
    _sum: CertificateSettingsSumAggregateOutputType | null
    _min: CertificateSettingsMinAggregateOutputType | null
    _max: CertificateSettingsMaxAggregateOutputType | null
  }

  export type CertificateSettingsAvgAggregateOutputType = {
    sequenceDigits: number | null
    currentSequence: number | null
    defaultValidityMonths: number | null
  }

  export type CertificateSettingsSumAggregateOutputType = {
    sequenceDigits: number | null
    currentSequence: number | null
    defaultValidityMonths: number | null
  }

  export type CertificateSettingsMinAggregateOutputType = {
    id: string | null
    instituteId: string | null
    prefix: string | null
    yearInId: boolean | null
    sequenceDigits: number | null
    currentSequence: number | null
    defaultSignatureUrl: string | null
    defaultSignatoryName: string | null
    defaultSignatoryTitle: string | null
    signaturePosition: string | null
    logoPosition: string | null
    logoSize: string | null
    signatureSize: string | null
    borderStyle: string | null
    backgroundUrl: string | null
    defaultValidityMonths: number | null
    instituteName: string | null
    instituteLogoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CertificateSettingsMaxAggregateOutputType = {
    id: string | null
    instituteId: string | null
    prefix: string | null
    yearInId: boolean | null
    sequenceDigits: number | null
    currentSequence: number | null
    defaultSignatureUrl: string | null
    defaultSignatoryName: string | null
    defaultSignatoryTitle: string | null
    signaturePosition: string | null
    logoPosition: string | null
    logoSize: string | null
    signatureSize: string | null
    borderStyle: string | null
    backgroundUrl: string | null
    defaultValidityMonths: number | null
    instituteName: string | null
    instituteLogoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CertificateSettingsCountAggregateOutputType = {
    id: number
    instituteId: number
    prefix: number
    yearInId: number
    sequenceDigits: number
    currentSequence: number
    defaultSignatureUrl: number
    defaultSignatoryName: number
    defaultSignatoryTitle: number
    signaturePosition: number
    logoPosition: number
    logoSize: number
    signatureSize: number
    borderStyle: number
    backgroundUrl: number
    defaultValidityMonths: number
    instituteName: number
    instituteLogoUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CertificateSettingsAvgAggregateInputType = {
    sequenceDigits?: true
    currentSequence?: true
    defaultValidityMonths?: true
  }

  export type CertificateSettingsSumAggregateInputType = {
    sequenceDigits?: true
    currentSequence?: true
    defaultValidityMonths?: true
  }

  export type CertificateSettingsMinAggregateInputType = {
    id?: true
    instituteId?: true
    prefix?: true
    yearInId?: true
    sequenceDigits?: true
    currentSequence?: true
    defaultSignatureUrl?: true
    defaultSignatoryName?: true
    defaultSignatoryTitle?: true
    signaturePosition?: true
    logoPosition?: true
    logoSize?: true
    signatureSize?: true
    borderStyle?: true
    backgroundUrl?: true
    defaultValidityMonths?: true
    instituteName?: true
    instituteLogoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CertificateSettingsMaxAggregateInputType = {
    id?: true
    instituteId?: true
    prefix?: true
    yearInId?: true
    sequenceDigits?: true
    currentSequence?: true
    defaultSignatureUrl?: true
    defaultSignatoryName?: true
    defaultSignatoryTitle?: true
    signaturePosition?: true
    logoPosition?: true
    logoSize?: true
    signatureSize?: true
    borderStyle?: true
    backgroundUrl?: true
    defaultValidityMonths?: true
    instituteName?: true
    instituteLogoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CertificateSettingsCountAggregateInputType = {
    id?: true
    instituteId?: true
    prefix?: true
    yearInId?: true
    sequenceDigits?: true
    currentSequence?: true
    defaultSignatureUrl?: true
    defaultSignatoryName?: true
    defaultSignatoryTitle?: true
    signaturePosition?: true
    logoPosition?: true
    logoSize?: true
    signatureSize?: true
    borderStyle?: true
    backgroundUrl?: true
    defaultValidityMonths?: true
    instituteName?: true
    instituteLogoUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CertificateSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CertificateSettings to aggregate.
     */
    where?: CertificateSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificateSettings to fetch.
     */
    orderBy?: CertificateSettingsOrderByWithRelationInput | CertificateSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificateSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificateSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificateSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CertificateSettings
    **/
    _count?: true | CertificateSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificateSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificateSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificateSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificateSettingsMaxAggregateInputType
  }

  export type GetCertificateSettingsAggregateType<T extends CertificateSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificateSettings[P]>
      : GetScalarType<T[P], AggregateCertificateSettings[P]>
  }




  export type CertificateSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateSettingsWhereInput
    orderBy?: CertificateSettingsOrderByWithAggregationInput | CertificateSettingsOrderByWithAggregationInput[]
    by: CertificateSettingsScalarFieldEnum[] | CertificateSettingsScalarFieldEnum
    having?: CertificateSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificateSettingsCountAggregateInputType | true
    _avg?: CertificateSettingsAvgAggregateInputType
    _sum?: CertificateSettingsSumAggregateInputType
    _min?: CertificateSettingsMinAggregateInputType
    _max?: CertificateSettingsMaxAggregateInputType
  }

  export type CertificateSettingsGroupByOutputType = {
    id: string
    instituteId: string
    prefix: string
    yearInId: boolean
    sequenceDigits: number
    currentSequence: number
    defaultSignatureUrl: string | null
    defaultSignatoryName: string
    defaultSignatoryTitle: string
    signaturePosition: string
    logoPosition: string
    logoSize: string
    signatureSize: string
    borderStyle: string
    backgroundUrl: string | null
    defaultValidityMonths: number | null
    instituteName: string
    instituteLogoUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: CertificateSettingsCountAggregateOutputType | null
    _avg: CertificateSettingsAvgAggregateOutputType | null
    _sum: CertificateSettingsSumAggregateOutputType | null
    _min: CertificateSettingsMinAggregateOutputType | null
    _max: CertificateSettingsMaxAggregateOutputType | null
  }

  type GetCertificateSettingsGroupByPayload<T extends CertificateSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificateSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificateSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificateSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], CertificateSettingsGroupByOutputType[P]>
        }
      >
    >


  export type CertificateSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instituteId?: boolean
    prefix?: boolean
    yearInId?: boolean
    sequenceDigits?: boolean
    currentSequence?: boolean
    defaultSignatureUrl?: boolean
    defaultSignatoryName?: boolean
    defaultSignatoryTitle?: boolean
    signaturePosition?: boolean
    logoPosition?: boolean
    logoSize?: boolean
    signatureSize?: boolean
    borderStyle?: boolean
    backgroundUrl?: boolean
    defaultValidityMonths?: boolean
    instituteName?: boolean
    instituteLogoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["certificateSettings"]>

  export type CertificateSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instituteId?: boolean
    prefix?: boolean
    yearInId?: boolean
    sequenceDigits?: boolean
    currentSequence?: boolean
    defaultSignatureUrl?: boolean
    defaultSignatoryName?: boolean
    defaultSignatoryTitle?: boolean
    signaturePosition?: boolean
    logoPosition?: boolean
    logoSize?: boolean
    signatureSize?: boolean
    borderStyle?: boolean
    backgroundUrl?: boolean
    defaultValidityMonths?: boolean
    instituteName?: boolean
    instituteLogoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["certificateSettings"]>

  export type CertificateSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instituteId?: boolean
    prefix?: boolean
    yearInId?: boolean
    sequenceDigits?: boolean
    currentSequence?: boolean
    defaultSignatureUrl?: boolean
    defaultSignatoryName?: boolean
    defaultSignatoryTitle?: boolean
    signaturePosition?: boolean
    logoPosition?: boolean
    logoSize?: boolean
    signatureSize?: boolean
    borderStyle?: boolean
    backgroundUrl?: boolean
    defaultValidityMonths?: boolean
    instituteName?: boolean
    instituteLogoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["certificateSettings"]>

  export type CertificateSettingsSelectScalar = {
    id?: boolean
    instituteId?: boolean
    prefix?: boolean
    yearInId?: boolean
    sequenceDigits?: boolean
    currentSequence?: boolean
    defaultSignatureUrl?: boolean
    defaultSignatoryName?: boolean
    defaultSignatoryTitle?: boolean
    signaturePosition?: boolean
    logoPosition?: boolean
    logoSize?: boolean
    signatureSize?: boolean
    borderStyle?: boolean
    backgroundUrl?: boolean
    defaultValidityMonths?: boolean
    instituteName?: boolean
    instituteLogoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CertificateSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "instituteId" | "prefix" | "yearInId" | "sequenceDigits" | "currentSequence" | "defaultSignatureUrl" | "defaultSignatoryName" | "defaultSignatoryTitle" | "signaturePosition" | "logoPosition" | "logoSize" | "signatureSize" | "borderStyle" | "backgroundUrl" | "defaultValidityMonths" | "instituteName" | "instituteLogoUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["certificateSettings"]>

  export type $CertificateSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CertificateSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      instituteId: string
      prefix: string
      yearInId: boolean
      sequenceDigits: number
      currentSequence: number
      defaultSignatureUrl: string | null
      defaultSignatoryName: string
      defaultSignatoryTitle: string
      signaturePosition: string
      logoPosition: string
      logoSize: string
      signatureSize: string
      borderStyle: string
      backgroundUrl: string | null
      defaultValidityMonths: number | null
      instituteName: string
      instituteLogoUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["certificateSettings"]>
    composites: {}
  }

  type CertificateSettingsGetPayload<S extends boolean | null | undefined | CertificateSettingsDefaultArgs> = $Result.GetResult<Prisma.$CertificateSettingsPayload, S>

  type CertificateSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CertificateSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CertificateSettingsCountAggregateInputType | true
    }

  export interface CertificateSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CertificateSettings'], meta: { name: 'CertificateSettings' } }
    /**
     * Find zero or one CertificateSettings that matches the filter.
     * @param {CertificateSettingsFindUniqueArgs} args - Arguments to find a CertificateSettings
     * @example
     * // Get one CertificateSettings
     * const certificateSettings = await prisma.certificateSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificateSettingsFindUniqueArgs>(args: SelectSubset<T, CertificateSettingsFindUniqueArgs<ExtArgs>>): Prisma__CertificateSettingsClient<$Result.GetResult<Prisma.$CertificateSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CertificateSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CertificateSettingsFindUniqueOrThrowArgs} args - Arguments to find a CertificateSettings
     * @example
     * // Get one CertificateSettings
     * const certificateSettings = await prisma.certificateSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificateSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificateSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificateSettingsClient<$Result.GetResult<Prisma.$CertificateSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CertificateSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateSettingsFindFirstArgs} args - Arguments to find a CertificateSettings
     * @example
     * // Get one CertificateSettings
     * const certificateSettings = await prisma.certificateSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificateSettingsFindFirstArgs>(args?: SelectSubset<T, CertificateSettingsFindFirstArgs<ExtArgs>>): Prisma__CertificateSettingsClient<$Result.GetResult<Prisma.$CertificateSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CertificateSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateSettingsFindFirstOrThrowArgs} args - Arguments to find a CertificateSettings
     * @example
     * // Get one CertificateSettings
     * const certificateSettings = await prisma.certificateSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificateSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificateSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificateSettingsClient<$Result.GetResult<Prisma.$CertificateSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CertificateSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CertificateSettings
     * const certificateSettings = await prisma.certificateSettings.findMany()
     * 
     * // Get first 10 CertificateSettings
     * const certificateSettings = await prisma.certificateSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificateSettingsWithIdOnly = await prisma.certificateSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificateSettingsFindManyArgs>(args?: SelectSubset<T, CertificateSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificateSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CertificateSettings.
     * @param {CertificateSettingsCreateArgs} args - Arguments to create a CertificateSettings.
     * @example
     * // Create one CertificateSettings
     * const CertificateSettings = await prisma.certificateSettings.create({
     *   data: {
     *     // ... data to create a CertificateSettings
     *   }
     * })
     * 
     */
    create<T extends CertificateSettingsCreateArgs>(args: SelectSubset<T, CertificateSettingsCreateArgs<ExtArgs>>): Prisma__CertificateSettingsClient<$Result.GetResult<Prisma.$CertificateSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CertificateSettings.
     * @param {CertificateSettingsCreateManyArgs} args - Arguments to create many CertificateSettings.
     * @example
     * // Create many CertificateSettings
     * const certificateSettings = await prisma.certificateSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificateSettingsCreateManyArgs>(args?: SelectSubset<T, CertificateSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CertificateSettings and returns the data saved in the database.
     * @param {CertificateSettingsCreateManyAndReturnArgs} args - Arguments to create many CertificateSettings.
     * @example
     * // Create many CertificateSettings
     * const certificateSettings = await prisma.certificateSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CertificateSettings and only return the `id`
     * const certificateSettingsWithIdOnly = await prisma.certificateSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificateSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificateSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificateSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CertificateSettings.
     * @param {CertificateSettingsDeleteArgs} args - Arguments to delete one CertificateSettings.
     * @example
     * // Delete one CertificateSettings
     * const CertificateSettings = await prisma.certificateSettings.delete({
     *   where: {
     *     // ... filter to delete one CertificateSettings
     *   }
     * })
     * 
     */
    delete<T extends CertificateSettingsDeleteArgs>(args: SelectSubset<T, CertificateSettingsDeleteArgs<ExtArgs>>): Prisma__CertificateSettingsClient<$Result.GetResult<Prisma.$CertificateSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CertificateSettings.
     * @param {CertificateSettingsUpdateArgs} args - Arguments to update one CertificateSettings.
     * @example
     * // Update one CertificateSettings
     * const certificateSettings = await prisma.certificateSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificateSettingsUpdateArgs>(args: SelectSubset<T, CertificateSettingsUpdateArgs<ExtArgs>>): Prisma__CertificateSettingsClient<$Result.GetResult<Prisma.$CertificateSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CertificateSettings.
     * @param {CertificateSettingsDeleteManyArgs} args - Arguments to filter CertificateSettings to delete.
     * @example
     * // Delete a few CertificateSettings
     * const { count } = await prisma.certificateSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificateSettingsDeleteManyArgs>(args?: SelectSubset<T, CertificateSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CertificateSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CertificateSettings
     * const certificateSettings = await prisma.certificateSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificateSettingsUpdateManyArgs>(args: SelectSubset<T, CertificateSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CertificateSettings and returns the data updated in the database.
     * @param {CertificateSettingsUpdateManyAndReturnArgs} args - Arguments to update many CertificateSettings.
     * @example
     * // Update many CertificateSettings
     * const certificateSettings = await prisma.certificateSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CertificateSettings and only return the `id`
     * const certificateSettingsWithIdOnly = await prisma.certificateSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CertificateSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, CertificateSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificateSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CertificateSettings.
     * @param {CertificateSettingsUpsertArgs} args - Arguments to update or create a CertificateSettings.
     * @example
     * // Update or create a CertificateSettings
     * const certificateSettings = await prisma.certificateSettings.upsert({
     *   create: {
     *     // ... data to create a CertificateSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CertificateSettings we want to update
     *   }
     * })
     */
    upsert<T extends CertificateSettingsUpsertArgs>(args: SelectSubset<T, CertificateSettingsUpsertArgs<ExtArgs>>): Prisma__CertificateSettingsClient<$Result.GetResult<Prisma.$CertificateSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CertificateSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateSettingsCountArgs} args - Arguments to filter CertificateSettings to count.
     * @example
     * // Count the number of CertificateSettings
     * const count = await prisma.certificateSettings.count({
     *   where: {
     *     // ... the filter for the CertificateSettings we want to count
     *   }
     * })
    **/
    count<T extends CertificateSettingsCountArgs>(
      args?: Subset<T, CertificateSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificateSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CertificateSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificateSettingsAggregateArgs>(args: Subset<T, CertificateSettingsAggregateArgs>): Prisma.PrismaPromise<GetCertificateSettingsAggregateType<T>>

    /**
     * Group by CertificateSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificateSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificateSettingsGroupByArgs['orderBy'] }
        : { orderBy?: CertificateSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificateSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificateSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CertificateSettings model
   */
  readonly fields: CertificateSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CertificateSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificateSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CertificateSettings model
   */
  interface CertificateSettingsFieldRefs {
    readonly id: FieldRef<"CertificateSettings", 'String'>
    readonly instituteId: FieldRef<"CertificateSettings", 'String'>
    readonly prefix: FieldRef<"CertificateSettings", 'String'>
    readonly yearInId: FieldRef<"CertificateSettings", 'Boolean'>
    readonly sequenceDigits: FieldRef<"CertificateSettings", 'Int'>
    readonly currentSequence: FieldRef<"CertificateSettings", 'Int'>
    readonly defaultSignatureUrl: FieldRef<"CertificateSettings", 'String'>
    readonly defaultSignatoryName: FieldRef<"CertificateSettings", 'String'>
    readonly defaultSignatoryTitle: FieldRef<"CertificateSettings", 'String'>
    readonly signaturePosition: FieldRef<"CertificateSettings", 'String'>
    readonly logoPosition: FieldRef<"CertificateSettings", 'String'>
    readonly logoSize: FieldRef<"CertificateSettings", 'String'>
    readonly signatureSize: FieldRef<"CertificateSettings", 'String'>
    readonly borderStyle: FieldRef<"CertificateSettings", 'String'>
    readonly backgroundUrl: FieldRef<"CertificateSettings", 'String'>
    readonly defaultValidityMonths: FieldRef<"CertificateSettings", 'Int'>
    readonly instituteName: FieldRef<"CertificateSettings", 'String'>
    readonly instituteLogoUrl: FieldRef<"CertificateSettings", 'String'>
    readonly createdAt: FieldRef<"CertificateSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"CertificateSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CertificateSettings findUnique
   */
  export type CertificateSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateSettings
     */
    select?: CertificateSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateSettings
     */
    omit?: CertificateSettingsOmit<ExtArgs> | null
    /**
     * Filter, which CertificateSettings to fetch.
     */
    where: CertificateSettingsWhereUniqueInput
  }

  /**
   * CertificateSettings findUniqueOrThrow
   */
  export type CertificateSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateSettings
     */
    select?: CertificateSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateSettings
     */
    omit?: CertificateSettingsOmit<ExtArgs> | null
    /**
     * Filter, which CertificateSettings to fetch.
     */
    where: CertificateSettingsWhereUniqueInput
  }

  /**
   * CertificateSettings findFirst
   */
  export type CertificateSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateSettings
     */
    select?: CertificateSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateSettings
     */
    omit?: CertificateSettingsOmit<ExtArgs> | null
    /**
     * Filter, which CertificateSettings to fetch.
     */
    where?: CertificateSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificateSettings to fetch.
     */
    orderBy?: CertificateSettingsOrderByWithRelationInput | CertificateSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CertificateSettings.
     */
    cursor?: CertificateSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificateSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificateSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CertificateSettings.
     */
    distinct?: CertificateSettingsScalarFieldEnum | CertificateSettingsScalarFieldEnum[]
  }

  /**
   * CertificateSettings findFirstOrThrow
   */
  export type CertificateSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateSettings
     */
    select?: CertificateSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateSettings
     */
    omit?: CertificateSettingsOmit<ExtArgs> | null
    /**
     * Filter, which CertificateSettings to fetch.
     */
    where?: CertificateSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificateSettings to fetch.
     */
    orderBy?: CertificateSettingsOrderByWithRelationInput | CertificateSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CertificateSettings.
     */
    cursor?: CertificateSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificateSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificateSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CertificateSettings.
     */
    distinct?: CertificateSettingsScalarFieldEnum | CertificateSettingsScalarFieldEnum[]
  }

  /**
   * CertificateSettings findMany
   */
  export type CertificateSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateSettings
     */
    select?: CertificateSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateSettings
     */
    omit?: CertificateSettingsOmit<ExtArgs> | null
    /**
     * Filter, which CertificateSettings to fetch.
     */
    where?: CertificateSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificateSettings to fetch.
     */
    orderBy?: CertificateSettingsOrderByWithRelationInput | CertificateSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CertificateSettings.
     */
    cursor?: CertificateSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificateSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificateSettings.
     */
    skip?: number
    distinct?: CertificateSettingsScalarFieldEnum | CertificateSettingsScalarFieldEnum[]
  }

  /**
   * CertificateSettings create
   */
  export type CertificateSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateSettings
     */
    select?: CertificateSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateSettings
     */
    omit?: CertificateSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a CertificateSettings.
     */
    data: XOR<CertificateSettingsCreateInput, CertificateSettingsUncheckedCreateInput>
  }

  /**
   * CertificateSettings createMany
   */
  export type CertificateSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CertificateSettings.
     */
    data: CertificateSettingsCreateManyInput | CertificateSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CertificateSettings createManyAndReturn
   */
  export type CertificateSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateSettings
     */
    select?: CertificateSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateSettings
     */
    omit?: CertificateSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many CertificateSettings.
     */
    data: CertificateSettingsCreateManyInput | CertificateSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CertificateSettings update
   */
  export type CertificateSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateSettings
     */
    select?: CertificateSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateSettings
     */
    omit?: CertificateSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a CertificateSettings.
     */
    data: XOR<CertificateSettingsUpdateInput, CertificateSettingsUncheckedUpdateInput>
    /**
     * Choose, which CertificateSettings to update.
     */
    where: CertificateSettingsWhereUniqueInput
  }

  /**
   * CertificateSettings updateMany
   */
  export type CertificateSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CertificateSettings.
     */
    data: XOR<CertificateSettingsUpdateManyMutationInput, CertificateSettingsUncheckedUpdateManyInput>
    /**
     * Filter which CertificateSettings to update
     */
    where?: CertificateSettingsWhereInput
    /**
     * Limit how many CertificateSettings to update.
     */
    limit?: number
  }

  /**
   * CertificateSettings updateManyAndReturn
   */
  export type CertificateSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateSettings
     */
    select?: CertificateSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateSettings
     */
    omit?: CertificateSettingsOmit<ExtArgs> | null
    /**
     * The data used to update CertificateSettings.
     */
    data: XOR<CertificateSettingsUpdateManyMutationInput, CertificateSettingsUncheckedUpdateManyInput>
    /**
     * Filter which CertificateSettings to update
     */
    where?: CertificateSettingsWhereInput
    /**
     * Limit how many CertificateSettings to update.
     */
    limit?: number
  }

  /**
   * CertificateSettings upsert
   */
  export type CertificateSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateSettings
     */
    select?: CertificateSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateSettings
     */
    omit?: CertificateSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the CertificateSettings to update in case it exists.
     */
    where: CertificateSettingsWhereUniqueInput
    /**
     * In case the CertificateSettings found by the `where` argument doesn't exist, create a new CertificateSettings with this data.
     */
    create: XOR<CertificateSettingsCreateInput, CertificateSettingsUncheckedCreateInput>
    /**
     * In case the CertificateSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificateSettingsUpdateInput, CertificateSettingsUncheckedUpdateInput>
  }

  /**
   * CertificateSettings delete
   */
  export type CertificateSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateSettings
     */
    select?: CertificateSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateSettings
     */
    omit?: CertificateSettingsOmit<ExtArgs> | null
    /**
     * Filter which CertificateSettings to delete.
     */
    where: CertificateSettingsWhereUniqueInput
  }

  /**
   * CertificateSettings deleteMany
   */
  export type CertificateSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CertificateSettings to delete
     */
    where?: CertificateSettingsWhereInput
    /**
     * Limit how many CertificateSettings to delete.
     */
    limit?: number
  }

  /**
   * CertificateSettings without action
   */
  export type CertificateSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificateSettings
     */
    select?: CertificateSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificateSettings
     */
    omit?: CertificateSettingsOmit<ExtArgs> | null
  }


  /**
   * Model AIProvider
   */

  export type AggregateAIProvider = {
    _count: AIProviderCountAggregateOutputType | null
    _avg: AIProviderAvgAggregateOutputType | null
    _sum: AIProviderSumAggregateOutputType | null
    _min: AIProviderMinAggregateOutputType | null
    _max: AIProviderMaxAggregateOutputType | null
  }

  export type AIProviderAvgAggregateOutputType = {
    usageLimit: number | null
    currentUsage: number | null
    temperature: number | null
    maxTokens: number | null
  }

  export type AIProviderSumAggregateOutputType = {
    usageLimit: number | null
    currentUsage: number | null
    temperature: number | null
    maxTokens: number | null
  }

  export type AIProviderMinAggregateOutputType = {
    id: string | null
    name: string | null
    provider: string | null
    apiKey: string | null
    model: string | null
    endpoint: string | null
    isActive: boolean | null
    isDefault: boolean | null
    usageLimit: number | null
    currentUsage: number | null
    lastResetAt: Date | null
    temperature: number | null
    maxTokens: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIProviderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    provider: string | null
    apiKey: string | null
    model: string | null
    endpoint: string | null
    isActive: boolean | null
    isDefault: boolean | null
    usageLimit: number | null
    currentUsage: number | null
    lastResetAt: Date | null
    temperature: number | null
    maxTokens: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIProviderCountAggregateOutputType = {
    id: number
    name: number
    provider: number
    apiKey: number
    model: number
    endpoint: number
    isActive: number
    isDefault: number
    usageLimit: number
    currentUsage: number
    lastResetAt: number
    temperature: number
    maxTokens: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AIProviderAvgAggregateInputType = {
    usageLimit?: true
    currentUsage?: true
    temperature?: true
    maxTokens?: true
  }

  export type AIProviderSumAggregateInputType = {
    usageLimit?: true
    currentUsage?: true
    temperature?: true
    maxTokens?: true
  }

  export type AIProviderMinAggregateInputType = {
    id?: true
    name?: true
    provider?: true
    apiKey?: true
    model?: true
    endpoint?: true
    isActive?: true
    isDefault?: true
    usageLimit?: true
    currentUsage?: true
    lastResetAt?: true
    temperature?: true
    maxTokens?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIProviderMaxAggregateInputType = {
    id?: true
    name?: true
    provider?: true
    apiKey?: true
    model?: true
    endpoint?: true
    isActive?: true
    isDefault?: true
    usageLimit?: true
    currentUsage?: true
    lastResetAt?: true
    temperature?: true
    maxTokens?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIProviderCountAggregateInputType = {
    id?: true
    name?: true
    provider?: true
    apiKey?: true
    model?: true
    endpoint?: true
    isActive?: true
    isDefault?: true
    usageLimit?: true
    currentUsage?: true
    lastResetAt?: true
    temperature?: true
    maxTokens?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AIProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIProvider to aggregate.
     */
    where?: AIProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIProviders to fetch.
     */
    orderBy?: AIProviderOrderByWithRelationInput | AIProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIProviders
    **/
    _count?: true | AIProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIProviderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIProviderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIProviderMaxAggregateInputType
  }

  export type GetAIProviderAggregateType<T extends AIProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateAIProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIProvider[P]>
      : GetScalarType<T[P], AggregateAIProvider[P]>
  }




  export type AIProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIProviderWhereInput
    orderBy?: AIProviderOrderByWithAggregationInput | AIProviderOrderByWithAggregationInput[]
    by: AIProviderScalarFieldEnum[] | AIProviderScalarFieldEnum
    having?: AIProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIProviderCountAggregateInputType | true
    _avg?: AIProviderAvgAggregateInputType
    _sum?: AIProviderSumAggregateInputType
    _min?: AIProviderMinAggregateInputType
    _max?: AIProviderMaxAggregateInputType
  }

  export type AIProviderGroupByOutputType = {
    id: string
    name: string
    provider: string
    apiKey: string
    model: string
    endpoint: string | null
    isActive: boolean
    isDefault: boolean
    usageLimit: number | null
    currentUsage: number
    lastResetAt: Date
    temperature: number
    maxTokens: number
    createdAt: Date
    updatedAt: Date
    _count: AIProviderCountAggregateOutputType | null
    _avg: AIProviderAvgAggregateOutputType | null
    _sum: AIProviderSumAggregateOutputType | null
    _min: AIProviderMinAggregateOutputType | null
    _max: AIProviderMaxAggregateOutputType | null
  }

  type GetAIProviderGroupByPayload<T extends AIProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIProviderGroupByOutputType[P]>
            : GetScalarType<T[P], AIProviderGroupByOutputType[P]>
        }
      >
    >


  export type AIProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    provider?: boolean
    apiKey?: boolean
    model?: boolean
    endpoint?: boolean
    isActive?: boolean
    isDefault?: boolean
    usageLimit?: boolean
    currentUsage?: boolean
    lastResetAt?: boolean
    temperature?: boolean
    maxTokens?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIProvider"]>

  export type AIProviderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    provider?: boolean
    apiKey?: boolean
    model?: boolean
    endpoint?: boolean
    isActive?: boolean
    isDefault?: boolean
    usageLimit?: boolean
    currentUsage?: boolean
    lastResetAt?: boolean
    temperature?: boolean
    maxTokens?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIProvider"]>

  export type AIProviderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    provider?: boolean
    apiKey?: boolean
    model?: boolean
    endpoint?: boolean
    isActive?: boolean
    isDefault?: boolean
    usageLimit?: boolean
    currentUsage?: boolean
    lastResetAt?: boolean
    temperature?: boolean
    maxTokens?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIProvider"]>

  export type AIProviderSelectScalar = {
    id?: boolean
    name?: boolean
    provider?: boolean
    apiKey?: boolean
    model?: boolean
    endpoint?: boolean
    isActive?: boolean
    isDefault?: boolean
    usageLimit?: boolean
    currentUsage?: boolean
    lastResetAt?: boolean
    temperature?: boolean
    maxTokens?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AIProviderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "provider" | "apiKey" | "model" | "endpoint" | "isActive" | "isDefault" | "usageLimit" | "currentUsage" | "lastResetAt" | "temperature" | "maxTokens" | "createdAt" | "updatedAt", ExtArgs["result"]["aIProvider"]>

  export type $AIProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIProvider"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      provider: string
      apiKey: string
      model: string
      endpoint: string | null
      isActive: boolean
      isDefault: boolean
      usageLimit: number | null
      currentUsage: number
      lastResetAt: Date
      temperature: number
      maxTokens: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aIProvider"]>
    composites: {}
  }

  type AIProviderGetPayload<S extends boolean | null | undefined | AIProviderDefaultArgs> = $Result.GetResult<Prisma.$AIProviderPayload, S>

  type AIProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIProviderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIProviderCountAggregateInputType | true
    }

  export interface AIProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIProvider'], meta: { name: 'AIProvider' } }
    /**
     * Find zero or one AIProvider that matches the filter.
     * @param {AIProviderFindUniqueArgs} args - Arguments to find a AIProvider
     * @example
     * // Get one AIProvider
     * const aIProvider = await prisma.aIProvider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIProviderFindUniqueArgs>(args: SelectSubset<T, AIProviderFindUniqueArgs<ExtArgs>>): Prisma__AIProviderClient<$Result.GetResult<Prisma.$AIProviderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIProvider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIProviderFindUniqueOrThrowArgs} args - Arguments to find a AIProvider
     * @example
     * // Get one AIProvider
     * const aIProvider = await prisma.aIProvider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIProviderFindUniqueOrThrowArgs>(args: SelectSubset<T, AIProviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIProviderClient<$Result.GetResult<Prisma.$AIProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIProvider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProviderFindFirstArgs} args - Arguments to find a AIProvider
     * @example
     * // Get one AIProvider
     * const aIProvider = await prisma.aIProvider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIProviderFindFirstArgs>(args?: SelectSubset<T, AIProviderFindFirstArgs<ExtArgs>>): Prisma__AIProviderClient<$Result.GetResult<Prisma.$AIProviderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIProvider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProviderFindFirstOrThrowArgs} args - Arguments to find a AIProvider
     * @example
     * // Get one AIProvider
     * const aIProvider = await prisma.aIProvider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIProviderFindFirstOrThrowArgs>(args?: SelectSubset<T, AIProviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIProviderClient<$Result.GetResult<Prisma.$AIProviderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIProviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIProviders
     * const aIProviders = await prisma.aIProvider.findMany()
     * 
     * // Get first 10 AIProviders
     * const aIProviders = await prisma.aIProvider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIProviderWithIdOnly = await prisma.aIProvider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIProviderFindManyArgs>(args?: SelectSubset<T, AIProviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIProvider.
     * @param {AIProviderCreateArgs} args - Arguments to create a AIProvider.
     * @example
     * // Create one AIProvider
     * const AIProvider = await prisma.aIProvider.create({
     *   data: {
     *     // ... data to create a AIProvider
     *   }
     * })
     * 
     */
    create<T extends AIProviderCreateArgs>(args: SelectSubset<T, AIProviderCreateArgs<ExtArgs>>): Prisma__AIProviderClient<$Result.GetResult<Prisma.$AIProviderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIProviders.
     * @param {AIProviderCreateManyArgs} args - Arguments to create many AIProviders.
     * @example
     * // Create many AIProviders
     * const aIProvider = await prisma.aIProvider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIProviderCreateManyArgs>(args?: SelectSubset<T, AIProviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIProviders and returns the data saved in the database.
     * @param {AIProviderCreateManyAndReturnArgs} args - Arguments to create many AIProviders.
     * @example
     * // Create many AIProviders
     * const aIProvider = await prisma.aIProvider.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIProviders and only return the `id`
     * const aIProviderWithIdOnly = await prisma.aIProvider.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIProviderCreateManyAndReturnArgs>(args?: SelectSubset<T, AIProviderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIProviderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIProvider.
     * @param {AIProviderDeleteArgs} args - Arguments to delete one AIProvider.
     * @example
     * // Delete one AIProvider
     * const AIProvider = await prisma.aIProvider.delete({
     *   where: {
     *     // ... filter to delete one AIProvider
     *   }
     * })
     * 
     */
    delete<T extends AIProviderDeleteArgs>(args: SelectSubset<T, AIProviderDeleteArgs<ExtArgs>>): Prisma__AIProviderClient<$Result.GetResult<Prisma.$AIProviderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIProvider.
     * @param {AIProviderUpdateArgs} args - Arguments to update one AIProvider.
     * @example
     * // Update one AIProvider
     * const aIProvider = await prisma.aIProvider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIProviderUpdateArgs>(args: SelectSubset<T, AIProviderUpdateArgs<ExtArgs>>): Prisma__AIProviderClient<$Result.GetResult<Prisma.$AIProviderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIProviders.
     * @param {AIProviderDeleteManyArgs} args - Arguments to filter AIProviders to delete.
     * @example
     * // Delete a few AIProviders
     * const { count } = await prisma.aIProvider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIProviderDeleteManyArgs>(args?: SelectSubset<T, AIProviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIProviders
     * const aIProvider = await prisma.aIProvider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIProviderUpdateManyArgs>(args: SelectSubset<T, AIProviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIProviders and returns the data updated in the database.
     * @param {AIProviderUpdateManyAndReturnArgs} args - Arguments to update many AIProviders.
     * @example
     * // Update many AIProviders
     * const aIProvider = await prisma.aIProvider.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIProviders and only return the `id`
     * const aIProviderWithIdOnly = await prisma.aIProvider.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIProviderUpdateManyAndReturnArgs>(args: SelectSubset<T, AIProviderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIProviderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIProvider.
     * @param {AIProviderUpsertArgs} args - Arguments to update or create a AIProvider.
     * @example
     * // Update or create a AIProvider
     * const aIProvider = await prisma.aIProvider.upsert({
     *   create: {
     *     // ... data to create a AIProvider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIProvider we want to update
     *   }
     * })
     */
    upsert<T extends AIProviderUpsertArgs>(args: SelectSubset<T, AIProviderUpsertArgs<ExtArgs>>): Prisma__AIProviderClient<$Result.GetResult<Prisma.$AIProviderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProviderCountArgs} args - Arguments to filter AIProviders to count.
     * @example
     * // Count the number of AIProviders
     * const count = await prisma.aIProvider.count({
     *   where: {
     *     // ... the filter for the AIProviders we want to count
     *   }
     * })
    **/
    count<T extends AIProviderCountArgs>(
      args?: Subset<T, AIProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIProviderAggregateArgs>(args: Subset<T, AIProviderAggregateArgs>): Prisma.PrismaPromise<GetAIProviderAggregateType<T>>

    /**
     * Group by AIProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIProviderGroupByArgs['orderBy'] }
        : { orderBy?: AIProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIProvider model
   */
  readonly fields: AIProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIProvider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIProvider model
   */
  interface AIProviderFieldRefs {
    readonly id: FieldRef<"AIProvider", 'String'>
    readonly name: FieldRef<"AIProvider", 'String'>
    readonly provider: FieldRef<"AIProvider", 'String'>
    readonly apiKey: FieldRef<"AIProvider", 'String'>
    readonly model: FieldRef<"AIProvider", 'String'>
    readonly endpoint: FieldRef<"AIProvider", 'String'>
    readonly isActive: FieldRef<"AIProvider", 'Boolean'>
    readonly isDefault: FieldRef<"AIProvider", 'Boolean'>
    readonly usageLimit: FieldRef<"AIProvider", 'Int'>
    readonly currentUsage: FieldRef<"AIProvider", 'Int'>
    readonly lastResetAt: FieldRef<"AIProvider", 'DateTime'>
    readonly temperature: FieldRef<"AIProvider", 'Float'>
    readonly maxTokens: FieldRef<"AIProvider", 'Int'>
    readonly createdAt: FieldRef<"AIProvider", 'DateTime'>
    readonly updatedAt: FieldRef<"AIProvider", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIProvider findUnique
   */
  export type AIProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProvider
     */
    select?: AIProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProvider
     */
    omit?: AIProviderOmit<ExtArgs> | null
    /**
     * Filter, which AIProvider to fetch.
     */
    where: AIProviderWhereUniqueInput
  }

  /**
   * AIProvider findUniqueOrThrow
   */
  export type AIProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProvider
     */
    select?: AIProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProvider
     */
    omit?: AIProviderOmit<ExtArgs> | null
    /**
     * Filter, which AIProvider to fetch.
     */
    where: AIProviderWhereUniqueInput
  }

  /**
   * AIProvider findFirst
   */
  export type AIProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProvider
     */
    select?: AIProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProvider
     */
    omit?: AIProviderOmit<ExtArgs> | null
    /**
     * Filter, which AIProvider to fetch.
     */
    where?: AIProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIProviders to fetch.
     */
    orderBy?: AIProviderOrderByWithRelationInput | AIProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIProviders.
     */
    cursor?: AIProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIProviders.
     */
    distinct?: AIProviderScalarFieldEnum | AIProviderScalarFieldEnum[]
  }

  /**
   * AIProvider findFirstOrThrow
   */
  export type AIProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProvider
     */
    select?: AIProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProvider
     */
    omit?: AIProviderOmit<ExtArgs> | null
    /**
     * Filter, which AIProvider to fetch.
     */
    where?: AIProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIProviders to fetch.
     */
    orderBy?: AIProviderOrderByWithRelationInput | AIProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIProviders.
     */
    cursor?: AIProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIProviders.
     */
    distinct?: AIProviderScalarFieldEnum | AIProviderScalarFieldEnum[]
  }

  /**
   * AIProvider findMany
   */
  export type AIProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProvider
     */
    select?: AIProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProvider
     */
    omit?: AIProviderOmit<ExtArgs> | null
    /**
     * Filter, which AIProviders to fetch.
     */
    where?: AIProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIProviders to fetch.
     */
    orderBy?: AIProviderOrderByWithRelationInput | AIProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIProviders.
     */
    cursor?: AIProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIProviders.
     */
    skip?: number
    distinct?: AIProviderScalarFieldEnum | AIProviderScalarFieldEnum[]
  }

  /**
   * AIProvider create
   */
  export type AIProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProvider
     */
    select?: AIProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProvider
     */
    omit?: AIProviderOmit<ExtArgs> | null
    /**
     * The data needed to create a AIProvider.
     */
    data: XOR<AIProviderCreateInput, AIProviderUncheckedCreateInput>
  }

  /**
   * AIProvider createMany
   */
  export type AIProviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIProviders.
     */
    data: AIProviderCreateManyInput | AIProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIProvider createManyAndReturn
   */
  export type AIProviderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProvider
     */
    select?: AIProviderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIProvider
     */
    omit?: AIProviderOmit<ExtArgs> | null
    /**
     * The data used to create many AIProviders.
     */
    data: AIProviderCreateManyInput | AIProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIProvider update
   */
  export type AIProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProvider
     */
    select?: AIProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProvider
     */
    omit?: AIProviderOmit<ExtArgs> | null
    /**
     * The data needed to update a AIProvider.
     */
    data: XOR<AIProviderUpdateInput, AIProviderUncheckedUpdateInput>
    /**
     * Choose, which AIProvider to update.
     */
    where: AIProviderWhereUniqueInput
  }

  /**
   * AIProvider updateMany
   */
  export type AIProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIProviders.
     */
    data: XOR<AIProviderUpdateManyMutationInput, AIProviderUncheckedUpdateManyInput>
    /**
     * Filter which AIProviders to update
     */
    where?: AIProviderWhereInput
    /**
     * Limit how many AIProviders to update.
     */
    limit?: number
  }

  /**
   * AIProvider updateManyAndReturn
   */
  export type AIProviderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProvider
     */
    select?: AIProviderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIProvider
     */
    omit?: AIProviderOmit<ExtArgs> | null
    /**
     * The data used to update AIProviders.
     */
    data: XOR<AIProviderUpdateManyMutationInput, AIProviderUncheckedUpdateManyInput>
    /**
     * Filter which AIProviders to update
     */
    where?: AIProviderWhereInput
    /**
     * Limit how many AIProviders to update.
     */
    limit?: number
  }

  /**
   * AIProvider upsert
   */
  export type AIProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProvider
     */
    select?: AIProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProvider
     */
    omit?: AIProviderOmit<ExtArgs> | null
    /**
     * The filter to search for the AIProvider to update in case it exists.
     */
    where: AIProviderWhereUniqueInput
    /**
     * In case the AIProvider found by the `where` argument doesn't exist, create a new AIProvider with this data.
     */
    create: XOR<AIProviderCreateInput, AIProviderUncheckedCreateInput>
    /**
     * In case the AIProvider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIProviderUpdateInput, AIProviderUncheckedUpdateInput>
  }

  /**
   * AIProvider delete
   */
  export type AIProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProvider
     */
    select?: AIProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProvider
     */
    omit?: AIProviderOmit<ExtArgs> | null
    /**
     * Filter which AIProvider to delete.
     */
    where: AIProviderWhereUniqueInput
  }

  /**
   * AIProvider deleteMany
   */
  export type AIProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIProviders to delete
     */
    where?: AIProviderWhereInput
    /**
     * Limit how many AIProviders to delete.
     */
    limit?: number
  }

  /**
   * AIProvider without action
   */
  export type AIProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIProvider
     */
    select?: AIProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIProvider
     */
    omit?: AIProviderOmit<ExtArgs> | null
  }


  /**
   * Model AIUsageLog
   */

  export type AggregateAIUsageLog = {
    _count: AIUsageLogCountAggregateOutputType | null
    _avg: AIUsageLogAvgAggregateOutputType | null
    _sum: AIUsageLogSumAggregateOutputType | null
    _min: AIUsageLogMinAggregateOutputType | null
    _max: AIUsageLogMaxAggregateOutputType | null
  }

  export type AIUsageLogAvgAggregateOutputType = {
    tokensUsed: number | null
  }

  export type AIUsageLogSumAggregateOutputType = {
    tokensUsed: number | null
  }

  export type AIUsageLogMinAggregateOutputType = {
    id: string | null
    providerId: string | null
    userId: string | null
    feature: string | null
    tokensUsed: number | null
    promptHash: string | null
    createdAt: Date | null
  }

  export type AIUsageLogMaxAggregateOutputType = {
    id: string | null
    providerId: string | null
    userId: string | null
    feature: string | null
    tokensUsed: number | null
    promptHash: string | null
    createdAt: Date | null
  }

  export type AIUsageLogCountAggregateOutputType = {
    id: number
    providerId: number
    userId: number
    feature: number
    tokensUsed: number
    promptHash: number
    createdAt: number
    _all: number
  }


  export type AIUsageLogAvgAggregateInputType = {
    tokensUsed?: true
  }

  export type AIUsageLogSumAggregateInputType = {
    tokensUsed?: true
  }

  export type AIUsageLogMinAggregateInputType = {
    id?: true
    providerId?: true
    userId?: true
    feature?: true
    tokensUsed?: true
    promptHash?: true
    createdAt?: true
  }

  export type AIUsageLogMaxAggregateInputType = {
    id?: true
    providerId?: true
    userId?: true
    feature?: true
    tokensUsed?: true
    promptHash?: true
    createdAt?: true
  }

  export type AIUsageLogCountAggregateInputType = {
    id?: true
    providerId?: true
    userId?: true
    feature?: true
    tokensUsed?: true
    promptHash?: true
    createdAt?: true
    _all?: true
  }

  export type AIUsageLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIUsageLog to aggregate.
     */
    where?: AIUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageLogs to fetch.
     */
    orderBy?: AIUsageLogOrderByWithRelationInput | AIUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIUsageLogs
    **/
    _count?: true | AIUsageLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIUsageLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIUsageLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIUsageLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIUsageLogMaxAggregateInputType
  }

  export type GetAIUsageLogAggregateType<T extends AIUsageLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAIUsageLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIUsageLog[P]>
      : GetScalarType<T[P], AggregateAIUsageLog[P]>
  }




  export type AIUsageLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIUsageLogWhereInput
    orderBy?: AIUsageLogOrderByWithAggregationInput | AIUsageLogOrderByWithAggregationInput[]
    by: AIUsageLogScalarFieldEnum[] | AIUsageLogScalarFieldEnum
    having?: AIUsageLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIUsageLogCountAggregateInputType | true
    _avg?: AIUsageLogAvgAggregateInputType
    _sum?: AIUsageLogSumAggregateInputType
    _min?: AIUsageLogMinAggregateInputType
    _max?: AIUsageLogMaxAggregateInputType
  }

  export type AIUsageLogGroupByOutputType = {
    id: string
    providerId: string
    userId: string | null
    feature: string
    tokensUsed: number
    promptHash: string | null
    createdAt: Date
    _count: AIUsageLogCountAggregateOutputType | null
    _avg: AIUsageLogAvgAggregateOutputType | null
    _sum: AIUsageLogSumAggregateOutputType | null
    _min: AIUsageLogMinAggregateOutputType | null
    _max: AIUsageLogMaxAggregateOutputType | null
  }

  type GetAIUsageLogGroupByPayload<T extends AIUsageLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIUsageLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIUsageLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIUsageLogGroupByOutputType[P]>
            : GetScalarType<T[P], AIUsageLogGroupByOutputType[P]>
        }
      >
    >


  export type AIUsageLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    userId?: boolean
    feature?: boolean
    tokensUsed?: boolean
    promptHash?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aIUsageLog"]>

  export type AIUsageLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    userId?: boolean
    feature?: boolean
    tokensUsed?: boolean
    promptHash?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aIUsageLog"]>

  export type AIUsageLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    userId?: boolean
    feature?: boolean
    tokensUsed?: boolean
    promptHash?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aIUsageLog"]>

  export type AIUsageLogSelectScalar = {
    id?: boolean
    providerId?: boolean
    userId?: boolean
    feature?: boolean
    tokensUsed?: boolean
    promptHash?: boolean
    createdAt?: boolean
  }

  export type AIUsageLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "providerId" | "userId" | "feature" | "tokensUsed" | "promptHash" | "createdAt", ExtArgs["result"]["aIUsageLog"]>

  export type $AIUsageLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIUsageLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      providerId: string
      userId: string | null
      feature: string
      tokensUsed: number
      promptHash: string | null
      createdAt: Date
    }, ExtArgs["result"]["aIUsageLog"]>
    composites: {}
  }

  type AIUsageLogGetPayload<S extends boolean | null | undefined | AIUsageLogDefaultArgs> = $Result.GetResult<Prisma.$AIUsageLogPayload, S>

  type AIUsageLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIUsageLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIUsageLogCountAggregateInputType | true
    }

  export interface AIUsageLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIUsageLog'], meta: { name: 'AIUsageLog' } }
    /**
     * Find zero or one AIUsageLog that matches the filter.
     * @param {AIUsageLogFindUniqueArgs} args - Arguments to find a AIUsageLog
     * @example
     * // Get one AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIUsageLogFindUniqueArgs>(args: SelectSubset<T, AIUsageLogFindUniqueArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIUsageLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIUsageLogFindUniqueOrThrowArgs} args - Arguments to find a AIUsageLog
     * @example
     * // Get one AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIUsageLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AIUsageLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIUsageLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogFindFirstArgs} args - Arguments to find a AIUsageLog
     * @example
     * // Get one AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIUsageLogFindFirstArgs>(args?: SelectSubset<T, AIUsageLogFindFirstArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIUsageLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogFindFirstOrThrowArgs} args - Arguments to find a AIUsageLog
     * @example
     * // Get one AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIUsageLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AIUsageLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIUsageLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIUsageLogs
     * const aIUsageLogs = await prisma.aIUsageLog.findMany()
     * 
     * // Get first 10 AIUsageLogs
     * const aIUsageLogs = await prisma.aIUsageLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIUsageLogWithIdOnly = await prisma.aIUsageLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIUsageLogFindManyArgs>(args?: SelectSubset<T, AIUsageLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIUsageLog.
     * @param {AIUsageLogCreateArgs} args - Arguments to create a AIUsageLog.
     * @example
     * // Create one AIUsageLog
     * const AIUsageLog = await prisma.aIUsageLog.create({
     *   data: {
     *     // ... data to create a AIUsageLog
     *   }
     * })
     * 
     */
    create<T extends AIUsageLogCreateArgs>(args: SelectSubset<T, AIUsageLogCreateArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIUsageLogs.
     * @param {AIUsageLogCreateManyArgs} args - Arguments to create many AIUsageLogs.
     * @example
     * // Create many AIUsageLogs
     * const aIUsageLog = await prisma.aIUsageLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIUsageLogCreateManyArgs>(args?: SelectSubset<T, AIUsageLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIUsageLogs and returns the data saved in the database.
     * @param {AIUsageLogCreateManyAndReturnArgs} args - Arguments to create many AIUsageLogs.
     * @example
     * // Create many AIUsageLogs
     * const aIUsageLog = await prisma.aIUsageLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIUsageLogs and only return the `id`
     * const aIUsageLogWithIdOnly = await prisma.aIUsageLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIUsageLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AIUsageLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIUsageLog.
     * @param {AIUsageLogDeleteArgs} args - Arguments to delete one AIUsageLog.
     * @example
     * // Delete one AIUsageLog
     * const AIUsageLog = await prisma.aIUsageLog.delete({
     *   where: {
     *     // ... filter to delete one AIUsageLog
     *   }
     * })
     * 
     */
    delete<T extends AIUsageLogDeleteArgs>(args: SelectSubset<T, AIUsageLogDeleteArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIUsageLog.
     * @param {AIUsageLogUpdateArgs} args - Arguments to update one AIUsageLog.
     * @example
     * // Update one AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIUsageLogUpdateArgs>(args: SelectSubset<T, AIUsageLogUpdateArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIUsageLogs.
     * @param {AIUsageLogDeleteManyArgs} args - Arguments to filter AIUsageLogs to delete.
     * @example
     * // Delete a few AIUsageLogs
     * const { count } = await prisma.aIUsageLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIUsageLogDeleteManyArgs>(args?: SelectSubset<T, AIUsageLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIUsageLogs
     * const aIUsageLog = await prisma.aIUsageLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIUsageLogUpdateManyArgs>(args: SelectSubset<T, AIUsageLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIUsageLogs and returns the data updated in the database.
     * @param {AIUsageLogUpdateManyAndReturnArgs} args - Arguments to update many AIUsageLogs.
     * @example
     * // Update many AIUsageLogs
     * const aIUsageLog = await prisma.aIUsageLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIUsageLogs and only return the `id`
     * const aIUsageLogWithIdOnly = await prisma.aIUsageLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIUsageLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AIUsageLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIUsageLog.
     * @param {AIUsageLogUpsertArgs} args - Arguments to update or create a AIUsageLog.
     * @example
     * // Update or create a AIUsageLog
     * const aIUsageLog = await prisma.aIUsageLog.upsert({
     *   create: {
     *     // ... data to create a AIUsageLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIUsageLog we want to update
     *   }
     * })
     */
    upsert<T extends AIUsageLogUpsertArgs>(args: SelectSubset<T, AIUsageLogUpsertArgs<ExtArgs>>): Prisma__AIUsageLogClient<$Result.GetResult<Prisma.$AIUsageLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogCountArgs} args - Arguments to filter AIUsageLogs to count.
     * @example
     * // Count the number of AIUsageLogs
     * const count = await prisma.aIUsageLog.count({
     *   where: {
     *     // ... the filter for the AIUsageLogs we want to count
     *   }
     * })
    **/
    count<T extends AIUsageLogCountArgs>(
      args?: Subset<T, AIUsageLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIUsageLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIUsageLogAggregateArgs>(args: Subset<T, AIUsageLogAggregateArgs>): Prisma.PrismaPromise<GetAIUsageLogAggregateType<T>>

    /**
     * Group by AIUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIUsageLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIUsageLogGroupByArgs['orderBy'] }
        : { orderBy?: AIUsageLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIUsageLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIUsageLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIUsageLog model
   */
  readonly fields: AIUsageLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIUsageLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIUsageLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIUsageLog model
   */
  interface AIUsageLogFieldRefs {
    readonly id: FieldRef<"AIUsageLog", 'String'>
    readonly providerId: FieldRef<"AIUsageLog", 'String'>
    readonly userId: FieldRef<"AIUsageLog", 'String'>
    readonly feature: FieldRef<"AIUsageLog", 'String'>
    readonly tokensUsed: FieldRef<"AIUsageLog", 'Int'>
    readonly promptHash: FieldRef<"AIUsageLog", 'String'>
    readonly createdAt: FieldRef<"AIUsageLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIUsageLog findUnique
   */
  export type AIUsageLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Filter, which AIUsageLog to fetch.
     */
    where: AIUsageLogWhereUniqueInput
  }

  /**
   * AIUsageLog findUniqueOrThrow
   */
  export type AIUsageLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Filter, which AIUsageLog to fetch.
     */
    where: AIUsageLogWhereUniqueInput
  }

  /**
   * AIUsageLog findFirst
   */
  export type AIUsageLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Filter, which AIUsageLog to fetch.
     */
    where?: AIUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageLogs to fetch.
     */
    orderBy?: AIUsageLogOrderByWithRelationInput | AIUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIUsageLogs.
     */
    cursor?: AIUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIUsageLogs.
     */
    distinct?: AIUsageLogScalarFieldEnum | AIUsageLogScalarFieldEnum[]
  }

  /**
   * AIUsageLog findFirstOrThrow
   */
  export type AIUsageLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Filter, which AIUsageLog to fetch.
     */
    where?: AIUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageLogs to fetch.
     */
    orderBy?: AIUsageLogOrderByWithRelationInput | AIUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIUsageLogs.
     */
    cursor?: AIUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIUsageLogs.
     */
    distinct?: AIUsageLogScalarFieldEnum | AIUsageLogScalarFieldEnum[]
  }

  /**
   * AIUsageLog findMany
   */
  export type AIUsageLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Filter, which AIUsageLogs to fetch.
     */
    where?: AIUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageLogs to fetch.
     */
    orderBy?: AIUsageLogOrderByWithRelationInput | AIUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIUsageLogs.
     */
    cursor?: AIUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageLogs.
     */
    skip?: number
    distinct?: AIUsageLogScalarFieldEnum | AIUsageLogScalarFieldEnum[]
  }

  /**
   * AIUsageLog create
   */
  export type AIUsageLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * The data needed to create a AIUsageLog.
     */
    data: XOR<AIUsageLogCreateInput, AIUsageLogUncheckedCreateInput>
  }

  /**
   * AIUsageLog createMany
   */
  export type AIUsageLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIUsageLogs.
     */
    data: AIUsageLogCreateManyInput | AIUsageLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIUsageLog createManyAndReturn
   */
  export type AIUsageLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * The data used to create many AIUsageLogs.
     */
    data: AIUsageLogCreateManyInput | AIUsageLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIUsageLog update
   */
  export type AIUsageLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * The data needed to update a AIUsageLog.
     */
    data: XOR<AIUsageLogUpdateInput, AIUsageLogUncheckedUpdateInput>
    /**
     * Choose, which AIUsageLog to update.
     */
    where: AIUsageLogWhereUniqueInput
  }

  /**
   * AIUsageLog updateMany
   */
  export type AIUsageLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIUsageLogs.
     */
    data: XOR<AIUsageLogUpdateManyMutationInput, AIUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which AIUsageLogs to update
     */
    where?: AIUsageLogWhereInput
    /**
     * Limit how many AIUsageLogs to update.
     */
    limit?: number
  }

  /**
   * AIUsageLog updateManyAndReturn
   */
  export type AIUsageLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * The data used to update AIUsageLogs.
     */
    data: XOR<AIUsageLogUpdateManyMutationInput, AIUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which AIUsageLogs to update
     */
    where?: AIUsageLogWhereInput
    /**
     * Limit how many AIUsageLogs to update.
     */
    limit?: number
  }

  /**
   * AIUsageLog upsert
   */
  export type AIUsageLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * The filter to search for the AIUsageLog to update in case it exists.
     */
    where: AIUsageLogWhereUniqueInput
    /**
     * In case the AIUsageLog found by the `where` argument doesn't exist, create a new AIUsageLog with this data.
     */
    create: XOR<AIUsageLogCreateInput, AIUsageLogUncheckedCreateInput>
    /**
     * In case the AIUsageLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIUsageLogUpdateInput, AIUsageLogUncheckedUpdateInput>
  }

  /**
   * AIUsageLog delete
   */
  export type AIUsageLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
    /**
     * Filter which AIUsageLog to delete.
     */
    where: AIUsageLogWhereUniqueInput
  }

  /**
   * AIUsageLog deleteMany
   */
  export type AIUsageLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIUsageLogs to delete
     */
    where?: AIUsageLogWhereInput
    /**
     * Limit how many AIUsageLogs to delete.
     */
    limit?: number
  }

  /**
   * AIUsageLog without action
   */
  export type AIUsageLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageLog
     */
    select?: AIUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageLog
     */
    omit?: AIUsageLogOmit<ExtArgs> | null
  }


  /**
   * Model VideoIntegration
   */

  export type AggregateVideoIntegration = {
    _count: VideoIntegrationCountAggregateOutputType | null
    _min: VideoIntegrationMinAggregateOutputType | null
    _max: VideoIntegrationMaxAggregateOutputType | null
  }

  export type VideoIntegrationMinAggregateOutputType = {
    id: string | null
    platform: string | null
    name: string | null
    clientId: string | null
    clientSecret: string | null
    apiKey: string | null
    accessToken: string | null
    refreshToken: string | null
    tokenExpiry: Date | null
    isActive: boolean | null
    webhookUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoIntegrationMaxAggregateOutputType = {
    id: string | null
    platform: string | null
    name: string | null
    clientId: string | null
    clientSecret: string | null
    apiKey: string | null
    accessToken: string | null
    refreshToken: string | null
    tokenExpiry: Date | null
    isActive: boolean | null
    webhookUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoIntegrationCountAggregateOutputType = {
    id: number
    platform: number
    name: number
    clientId: number
    clientSecret: number
    apiKey: number
    accessToken: number
    refreshToken: number
    tokenExpiry: number
    isActive: number
    webhookUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VideoIntegrationMinAggregateInputType = {
    id?: true
    platform?: true
    name?: true
    clientId?: true
    clientSecret?: true
    apiKey?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiry?: true
    isActive?: true
    webhookUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoIntegrationMaxAggregateInputType = {
    id?: true
    platform?: true
    name?: true
    clientId?: true
    clientSecret?: true
    apiKey?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiry?: true
    isActive?: true
    webhookUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoIntegrationCountAggregateInputType = {
    id?: true
    platform?: true
    name?: true
    clientId?: true
    clientSecret?: true
    apiKey?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiry?: true
    isActive?: true
    webhookUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VideoIntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoIntegration to aggregate.
     */
    where?: VideoIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoIntegrations to fetch.
     */
    orderBy?: VideoIntegrationOrderByWithRelationInput | VideoIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoIntegrations
    **/
    _count?: true | VideoIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoIntegrationMaxAggregateInputType
  }

  export type GetVideoIntegrationAggregateType<T extends VideoIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoIntegration[P]>
      : GetScalarType<T[P], AggregateVideoIntegration[P]>
  }




  export type VideoIntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoIntegrationWhereInput
    orderBy?: VideoIntegrationOrderByWithAggregationInput | VideoIntegrationOrderByWithAggregationInput[]
    by: VideoIntegrationScalarFieldEnum[] | VideoIntegrationScalarFieldEnum
    having?: VideoIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoIntegrationCountAggregateInputType | true
    _min?: VideoIntegrationMinAggregateInputType
    _max?: VideoIntegrationMaxAggregateInputType
  }

  export type VideoIntegrationGroupByOutputType = {
    id: string
    platform: string
    name: string
    clientId: string | null
    clientSecret: string | null
    apiKey: string | null
    accessToken: string | null
    refreshToken: string | null
    tokenExpiry: Date | null
    isActive: boolean
    webhookUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: VideoIntegrationCountAggregateOutputType | null
    _min: VideoIntegrationMinAggregateOutputType | null
    _max: VideoIntegrationMaxAggregateOutputType | null
  }

  type GetVideoIntegrationGroupByPayload<T extends VideoIntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], VideoIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type VideoIntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    name?: boolean
    clientId?: boolean
    clientSecret?: boolean
    apiKey?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiry?: boolean
    isActive?: boolean
    webhookUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["videoIntegration"]>

  export type VideoIntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    name?: boolean
    clientId?: boolean
    clientSecret?: boolean
    apiKey?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiry?: boolean
    isActive?: boolean
    webhookUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["videoIntegration"]>

  export type VideoIntegrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    name?: boolean
    clientId?: boolean
    clientSecret?: boolean
    apiKey?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiry?: boolean
    isActive?: boolean
    webhookUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["videoIntegration"]>

  export type VideoIntegrationSelectScalar = {
    id?: boolean
    platform?: boolean
    name?: boolean
    clientId?: boolean
    clientSecret?: boolean
    apiKey?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiry?: boolean
    isActive?: boolean
    webhookUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VideoIntegrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "platform" | "name" | "clientId" | "clientSecret" | "apiKey" | "accessToken" | "refreshToken" | "tokenExpiry" | "isActive" | "webhookUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["videoIntegration"]>

  export type $VideoIntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoIntegration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      platform: string
      name: string
      clientId: string | null
      clientSecret: string | null
      apiKey: string | null
      accessToken: string | null
      refreshToken: string | null
      tokenExpiry: Date | null
      isActive: boolean
      webhookUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["videoIntegration"]>
    composites: {}
  }

  type VideoIntegrationGetPayload<S extends boolean | null | undefined | VideoIntegrationDefaultArgs> = $Result.GetResult<Prisma.$VideoIntegrationPayload, S>

  type VideoIntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideoIntegrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideoIntegrationCountAggregateInputType | true
    }

  export interface VideoIntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoIntegration'], meta: { name: 'VideoIntegration' } }
    /**
     * Find zero or one VideoIntegration that matches the filter.
     * @param {VideoIntegrationFindUniqueArgs} args - Arguments to find a VideoIntegration
     * @example
     * // Get one VideoIntegration
     * const videoIntegration = await prisma.videoIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoIntegrationFindUniqueArgs>(args: SelectSubset<T, VideoIntegrationFindUniqueArgs<ExtArgs>>): Prisma__VideoIntegrationClient<$Result.GetResult<Prisma.$VideoIntegrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VideoIntegration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideoIntegrationFindUniqueOrThrowArgs} args - Arguments to find a VideoIntegration
     * @example
     * // Get one VideoIntegration
     * const videoIntegration = await prisma.videoIntegration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoIntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoIntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoIntegrationClient<$Result.GetResult<Prisma.$VideoIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoIntegrationFindFirstArgs} args - Arguments to find a VideoIntegration
     * @example
     * // Get one VideoIntegration
     * const videoIntegration = await prisma.videoIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoIntegrationFindFirstArgs>(args?: SelectSubset<T, VideoIntegrationFindFirstArgs<ExtArgs>>): Prisma__VideoIntegrationClient<$Result.GetResult<Prisma.$VideoIntegrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoIntegration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoIntegrationFindFirstOrThrowArgs} args - Arguments to find a VideoIntegration
     * @example
     * // Get one VideoIntegration
     * const videoIntegration = await prisma.videoIntegration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoIntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoIntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoIntegrationClient<$Result.GetResult<Prisma.$VideoIntegrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VideoIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoIntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoIntegrations
     * const videoIntegrations = await prisma.videoIntegration.findMany()
     * 
     * // Get first 10 VideoIntegrations
     * const videoIntegrations = await prisma.videoIntegration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoIntegrationWithIdOnly = await prisma.videoIntegration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoIntegrationFindManyArgs>(args?: SelectSubset<T, VideoIntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoIntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VideoIntegration.
     * @param {VideoIntegrationCreateArgs} args - Arguments to create a VideoIntegration.
     * @example
     * // Create one VideoIntegration
     * const VideoIntegration = await prisma.videoIntegration.create({
     *   data: {
     *     // ... data to create a VideoIntegration
     *   }
     * })
     * 
     */
    create<T extends VideoIntegrationCreateArgs>(args: SelectSubset<T, VideoIntegrationCreateArgs<ExtArgs>>): Prisma__VideoIntegrationClient<$Result.GetResult<Prisma.$VideoIntegrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VideoIntegrations.
     * @param {VideoIntegrationCreateManyArgs} args - Arguments to create many VideoIntegrations.
     * @example
     * // Create many VideoIntegrations
     * const videoIntegration = await prisma.videoIntegration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoIntegrationCreateManyArgs>(args?: SelectSubset<T, VideoIntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoIntegrations and returns the data saved in the database.
     * @param {VideoIntegrationCreateManyAndReturnArgs} args - Arguments to create many VideoIntegrations.
     * @example
     * // Create many VideoIntegrations
     * const videoIntegration = await prisma.videoIntegration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoIntegrations and only return the `id`
     * const videoIntegrationWithIdOnly = await prisma.videoIntegration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoIntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoIntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoIntegrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VideoIntegration.
     * @param {VideoIntegrationDeleteArgs} args - Arguments to delete one VideoIntegration.
     * @example
     * // Delete one VideoIntegration
     * const VideoIntegration = await prisma.videoIntegration.delete({
     *   where: {
     *     // ... filter to delete one VideoIntegration
     *   }
     * })
     * 
     */
    delete<T extends VideoIntegrationDeleteArgs>(args: SelectSubset<T, VideoIntegrationDeleteArgs<ExtArgs>>): Prisma__VideoIntegrationClient<$Result.GetResult<Prisma.$VideoIntegrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VideoIntegration.
     * @param {VideoIntegrationUpdateArgs} args - Arguments to update one VideoIntegration.
     * @example
     * // Update one VideoIntegration
     * const videoIntegration = await prisma.videoIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoIntegrationUpdateArgs>(args: SelectSubset<T, VideoIntegrationUpdateArgs<ExtArgs>>): Prisma__VideoIntegrationClient<$Result.GetResult<Prisma.$VideoIntegrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VideoIntegrations.
     * @param {VideoIntegrationDeleteManyArgs} args - Arguments to filter VideoIntegrations to delete.
     * @example
     * // Delete a few VideoIntegrations
     * const { count } = await prisma.videoIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoIntegrationDeleteManyArgs>(args?: SelectSubset<T, VideoIntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoIntegrations
     * const videoIntegration = await prisma.videoIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoIntegrationUpdateManyArgs>(args: SelectSubset<T, VideoIntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoIntegrations and returns the data updated in the database.
     * @param {VideoIntegrationUpdateManyAndReturnArgs} args - Arguments to update many VideoIntegrations.
     * @example
     * // Update many VideoIntegrations
     * const videoIntegration = await prisma.videoIntegration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VideoIntegrations and only return the `id`
     * const videoIntegrationWithIdOnly = await prisma.videoIntegration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VideoIntegrationUpdateManyAndReturnArgs>(args: SelectSubset<T, VideoIntegrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoIntegrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VideoIntegration.
     * @param {VideoIntegrationUpsertArgs} args - Arguments to update or create a VideoIntegration.
     * @example
     * // Update or create a VideoIntegration
     * const videoIntegration = await prisma.videoIntegration.upsert({
     *   create: {
     *     // ... data to create a VideoIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoIntegration we want to update
     *   }
     * })
     */
    upsert<T extends VideoIntegrationUpsertArgs>(args: SelectSubset<T, VideoIntegrationUpsertArgs<ExtArgs>>): Prisma__VideoIntegrationClient<$Result.GetResult<Prisma.$VideoIntegrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VideoIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoIntegrationCountArgs} args - Arguments to filter VideoIntegrations to count.
     * @example
     * // Count the number of VideoIntegrations
     * const count = await prisma.videoIntegration.count({
     *   where: {
     *     // ... the filter for the VideoIntegrations we want to count
     *   }
     * })
    **/
    count<T extends VideoIntegrationCountArgs>(
      args?: Subset<T, VideoIntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoIntegrationAggregateArgs>(args: Subset<T, VideoIntegrationAggregateArgs>): Prisma.PrismaPromise<GetVideoIntegrationAggregateType<T>>

    /**
     * Group by VideoIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: VideoIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoIntegration model
   */
  readonly fields: VideoIntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoIntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoIntegration model
   */
  interface VideoIntegrationFieldRefs {
    readonly id: FieldRef<"VideoIntegration", 'String'>
    readonly platform: FieldRef<"VideoIntegration", 'String'>
    readonly name: FieldRef<"VideoIntegration", 'String'>
    readonly clientId: FieldRef<"VideoIntegration", 'String'>
    readonly clientSecret: FieldRef<"VideoIntegration", 'String'>
    readonly apiKey: FieldRef<"VideoIntegration", 'String'>
    readonly accessToken: FieldRef<"VideoIntegration", 'String'>
    readonly refreshToken: FieldRef<"VideoIntegration", 'String'>
    readonly tokenExpiry: FieldRef<"VideoIntegration", 'DateTime'>
    readonly isActive: FieldRef<"VideoIntegration", 'Boolean'>
    readonly webhookUrl: FieldRef<"VideoIntegration", 'String'>
    readonly createdAt: FieldRef<"VideoIntegration", 'DateTime'>
    readonly updatedAt: FieldRef<"VideoIntegration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VideoIntegration findUnique
   */
  export type VideoIntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoIntegration
     */
    select?: VideoIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoIntegration
     */
    omit?: VideoIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which VideoIntegration to fetch.
     */
    where: VideoIntegrationWhereUniqueInput
  }

  /**
   * VideoIntegration findUniqueOrThrow
   */
  export type VideoIntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoIntegration
     */
    select?: VideoIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoIntegration
     */
    omit?: VideoIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which VideoIntegration to fetch.
     */
    where: VideoIntegrationWhereUniqueInput
  }

  /**
   * VideoIntegration findFirst
   */
  export type VideoIntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoIntegration
     */
    select?: VideoIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoIntegration
     */
    omit?: VideoIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which VideoIntegration to fetch.
     */
    where?: VideoIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoIntegrations to fetch.
     */
    orderBy?: VideoIntegrationOrderByWithRelationInput | VideoIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoIntegrations.
     */
    cursor?: VideoIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoIntegrations.
     */
    distinct?: VideoIntegrationScalarFieldEnum | VideoIntegrationScalarFieldEnum[]
  }

  /**
   * VideoIntegration findFirstOrThrow
   */
  export type VideoIntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoIntegration
     */
    select?: VideoIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoIntegration
     */
    omit?: VideoIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which VideoIntegration to fetch.
     */
    where?: VideoIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoIntegrations to fetch.
     */
    orderBy?: VideoIntegrationOrderByWithRelationInput | VideoIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoIntegrations.
     */
    cursor?: VideoIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoIntegrations.
     */
    distinct?: VideoIntegrationScalarFieldEnum | VideoIntegrationScalarFieldEnum[]
  }

  /**
   * VideoIntegration findMany
   */
  export type VideoIntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoIntegration
     */
    select?: VideoIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoIntegration
     */
    omit?: VideoIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which VideoIntegrations to fetch.
     */
    where?: VideoIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoIntegrations to fetch.
     */
    orderBy?: VideoIntegrationOrderByWithRelationInput | VideoIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoIntegrations.
     */
    cursor?: VideoIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoIntegrations.
     */
    skip?: number
    distinct?: VideoIntegrationScalarFieldEnum | VideoIntegrationScalarFieldEnum[]
  }

  /**
   * VideoIntegration create
   */
  export type VideoIntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoIntegration
     */
    select?: VideoIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoIntegration
     */
    omit?: VideoIntegrationOmit<ExtArgs> | null
    /**
     * The data needed to create a VideoIntegration.
     */
    data: XOR<VideoIntegrationCreateInput, VideoIntegrationUncheckedCreateInput>
  }

  /**
   * VideoIntegration createMany
   */
  export type VideoIntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoIntegrations.
     */
    data: VideoIntegrationCreateManyInput | VideoIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoIntegration createManyAndReturn
   */
  export type VideoIntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoIntegration
     */
    select?: VideoIntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoIntegration
     */
    omit?: VideoIntegrationOmit<ExtArgs> | null
    /**
     * The data used to create many VideoIntegrations.
     */
    data: VideoIntegrationCreateManyInput | VideoIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoIntegration update
   */
  export type VideoIntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoIntegration
     */
    select?: VideoIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoIntegration
     */
    omit?: VideoIntegrationOmit<ExtArgs> | null
    /**
     * The data needed to update a VideoIntegration.
     */
    data: XOR<VideoIntegrationUpdateInput, VideoIntegrationUncheckedUpdateInput>
    /**
     * Choose, which VideoIntegration to update.
     */
    where: VideoIntegrationWhereUniqueInput
  }

  /**
   * VideoIntegration updateMany
   */
  export type VideoIntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoIntegrations.
     */
    data: XOR<VideoIntegrationUpdateManyMutationInput, VideoIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which VideoIntegrations to update
     */
    where?: VideoIntegrationWhereInput
    /**
     * Limit how many VideoIntegrations to update.
     */
    limit?: number
  }

  /**
   * VideoIntegration updateManyAndReturn
   */
  export type VideoIntegrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoIntegration
     */
    select?: VideoIntegrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoIntegration
     */
    omit?: VideoIntegrationOmit<ExtArgs> | null
    /**
     * The data used to update VideoIntegrations.
     */
    data: XOR<VideoIntegrationUpdateManyMutationInput, VideoIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which VideoIntegrations to update
     */
    where?: VideoIntegrationWhereInput
    /**
     * Limit how many VideoIntegrations to update.
     */
    limit?: number
  }

  /**
   * VideoIntegration upsert
   */
  export type VideoIntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoIntegration
     */
    select?: VideoIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoIntegration
     */
    omit?: VideoIntegrationOmit<ExtArgs> | null
    /**
     * The filter to search for the VideoIntegration to update in case it exists.
     */
    where: VideoIntegrationWhereUniqueInput
    /**
     * In case the VideoIntegration found by the `where` argument doesn't exist, create a new VideoIntegration with this data.
     */
    create: XOR<VideoIntegrationCreateInput, VideoIntegrationUncheckedCreateInput>
    /**
     * In case the VideoIntegration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoIntegrationUpdateInput, VideoIntegrationUncheckedUpdateInput>
  }

  /**
   * VideoIntegration delete
   */
  export type VideoIntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoIntegration
     */
    select?: VideoIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoIntegration
     */
    omit?: VideoIntegrationOmit<ExtArgs> | null
    /**
     * Filter which VideoIntegration to delete.
     */
    where: VideoIntegrationWhereUniqueInput
  }

  /**
   * VideoIntegration deleteMany
   */
  export type VideoIntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoIntegrations to delete
     */
    where?: VideoIntegrationWhereInput
    /**
     * Limit how many VideoIntegrations to delete.
     */
    limit?: number
  }

  /**
   * VideoIntegration without action
   */
  export type VideoIntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoIntegration
     */
    select?: VideoIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoIntegration
     */
    omit?: VideoIntegrationOmit<ExtArgs> | null
  }


  /**
   * Model LiveClass
   */

  export type AggregateLiveClass = {
    _count: LiveClassCountAggregateOutputType | null
    _avg: LiveClassAvgAggregateOutputType | null
    _sum: LiveClassSumAggregateOutputType | null
    _min: LiveClassMinAggregateOutputType | null
    _max: LiveClassMaxAggregateOutputType | null
  }

  export type LiveClassAvgAggregateOutputType = {
    duration: number | null
  }

  export type LiveClassSumAggregateOutputType = {
    duration: number | null
  }

  export type LiveClassMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    title: string | null
    description: string | null
    platform: string | null
    meetingLink: string | null
    meetingId: string | null
    password: string | null
    scheduledAt: Date | null
    duration: number | null
    timezone: string | null
    status: $Enums.LiveClassStatus | null
    startedAt: Date | null
    endedAt: Date | null
    recordingUrl: string | null
    recordingPassword: string | null
    hostId: string | null
    hostName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LiveClassMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    title: string | null
    description: string | null
    platform: string | null
    meetingLink: string | null
    meetingId: string | null
    password: string | null
    scheduledAt: Date | null
    duration: number | null
    timezone: string | null
    status: $Enums.LiveClassStatus | null
    startedAt: Date | null
    endedAt: Date | null
    recordingUrl: string | null
    recordingPassword: string | null
    hostId: string | null
    hostName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LiveClassCountAggregateOutputType = {
    id: number
    courseId: number
    title: number
    description: number
    platform: number
    meetingLink: number
    meetingId: number
    password: number
    scheduledAt: number
    duration: number
    timezone: number
    status: number
    startedAt: number
    endedAt: number
    recordingUrl: number
    recordingPassword: number
    hostId: number
    hostName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LiveClassAvgAggregateInputType = {
    duration?: true
  }

  export type LiveClassSumAggregateInputType = {
    duration?: true
  }

  export type LiveClassMinAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    platform?: true
    meetingLink?: true
    meetingId?: true
    password?: true
    scheduledAt?: true
    duration?: true
    timezone?: true
    status?: true
    startedAt?: true
    endedAt?: true
    recordingUrl?: true
    recordingPassword?: true
    hostId?: true
    hostName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LiveClassMaxAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    platform?: true
    meetingLink?: true
    meetingId?: true
    password?: true
    scheduledAt?: true
    duration?: true
    timezone?: true
    status?: true
    startedAt?: true
    endedAt?: true
    recordingUrl?: true
    recordingPassword?: true
    hostId?: true
    hostName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LiveClassCountAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    platform?: true
    meetingLink?: true
    meetingId?: true
    password?: true
    scheduledAt?: true
    duration?: true
    timezone?: true
    status?: true
    startedAt?: true
    endedAt?: true
    recordingUrl?: true
    recordingPassword?: true
    hostId?: true
    hostName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LiveClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiveClass to aggregate.
     */
    where?: LiveClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiveClasses to fetch.
     */
    orderBy?: LiveClassOrderByWithRelationInput | LiveClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LiveClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiveClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiveClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LiveClasses
    **/
    _count?: true | LiveClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LiveClassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LiveClassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiveClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiveClassMaxAggregateInputType
  }

  export type GetLiveClassAggregateType<T extends LiveClassAggregateArgs> = {
        [P in keyof T & keyof AggregateLiveClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiveClass[P]>
      : GetScalarType<T[P], AggregateLiveClass[P]>
  }




  export type LiveClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiveClassWhereInput
    orderBy?: LiveClassOrderByWithAggregationInput | LiveClassOrderByWithAggregationInput[]
    by: LiveClassScalarFieldEnum[] | LiveClassScalarFieldEnum
    having?: LiveClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiveClassCountAggregateInputType | true
    _avg?: LiveClassAvgAggregateInputType
    _sum?: LiveClassSumAggregateInputType
    _min?: LiveClassMinAggregateInputType
    _max?: LiveClassMaxAggregateInputType
  }

  export type LiveClassGroupByOutputType = {
    id: string
    courseId: string
    title: string
    description: string | null
    platform: string
    meetingLink: string | null
    meetingId: string | null
    password: string | null
    scheduledAt: Date
    duration: number
    timezone: string
    status: $Enums.LiveClassStatus
    startedAt: Date | null
    endedAt: Date | null
    recordingUrl: string | null
    recordingPassword: string | null
    hostId: string | null
    hostName: string | null
    createdAt: Date
    updatedAt: Date
    _count: LiveClassCountAggregateOutputType | null
    _avg: LiveClassAvgAggregateOutputType | null
    _sum: LiveClassSumAggregateOutputType | null
    _min: LiveClassMinAggregateOutputType | null
    _max: LiveClassMaxAggregateOutputType | null
  }

  type GetLiveClassGroupByPayload<T extends LiveClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LiveClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LiveClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LiveClassGroupByOutputType[P]>
            : GetScalarType<T[P], LiveClassGroupByOutputType[P]>
        }
      >
    >


  export type LiveClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    platform?: boolean
    meetingLink?: boolean
    meetingId?: boolean
    password?: boolean
    scheduledAt?: boolean
    duration?: boolean
    timezone?: boolean
    status?: boolean
    startedAt?: boolean
    endedAt?: boolean
    recordingUrl?: boolean
    recordingPassword?: boolean
    hostId?: boolean
    hostName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liveClass"]>

  export type LiveClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    platform?: boolean
    meetingLink?: boolean
    meetingId?: boolean
    password?: boolean
    scheduledAt?: boolean
    duration?: boolean
    timezone?: boolean
    status?: boolean
    startedAt?: boolean
    endedAt?: boolean
    recordingUrl?: boolean
    recordingPassword?: boolean
    hostId?: boolean
    hostName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liveClass"]>

  export type LiveClassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    platform?: boolean
    meetingLink?: boolean
    meetingId?: boolean
    password?: boolean
    scheduledAt?: boolean
    duration?: boolean
    timezone?: boolean
    status?: boolean
    startedAt?: boolean
    endedAt?: boolean
    recordingUrl?: boolean
    recordingPassword?: boolean
    hostId?: boolean
    hostName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liveClass"]>

  export type LiveClassSelectScalar = {
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    platform?: boolean
    meetingLink?: boolean
    meetingId?: boolean
    password?: boolean
    scheduledAt?: boolean
    duration?: boolean
    timezone?: boolean
    status?: boolean
    startedAt?: boolean
    endedAt?: boolean
    recordingUrl?: boolean
    recordingPassword?: boolean
    hostId?: boolean
    hostName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LiveClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "title" | "description" | "platform" | "meetingLink" | "meetingId" | "password" | "scheduledAt" | "duration" | "timezone" | "status" | "startedAt" | "endedAt" | "recordingUrl" | "recordingPassword" | "hostId" | "hostName" | "createdAt" | "updatedAt", ExtArgs["result"]["liveClass"]>
  export type LiveClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type LiveClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type LiveClassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $LiveClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LiveClass"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      title: string
      description: string | null
      platform: string
      meetingLink: string | null
      meetingId: string | null
      password: string | null
      scheduledAt: Date
      duration: number
      timezone: string
      status: $Enums.LiveClassStatus
      startedAt: Date | null
      endedAt: Date | null
      recordingUrl: string | null
      recordingPassword: string | null
      hostId: string | null
      hostName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["liveClass"]>
    composites: {}
  }

  type LiveClassGetPayload<S extends boolean | null | undefined | LiveClassDefaultArgs> = $Result.GetResult<Prisma.$LiveClassPayload, S>

  type LiveClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LiveClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LiveClassCountAggregateInputType | true
    }

  export interface LiveClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LiveClass'], meta: { name: 'LiveClass' } }
    /**
     * Find zero or one LiveClass that matches the filter.
     * @param {LiveClassFindUniqueArgs} args - Arguments to find a LiveClass
     * @example
     * // Get one LiveClass
     * const liveClass = await prisma.liveClass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LiveClassFindUniqueArgs>(args: SelectSubset<T, LiveClassFindUniqueArgs<ExtArgs>>): Prisma__LiveClassClient<$Result.GetResult<Prisma.$LiveClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LiveClass that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LiveClassFindUniqueOrThrowArgs} args - Arguments to find a LiveClass
     * @example
     * // Get one LiveClass
     * const liveClass = await prisma.liveClass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LiveClassFindUniqueOrThrowArgs>(args: SelectSubset<T, LiveClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LiveClassClient<$Result.GetResult<Prisma.$LiveClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LiveClass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveClassFindFirstArgs} args - Arguments to find a LiveClass
     * @example
     * // Get one LiveClass
     * const liveClass = await prisma.liveClass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LiveClassFindFirstArgs>(args?: SelectSubset<T, LiveClassFindFirstArgs<ExtArgs>>): Prisma__LiveClassClient<$Result.GetResult<Prisma.$LiveClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LiveClass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveClassFindFirstOrThrowArgs} args - Arguments to find a LiveClass
     * @example
     * // Get one LiveClass
     * const liveClass = await prisma.liveClass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LiveClassFindFirstOrThrowArgs>(args?: SelectSubset<T, LiveClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__LiveClassClient<$Result.GetResult<Prisma.$LiveClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LiveClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LiveClasses
     * const liveClasses = await prisma.liveClass.findMany()
     * 
     * // Get first 10 LiveClasses
     * const liveClasses = await prisma.liveClass.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const liveClassWithIdOnly = await prisma.liveClass.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LiveClassFindManyArgs>(args?: SelectSubset<T, LiveClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiveClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LiveClass.
     * @param {LiveClassCreateArgs} args - Arguments to create a LiveClass.
     * @example
     * // Create one LiveClass
     * const LiveClass = await prisma.liveClass.create({
     *   data: {
     *     // ... data to create a LiveClass
     *   }
     * })
     * 
     */
    create<T extends LiveClassCreateArgs>(args: SelectSubset<T, LiveClassCreateArgs<ExtArgs>>): Prisma__LiveClassClient<$Result.GetResult<Prisma.$LiveClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LiveClasses.
     * @param {LiveClassCreateManyArgs} args - Arguments to create many LiveClasses.
     * @example
     * // Create many LiveClasses
     * const liveClass = await prisma.liveClass.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LiveClassCreateManyArgs>(args?: SelectSubset<T, LiveClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LiveClasses and returns the data saved in the database.
     * @param {LiveClassCreateManyAndReturnArgs} args - Arguments to create many LiveClasses.
     * @example
     * // Create many LiveClasses
     * const liveClass = await prisma.liveClass.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LiveClasses and only return the `id`
     * const liveClassWithIdOnly = await prisma.liveClass.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LiveClassCreateManyAndReturnArgs>(args?: SelectSubset<T, LiveClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiveClassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LiveClass.
     * @param {LiveClassDeleteArgs} args - Arguments to delete one LiveClass.
     * @example
     * // Delete one LiveClass
     * const LiveClass = await prisma.liveClass.delete({
     *   where: {
     *     // ... filter to delete one LiveClass
     *   }
     * })
     * 
     */
    delete<T extends LiveClassDeleteArgs>(args: SelectSubset<T, LiveClassDeleteArgs<ExtArgs>>): Prisma__LiveClassClient<$Result.GetResult<Prisma.$LiveClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LiveClass.
     * @param {LiveClassUpdateArgs} args - Arguments to update one LiveClass.
     * @example
     * // Update one LiveClass
     * const liveClass = await prisma.liveClass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LiveClassUpdateArgs>(args: SelectSubset<T, LiveClassUpdateArgs<ExtArgs>>): Prisma__LiveClassClient<$Result.GetResult<Prisma.$LiveClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LiveClasses.
     * @param {LiveClassDeleteManyArgs} args - Arguments to filter LiveClasses to delete.
     * @example
     * // Delete a few LiveClasses
     * const { count } = await prisma.liveClass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LiveClassDeleteManyArgs>(args?: SelectSubset<T, LiveClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiveClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LiveClasses
     * const liveClass = await prisma.liveClass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LiveClassUpdateManyArgs>(args: SelectSubset<T, LiveClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiveClasses and returns the data updated in the database.
     * @param {LiveClassUpdateManyAndReturnArgs} args - Arguments to update many LiveClasses.
     * @example
     * // Update many LiveClasses
     * const liveClass = await prisma.liveClass.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LiveClasses and only return the `id`
     * const liveClassWithIdOnly = await prisma.liveClass.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LiveClassUpdateManyAndReturnArgs>(args: SelectSubset<T, LiveClassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiveClassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LiveClass.
     * @param {LiveClassUpsertArgs} args - Arguments to update or create a LiveClass.
     * @example
     * // Update or create a LiveClass
     * const liveClass = await prisma.liveClass.upsert({
     *   create: {
     *     // ... data to create a LiveClass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LiveClass we want to update
     *   }
     * })
     */
    upsert<T extends LiveClassUpsertArgs>(args: SelectSubset<T, LiveClassUpsertArgs<ExtArgs>>): Prisma__LiveClassClient<$Result.GetResult<Prisma.$LiveClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LiveClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveClassCountArgs} args - Arguments to filter LiveClasses to count.
     * @example
     * // Count the number of LiveClasses
     * const count = await prisma.liveClass.count({
     *   where: {
     *     // ... the filter for the LiveClasses we want to count
     *   }
     * })
    **/
    count<T extends LiveClassCountArgs>(
      args?: Subset<T, LiveClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiveClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LiveClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiveClassAggregateArgs>(args: Subset<T, LiveClassAggregateArgs>): Prisma.PrismaPromise<GetLiveClassAggregateType<T>>

    /**
     * Group by LiveClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiveClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiveClassGroupByArgs['orderBy'] }
        : { orderBy?: LiveClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiveClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiveClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LiveClass model
   */
  readonly fields: LiveClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LiveClass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LiveClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LiveClass model
   */
  interface LiveClassFieldRefs {
    readonly id: FieldRef<"LiveClass", 'String'>
    readonly courseId: FieldRef<"LiveClass", 'String'>
    readonly title: FieldRef<"LiveClass", 'String'>
    readonly description: FieldRef<"LiveClass", 'String'>
    readonly platform: FieldRef<"LiveClass", 'String'>
    readonly meetingLink: FieldRef<"LiveClass", 'String'>
    readonly meetingId: FieldRef<"LiveClass", 'String'>
    readonly password: FieldRef<"LiveClass", 'String'>
    readonly scheduledAt: FieldRef<"LiveClass", 'DateTime'>
    readonly duration: FieldRef<"LiveClass", 'Int'>
    readonly timezone: FieldRef<"LiveClass", 'String'>
    readonly status: FieldRef<"LiveClass", 'LiveClassStatus'>
    readonly startedAt: FieldRef<"LiveClass", 'DateTime'>
    readonly endedAt: FieldRef<"LiveClass", 'DateTime'>
    readonly recordingUrl: FieldRef<"LiveClass", 'String'>
    readonly recordingPassword: FieldRef<"LiveClass", 'String'>
    readonly hostId: FieldRef<"LiveClass", 'String'>
    readonly hostName: FieldRef<"LiveClass", 'String'>
    readonly createdAt: FieldRef<"LiveClass", 'DateTime'>
    readonly updatedAt: FieldRef<"LiveClass", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LiveClass findUnique
   */
  export type LiveClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveClass
     */
    select?: LiveClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiveClass
     */
    omit?: LiveClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveClassInclude<ExtArgs> | null
    /**
     * Filter, which LiveClass to fetch.
     */
    where: LiveClassWhereUniqueInput
  }

  /**
   * LiveClass findUniqueOrThrow
   */
  export type LiveClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveClass
     */
    select?: LiveClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiveClass
     */
    omit?: LiveClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveClassInclude<ExtArgs> | null
    /**
     * Filter, which LiveClass to fetch.
     */
    where: LiveClassWhereUniqueInput
  }

  /**
   * LiveClass findFirst
   */
  export type LiveClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveClass
     */
    select?: LiveClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiveClass
     */
    omit?: LiveClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveClassInclude<ExtArgs> | null
    /**
     * Filter, which LiveClass to fetch.
     */
    where?: LiveClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiveClasses to fetch.
     */
    orderBy?: LiveClassOrderByWithRelationInput | LiveClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiveClasses.
     */
    cursor?: LiveClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiveClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiveClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiveClasses.
     */
    distinct?: LiveClassScalarFieldEnum | LiveClassScalarFieldEnum[]
  }

  /**
   * LiveClass findFirstOrThrow
   */
  export type LiveClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveClass
     */
    select?: LiveClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiveClass
     */
    omit?: LiveClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveClassInclude<ExtArgs> | null
    /**
     * Filter, which LiveClass to fetch.
     */
    where?: LiveClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiveClasses to fetch.
     */
    orderBy?: LiveClassOrderByWithRelationInput | LiveClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiveClasses.
     */
    cursor?: LiveClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiveClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiveClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiveClasses.
     */
    distinct?: LiveClassScalarFieldEnum | LiveClassScalarFieldEnum[]
  }

  /**
   * LiveClass findMany
   */
  export type LiveClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveClass
     */
    select?: LiveClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiveClass
     */
    omit?: LiveClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveClassInclude<ExtArgs> | null
    /**
     * Filter, which LiveClasses to fetch.
     */
    where?: LiveClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiveClasses to fetch.
     */
    orderBy?: LiveClassOrderByWithRelationInput | LiveClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LiveClasses.
     */
    cursor?: LiveClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiveClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiveClasses.
     */
    skip?: number
    distinct?: LiveClassScalarFieldEnum | LiveClassScalarFieldEnum[]
  }

  /**
   * LiveClass create
   */
  export type LiveClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveClass
     */
    select?: LiveClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiveClass
     */
    omit?: LiveClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveClassInclude<ExtArgs> | null
    /**
     * The data needed to create a LiveClass.
     */
    data: XOR<LiveClassCreateInput, LiveClassUncheckedCreateInput>
  }

  /**
   * LiveClass createMany
   */
  export type LiveClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LiveClasses.
     */
    data: LiveClassCreateManyInput | LiveClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LiveClass createManyAndReturn
   */
  export type LiveClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveClass
     */
    select?: LiveClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiveClass
     */
    omit?: LiveClassOmit<ExtArgs> | null
    /**
     * The data used to create many LiveClasses.
     */
    data: LiveClassCreateManyInput | LiveClassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiveClass update
   */
  export type LiveClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveClass
     */
    select?: LiveClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiveClass
     */
    omit?: LiveClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveClassInclude<ExtArgs> | null
    /**
     * The data needed to update a LiveClass.
     */
    data: XOR<LiveClassUpdateInput, LiveClassUncheckedUpdateInput>
    /**
     * Choose, which LiveClass to update.
     */
    where: LiveClassWhereUniqueInput
  }

  /**
   * LiveClass updateMany
   */
  export type LiveClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LiveClasses.
     */
    data: XOR<LiveClassUpdateManyMutationInput, LiveClassUncheckedUpdateManyInput>
    /**
     * Filter which LiveClasses to update
     */
    where?: LiveClassWhereInput
    /**
     * Limit how many LiveClasses to update.
     */
    limit?: number
  }

  /**
   * LiveClass updateManyAndReturn
   */
  export type LiveClassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveClass
     */
    select?: LiveClassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LiveClass
     */
    omit?: LiveClassOmit<ExtArgs> | null
    /**
     * The data used to update LiveClasses.
     */
    data: XOR<LiveClassUpdateManyMutationInput, LiveClassUncheckedUpdateManyInput>
    /**
     * Filter which LiveClasses to update
     */
    where?: LiveClassWhereInput
    /**
     * Limit how many LiveClasses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveClassIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiveClass upsert
   */
  export type LiveClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveClass
     */
    select?: LiveClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiveClass
     */
    omit?: LiveClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveClassInclude<ExtArgs> | null
    /**
     * The filter to search for the LiveClass to update in case it exists.
     */
    where: LiveClassWhereUniqueInput
    /**
     * In case the LiveClass found by the `where` argument doesn't exist, create a new LiveClass with this data.
     */
    create: XOR<LiveClassCreateInput, LiveClassUncheckedCreateInput>
    /**
     * In case the LiveClass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LiveClassUpdateInput, LiveClassUncheckedUpdateInput>
  }

  /**
   * LiveClass delete
   */
  export type LiveClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveClass
     */
    select?: LiveClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiveClass
     */
    omit?: LiveClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveClassInclude<ExtArgs> | null
    /**
     * Filter which LiveClass to delete.
     */
    where: LiveClassWhereUniqueInput
  }

  /**
   * LiveClass deleteMany
   */
  export type LiveClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiveClasses to delete
     */
    where?: LiveClassWhereInput
    /**
     * Limit how many LiveClasses to delete.
     */
    limit?: number
  }

  /**
   * LiveClass without action
   */
  export type LiveClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveClass
     */
    select?: LiveClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LiveClass
     */
    omit?: LiveClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveClassInclude<ExtArgs> | null
  }


  /**
   * Model Lead
   */

  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    college: string | null
    qualification: string | null
    dob: Date | null
    location: string | null
    gender: string | null
    source: string | null
    status: $Enums.LeadStatus | null
    notes: string | null
    assignedTo: string | null
    platform: string | null
    campaignId: string | null
    adGroupId: string | null
    adId: string | null
    formId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    college: string | null
    qualification: string | null
    dob: Date | null
    location: string | null
    gender: string | null
    source: string | null
    status: $Enums.LeadStatus | null
    notes: string | null
    assignedTo: string | null
    platform: string | null
    campaignId: string | null
    adGroupId: string | null
    adId: string | null
    formId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    college: number
    qualification: number
    dob: number
    location: number
    gender: number
    source: number
    status: number
    notes: number
    assignedTo: number
    platform: number
    campaignId: number
    adGroupId: number
    adId: number
    formId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeadMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    college?: true
    qualification?: true
    dob?: true
    location?: true
    gender?: true
    source?: true
    status?: true
    notes?: true
    assignedTo?: true
    platform?: true
    campaignId?: true
    adGroupId?: true
    adId?: true
    formId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    college?: true
    qualification?: true
    dob?: true
    location?: true
    gender?: true
    source?: true
    status?: true
    notes?: true
    assignedTo?: true
    platform?: true
    campaignId?: true
    adGroupId?: true
    adId?: true
    formId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    college?: true
    qualification?: true
    dob?: true
    location?: true
    gender?: true
    source?: true
    status?: true
    notes?: true
    assignedTo?: true
    platform?: true
    campaignId?: true
    adGroupId?: true
    adId?: true
    formId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lead to aggregate.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type LeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithAggregationInput | LeadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: LeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }

  export type LeadGroupByOutputType = {
    id: string
    name: string
    email: string | null
    phone: string | null
    college: string | null
    qualification: string | null
    dob: Date | null
    location: string | null
    gender: string | null
    source: string
    status: $Enums.LeadStatus
    notes: string | null
    assignedTo: string | null
    platform: string | null
    campaignId: string | null
    adGroupId: string | null
    adId: string | null
    formId: string | null
    createdAt: Date
    updatedAt: Date
    _count: LeadCountAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends LeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type LeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    college?: boolean
    qualification?: boolean
    dob?: boolean
    location?: boolean
    gender?: boolean
    source?: boolean
    status?: boolean
    notes?: boolean
    assignedTo?: boolean
    platform?: boolean
    campaignId?: boolean
    adGroupId?: boolean
    adId?: boolean
    formId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tasks?: boolean | Lead$tasksArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    college?: boolean
    qualification?: boolean
    dob?: boolean
    location?: boolean
    gender?: boolean
    source?: boolean
    status?: boolean
    notes?: boolean
    assignedTo?: boolean
    platform?: boolean
    campaignId?: boolean
    adGroupId?: boolean
    adId?: boolean
    formId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    college?: boolean
    qualification?: boolean
    dob?: boolean
    location?: boolean
    gender?: boolean
    source?: boolean
    status?: boolean
    notes?: boolean
    assignedTo?: boolean
    platform?: boolean
    campaignId?: boolean
    adGroupId?: boolean
    adId?: boolean
    formId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    college?: boolean
    qualification?: boolean
    dob?: boolean
    location?: boolean
    gender?: boolean
    source?: boolean
    status?: boolean
    notes?: boolean
    assignedTo?: boolean
    platform?: boolean
    campaignId?: boolean
    adGroupId?: boolean
    adId?: boolean
    formId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "college" | "qualification" | "dob" | "location" | "gender" | "source" | "status" | "notes" | "assignedTo" | "platform" | "campaignId" | "adGroupId" | "adId" | "formId" | "createdAt" | "updatedAt", ExtArgs["result"]["lead"]>
  export type LeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | Lead$tasksArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LeadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lead"
    objects: {
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string | null
      phone: string | null
      college: string | null
      qualification: string | null
      dob: Date | null
      location: string | null
      gender: string | null
      source: string
      status: $Enums.LeadStatus
      notes: string | null
      assignedTo: string | null
      platform: string | null
      campaignId: string | null
      adGroupId: string | null
      adId: string | null
      formId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lead"]>
    composites: {}
  }

  type LeadGetPayload<S extends boolean | null | undefined | LeadDefaultArgs> = $Result.GetResult<Prisma.$LeadPayload, S>

  type LeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadCountAggregateInputType | true
    }

  export interface LeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lead'], meta: { name: 'Lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {LeadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadFindUniqueArgs>(args: SelectSubset<T, LeadFindUniqueArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadFindFirstArgs>(args?: SelectSubset<T, LeadFindFirstArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadFindManyArgs>(args?: SelectSubset<T, LeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lead.
     * @param {LeadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
     */
    create<T extends LeadCreateArgs>(args: SelectSubset<T, LeadCreateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leads.
     * @param {LeadCreateManyArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadCreateManyArgs>(args?: SelectSubset<T, LeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leads and returns the data saved in the database.
     * @param {LeadCreateManyAndReturnArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lead.
     * @param {LeadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
     */
    delete<T extends LeadDeleteArgs>(args: SelectSubset<T, LeadDeleteArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lead.
     * @param {LeadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadUpdateArgs>(args: SelectSubset<T, LeadUpdateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leads.
     * @param {LeadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadDeleteManyArgs>(args?: SelectSubset<T, LeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadUpdateManyArgs>(args: SelectSubset<T, LeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads and returns the data updated in the database.
     * @param {LeadUpdateManyAndReturnArgs} args - Arguments to update many Leads.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lead.
     * @param {LeadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
     */
    upsert<T extends LeadUpsertArgs>(args: SelectSubset<T, LeadUpsertArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends LeadCountArgs>(
      args?: Subset<T, LeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadGroupByArgs['orderBy'] }
        : { orderBy?: LeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lead model
   */
  readonly fields: LeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tasks<T extends Lead$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Lead$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lead model
   */
  interface LeadFieldRefs {
    readonly id: FieldRef<"Lead", 'String'>
    readonly name: FieldRef<"Lead", 'String'>
    readonly email: FieldRef<"Lead", 'String'>
    readonly phone: FieldRef<"Lead", 'String'>
    readonly college: FieldRef<"Lead", 'String'>
    readonly qualification: FieldRef<"Lead", 'String'>
    readonly dob: FieldRef<"Lead", 'DateTime'>
    readonly location: FieldRef<"Lead", 'String'>
    readonly gender: FieldRef<"Lead", 'String'>
    readonly source: FieldRef<"Lead", 'String'>
    readonly status: FieldRef<"Lead", 'LeadStatus'>
    readonly notes: FieldRef<"Lead", 'String'>
    readonly assignedTo: FieldRef<"Lead", 'String'>
    readonly platform: FieldRef<"Lead", 'String'>
    readonly campaignId: FieldRef<"Lead", 'String'>
    readonly adGroupId: FieldRef<"Lead", 'String'>
    readonly adId: FieldRef<"Lead", 'String'>
    readonly formId: FieldRef<"Lead", 'String'>
    readonly createdAt: FieldRef<"Lead", 'DateTime'>
    readonly updatedAt: FieldRef<"Lead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lead findUnique
   */
  export type LeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findUniqueOrThrow
   */
  export type LeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findFirst
   */
  export type LeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findFirstOrThrow
   */
  export type LeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findMany
   */
  export type LeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Leads to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead create
   */
  export type LeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to create a Lead.
     */
    data: XOR<LeadCreateInput, LeadUncheckedCreateInput>
  }

  /**
   * Lead createMany
   */
  export type LeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lead createManyAndReturn
   */
  export type LeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lead update
   */
  export type LeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to update a Lead.
     */
    data: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
    /**
     * Choose, which Lead to update.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead updateMany
   */
  export type LeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to update.
     */
    limit?: number
  }

  /**
   * Lead updateManyAndReturn
   */
  export type LeadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to update.
     */
    limit?: number
  }

  /**
   * Lead upsert
   */
  export type LeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The filter to search for the Lead to update in case it exists.
     */
    where: LeadWhereUniqueInput
    /**
     * In case the Lead found by the `where` argument doesn't exist, create a new Lead with this data.
     */
    create: XOR<LeadCreateInput, LeadUncheckedCreateInput>
    /**
     * In case the Lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
  }

  /**
   * Lead delete
   */
  export type LeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter which Lead to delete.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead deleteMany
   */
  export type LeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leads to delete
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to delete.
     */
    limit?: number
  }

  /**
   * Lead.tasks
   */
  export type Lead$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Lead without action
   */
  export type LeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
  }


  /**
   * Model MarketingIntegration
   */

  export type AggregateMarketingIntegration = {
    _count: MarketingIntegrationCountAggregateOutputType | null
    _min: MarketingIntegrationMinAggregateOutputType | null
    _max: MarketingIntegrationMaxAggregateOutputType | null
  }

  export type MarketingIntegrationMinAggregateOutputType = {
    id: string | null
    platform: string | null
    name: string | null
    accessToken: string | null
    refreshToken: string | null
    accountId: string | null
    pageId: string | null
    isActive: boolean | null
    webhookSecret: string | null
    lastSyncAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketingIntegrationMaxAggregateOutputType = {
    id: string | null
    platform: string | null
    name: string | null
    accessToken: string | null
    refreshToken: string | null
    accountId: string | null
    pageId: string | null
    isActive: boolean | null
    webhookSecret: string | null
    lastSyncAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketingIntegrationCountAggregateOutputType = {
    id: number
    platform: number
    name: number
    accessToken: number
    refreshToken: number
    accountId: number
    pageId: number
    isActive: number
    webhookSecret: number
    lastSyncAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MarketingIntegrationMinAggregateInputType = {
    id?: true
    platform?: true
    name?: true
    accessToken?: true
    refreshToken?: true
    accountId?: true
    pageId?: true
    isActive?: true
    webhookSecret?: true
    lastSyncAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketingIntegrationMaxAggregateInputType = {
    id?: true
    platform?: true
    name?: true
    accessToken?: true
    refreshToken?: true
    accountId?: true
    pageId?: true
    isActive?: true
    webhookSecret?: true
    lastSyncAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketingIntegrationCountAggregateInputType = {
    id?: true
    platform?: true
    name?: true
    accessToken?: true
    refreshToken?: true
    accountId?: true
    pageId?: true
    isActive?: true
    webhookSecret?: true
    lastSyncAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MarketingIntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingIntegration to aggregate.
     */
    where?: MarketingIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingIntegrations to fetch.
     */
    orderBy?: MarketingIntegrationOrderByWithRelationInput | MarketingIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketingIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketingIntegrations
    **/
    _count?: true | MarketingIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketingIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketingIntegrationMaxAggregateInputType
  }

  export type GetMarketingIntegrationAggregateType<T extends MarketingIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketingIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketingIntegration[P]>
      : GetScalarType<T[P], AggregateMarketingIntegration[P]>
  }




  export type MarketingIntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketingIntegrationWhereInput
    orderBy?: MarketingIntegrationOrderByWithAggregationInput | MarketingIntegrationOrderByWithAggregationInput[]
    by: MarketingIntegrationScalarFieldEnum[] | MarketingIntegrationScalarFieldEnum
    having?: MarketingIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketingIntegrationCountAggregateInputType | true
    _min?: MarketingIntegrationMinAggregateInputType
    _max?: MarketingIntegrationMaxAggregateInputType
  }

  export type MarketingIntegrationGroupByOutputType = {
    id: string
    platform: string
    name: string
    accessToken: string | null
    refreshToken: string | null
    accountId: string | null
    pageId: string | null
    isActive: boolean
    webhookSecret: string | null
    lastSyncAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MarketingIntegrationCountAggregateOutputType | null
    _min: MarketingIntegrationMinAggregateOutputType | null
    _max: MarketingIntegrationMaxAggregateOutputType | null
  }

  type GetMarketingIntegrationGroupByPayload<T extends MarketingIntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketingIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketingIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketingIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], MarketingIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type MarketingIntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    name?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accountId?: boolean
    pageId?: boolean
    isActive?: boolean
    webhookSecret?: boolean
    lastSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marketingIntegration"]>

  export type MarketingIntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    name?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accountId?: boolean
    pageId?: boolean
    isActive?: boolean
    webhookSecret?: boolean
    lastSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marketingIntegration"]>

  export type MarketingIntegrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    name?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accountId?: boolean
    pageId?: boolean
    isActive?: boolean
    webhookSecret?: boolean
    lastSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marketingIntegration"]>

  export type MarketingIntegrationSelectScalar = {
    id?: boolean
    platform?: boolean
    name?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accountId?: boolean
    pageId?: boolean
    isActive?: boolean
    webhookSecret?: boolean
    lastSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MarketingIntegrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "platform" | "name" | "accessToken" | "refreshToken" | "accountId" | "pageId" | "isActive" | "webhookSecret" | "lastSyncAt" | "createdAt" | "updatedAt", ExtArgs["result"]["marketingIntegration"]>

  export type $MarketingIntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketingIntegration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      platform: string
      name: string
      accessToken: string | null
      refreshToken: string | null
      accountId: string | null
      pageId: string | null
      isActive: boolean
      webhookSecret: string | null
      lastSyncAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["marketingIntegration"]>
    composites: {}
  }

  type MarketingIntegrationGetPayload<S extends boolean | null | undefined | MarketingIntegrationDefaultArgs> = $Result.GetResult<Prisma.$MarketingIntegrationPayload, S>

  type MarketingIntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketingIntegrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketingIntegrationCountAggregateInputType | true
    }

  export interface MarketingIntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketingIntegration'], meta: { name: 'MarketingIntegration' } }
    /**
     * Find zero or one MarketingIntegration that matches the filter.
     * @param {MarketingIntegrationFindUniqueArgs} args - Arguments to find a MarketingIntegration
     * @example
     * // Get one MarketingIntegration
     * const marketingIntegration = await prisma.marketingIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketingIntegrationFindUniqueArgs>(args: SelectSubset<T, MarketingIntegrationFindUniqueArgs<ExtArgs>>): Prisma__MarketingIntegrationClient<$Result.GetResult<Prisma.$MarketingIntegrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketingIntegration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketingIntegrationFindUniqueOrThrowArgs} args - Arguments to find a MarketingIntegration
     * @example
     * // Get one MarketingIntegration
     * const marketingIntegration = await prisma.marketingIntegration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketingIntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketingIntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketingIntegrationClient<$Result.GetResult<Prisma.$MarketingIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketingIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingIntegrationFindFirstArgs} args - Arguments to find a MarketingIntegration
     * @example
     * // Get one MarketingIntegration
     * const marketingIntegration = await prisma.marketingIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketingIntegrationFindFirstArgs>(args?: SelectSubset<T, MarketingIntegrationFindFirstArgs<ExtArgs>>): Prisma__MarketingIntegrationClient<$Result.GetResult<Prisma.$MarketingIntegrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketingIntegration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingIntegrationFindFirstOrThrowArgs} args - Arguments to find a MarketingIntegration
     * @example
     * // Get one MarketingIntegration
     * const marketingIntegration = await prisma.marketingIntegration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketingIntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketingIntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketingIntegrationClient<$Result.GetResult<Prisma.$MarketingIntegrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketingIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingIntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketingIntegrations
     * const marketingIntegrations = await prisma.marketingIntegration.findMany()
     * 
     * // Get first 10 MarketingIntegrations
     * const marketingIntegrations = await prisma.marketingIntegration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketingIntegrationWithIdOnly = await prisma.marketingIntegration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketingIntegrationFindManyArgs>(args?: SelectSubset<T, MarketingIntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingIntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketingIntegration.
     * @param {MarketingIntegrationCreateArgs} args - Arguments to create a MarketingIntegration.
     * @example
     * // Create one MarketingIntegration
     * const MarketingIntegration = await prisma.marketingIntegration.create({
     *   data: {
     *     // ... data to create a MarketingIntegration
     *   }
     * })
     * 
     */
    create<T extends MarketingIntegrationCreateArgs>(args: SelectSubset<T, MarketingIntegrationCreateArgs<ExtArgs>>): Prisma__MarketingIntegrationClient<$Result.GetResult<Prisma.$MarketingIntegrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketingIntegrations.
     * @param {MarketingIntegrationCreateManyArgs} args - Arguments to create many MarketingIntegrations.
     * @example
     * // Create many MarketingIntegrations
     * const marketingIntegration = await prisma.marketingIntegration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketingIntegrationCreateManyArgs>(args?: SelectSubset<T, MarketingIntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketingIntegrations and returns the data saved in the database.
     * @param {MarketingIntegrationCreateManyAndReturnArgs} args - Arguments to create many MarketingIntegrations.
     * @example
     * // Create many MarketingIntegrations
     * const marketingIntegration = await prisma.marketingIntegration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketingIntegrations and only return the `id`
     * const marketingIntegrationWithIdOnly = await prisma.marketingIntegration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketingIntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketingIntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingIntegrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MarketingIntegration.
     * @param {MarketingIntegrationDeleteArgs} args - Arguments to delete one MarketingIntegration.
     * @example
     * // Delete one MarketingIntegration
     * const MarketingIntegration = await prisma.marketingIntegration.delete({
     *   where: {
     *     // ... filter to delete one MarketingIntegration
     *   }
     * })
     * 
     */
    delete<T extends MarketingIntegrationDeleteArgs>(args: SelectSubset<T, MarketingIntegrationDeleteArgs<ExtArgs>>): Prisma__MarketingIntegrationClient<$Result.GetResult<Prisma.$MarketingIntegrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketingIntegration.
     * @param {MarketingIntegrationUpdateArgs} args - Arguments to update one MarketingIntegration.
     * @example
     * // Update one MarketingIntegration
     * const marketingIntegration = await prisma.marketingIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketingIntegrationUpdateArgs>(args: SelectSubset<T, MarketingIntegrationUpdateArgs<ExtArgs>>): Prisma__MarketingIntegrationClient<$Result.GetResult<Prisma.$MarketingIntegrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketingIntegrations.
     * @param {MarketingIntegrationDeleteManyArgs} args - Arguments to filter MarketingIntegrations to delete.
     * @example
     * // Delete a few MarketingIntegrations
     * const { count } = await prisma.marketingIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketingIntegrationDeleteManyArgs>(args?: SelectSubset<T, MarketingIntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketingIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketingIntegrations
     * const marketingIntegration = await prisma.marketingIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketingIntegrationUpdateManyArgs>(args: SelectSubset<T, MarketingIntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketingIntegrations and returns the data updated in the database.
     * @param {MarketingIntegrationUpdateManyAndReturnArgs} args - Arguments to update many MarketingIntegrations.
     * @example
     * // Update many MarketingIntegrations
     * const marketingIntegration = await prisma.marketingIntegration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MarketingIntegrations and only return the `id`
     * const marketingIntegrationWithIdOnly = await prisma.marketingIntegration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MarketingIntegrationUpdateManyAndReturnArgs>(args: SelectSubset<T, MarketingIntegrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingIntegrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MarketingIntegration.
     * @param {MarketingIntegrationUpsertArgs} args - Arguments to update or create a MarketingIntegration.
     * @example
     * // Update or create a MarketingIntegration
     * const marketingIntegration = await prisma.marketingIntegration.upsert({
     *   create: {
     *     // ... data to create a MarketingIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketingIntegration we want to update
     *   }
     * })
     */
    upsert<T extends MarketingIntegrationUpsertArgs>(args: SelectSubset<T, MarketingIntegrationUpsertArgs<ExtArgs>>): Prisma__MarketingIntegrationClient<$Result.GetResult<Prisma.$MarketingIntegrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MarketingIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingIntegrationCountArgs} args - Arguments to filter MarketingIntegrations to count.
     * @example
     * // Count the number of MarketingIntegrations
     * const count = await prisma.marketingIntegration.count({
     *   where: {
     *     // ... the filter for the MarketingIntegrations we want to count
     *   }
     * })
    **/
    count<T extends MarketingIntegrationCountArgs>(
      args?: Subset<T, MarketingIntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketingIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketingIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketingIntegrationAggregateArgs>(args: Subset<T, MarketingIntegrationAggregateArgs>): Prisma.PrismaPromise<GetMarketingIntegrationAggregateType<T>>

    /**
     * Group by MarketingIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketingIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketingIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: MarketingIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketingIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketingIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketingIntegration model
   */
  readonly fields: MarketingIntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketingIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketingIntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketingIntegration model
   */
  interface MarketingIntegrationFieldRefs {
    readonly id: FieldRef<"MarketingIntegration", 'String'>
    readonly platform: FieldRef<"MarketingIntegration", 'String'>
    readonly name: FieldRef<"MarketingIntegration", 'String'>
    readonly accessToken: FieldRef<"MarketingIntegration", 'String'>
    readonly refreshToken: FieldRef<"MarketingIntegration", 'String'>
    readonly accountId: FieldRef<"MarketingIntegration", 'String'>
    readonly pageId: FieldRef<"MarketingIntegration", 'String'>
    readonly isActive: FieldRef<"MarketingIntegration", 'Boolean'>
    readonly webhookSecret: FieldRef<"MarketingIntegration", 'String'>
    readonly lastSyncAt: FieldRef<"MarketingIntegration", 'DateTime'>
    readonly createdAt: FieldRef<"MarketingIntegration", 'DateTime'>
    readonly updatedAt: FieldRef<"MarketingIntegration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketingIntegration findUnique
   */
  export type MarketingIntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingIntegration
     */
    select?: MarketingIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingIntegration
     */
    omit?: MarketingIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which MarketingIntegration to fetch.
     */
    where: MarketingIntegrationWhereUniqueInput
  }

  /**
   * MarketingIntegration findUniqueOrThrow
   */
  export type MarketingIntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingIntegration
     */
    select?: MarketingIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingIntegration
     */
    omit?: MarketingIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which MarketingIntegration to fetch.
     */
    where: MarketingIntegrationWhereUniqueInput
  }

  /**
   * MarketingIntegration findFirst
   */
  export type MarketingIntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingIntegration
     */
    select?: MarketingIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingIntegration
     */
    omit?: MarketingIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which MarketingIntegration to fetch.
     */
    where?: MarketingIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingIntegrations to fetch.
     */
    orderBy?: MarketingIntegrationOrderByWithRelationInput | MarketingIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingIntegrations.
     */
    cursor?: MarketingIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingIntegrations.
     */
    distinct?: MarketingIntegrationScalarFieldEnum | MarketingIntegrationScalarFieldEnum[]
  }

  /**
   * MarketingIntegration findFirstOrThrow
   */
  export type MarketingIntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingIntegration
     */
    select?: MarketingIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingIntegration
     */
    omit?: MarketingIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which MarketingIntegration to fetch.
     */
    where?: MarketingIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingIntegrations to fetch.
     */
    orderBy?: MarketingIntegrationOrderByWithRelationInput | MarketingIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingIntegrations.
     */
    cursor?: MarketingIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingIntegrations.
     */
    distinct?: MarketingIntegrationScalarFieldEnum | MarketingIntegrationScalarFieldEnum[]
  }

  /**
   * MarketingIntegration findMany
   */
  export type MarketingIntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingIntegration
     */
    select?: MarketingIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingIntegration
     */
    omit?: MarketingIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which MarketingIntegrations to fetch.
     */
    where?: MarketingIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingIntegrations to fetch.
     */
    orderBy?: MarketingIntegrationOrderByWithRelationInput | MarketingIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketingIntegrations.
     */
    cursor?: MarketingIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingIntegrations.
     */
    skip?: number
    distinct?: MarketingIntegrationScalarFieldEnum | MarketingIntegrationScalarFieldEnum[]
  }

  /**
   * MarketingIntegration create
   */
  export type MarketingIntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingIntegration
     */
    select?: MarketingIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingIntegration
     */
    omit?: MarketingIntegrationOmit<ExtArgs> | null
    /**
     * The data needed to create a MarketingIntegration.
     */
    data: XOR<MarketingIntegrationCreateInput, MarketingIntegrationUncheckedCreateInput>
  }

  /**
   * MarketingIntegration createMany
   */
  export type MarketingIntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketingIntegrations.
     */
    data: MarketingIntegrationCreateManyInput | MarketingIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketingIntegration createManyAndReturn
   */
  export type MarketingIntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingIntegration
     */
    select?: MarketingIntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingIntegration
     */
    omit?: MarketingIntegrationOmit<ExtArgs> | null
    /**
     * The data used to create many MarketingIntegrations.
     */
    data: MarketingIntegrationCreateManyInput | MarketingIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketingIntegration update
   */
  export type MarketingIntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingIntegration
     */
    select?: MarketingIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingIntegration
     */
    omit?: MarketingIntegrationOmit<ExtArgs> | null
    /**
     * The data needed to update a MarketingIntegration.
     */
    data: XOR<MarketingIntegrationUpdateInput, MarketingIntegrationUncheckedUpdateInput>
    /**
     * Choose, which MarketingIntegration to update.
     */
    where: MarketingIntegrationWhereUniqueInput
  }

  /**
   * MarketingIntegration updateMany
   */
  export type MarketingIntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketingIntegrations.
     */
    data: XOR<MarketingIntegrationUpdateManyMutationInput, MarketingIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which MarketingIntegrations to update
     */
    where?: MarketingIntegrationWhereInput
    /**
     * Limit how many MarketingIntegrations to update.
     */
    limit?: number
  }

  /**
   * MarketingIntegration updateManyAndReturn
   */
  export type MarketingIntegrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingIntegration
     */
    select?: MarketingIntegrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingIntegration
     */
    omit?: MarketingIntegrationOmit<ExtArgs> | null
    /**
     * The data used to update MarketingIntegrations.
     */
    data: XOR<MarketingIntegrationUpdateManyMutationInput, MarketingIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which MarketingIntegrations to update
     */
    where?: MarketingIntegrationWhereInput
    /**
     * Limit how many MarketingIntegrations to update.
     */
    limit?: number
  }

  /**
   * MarketingIntegration upsert
   */
  export type MarketingIntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingIntegration
     */
    select?: MarketingIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingIntegration
     */
    omit?: MarketingIntegrationOmit<ExtArgs> | null
    /**
     * The filter to search for the MarketingIntegration to update in case it exists.
     */
    where: MarketingIntegrationWhereUniqueInput
    /**
     * In case the MarketingIntegration found by the `where` argument doesn't exist, create a new MarketingIntegration with this data.
     */
    create: XOR<MarketingIntegrationCreateInput, MarketingIntegrationUncheckedCreateInput>
    /**
     * In case the MarketingIntegration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketingIntegrationUpdateInput, MarketingIntegrationUncheckedUpdateInput>
  }

  /**
   * MarketingIntegration delete
   */
  export type MarketingIntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingIntegration
     */
    select?: MarketingIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingIntegration
     */
    omit?: MarketingIntegrationOmit<ExtArgs> | null
    /**
     * Filter which MarketingIntegration to delete.
     */
    where: MarketingIntegrationWhereUniqueInput
  }

  /**
   * MarketingIntegration deleteMany
   */
  export type MarketingIntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingIntegrations to delete
     */
    where?: MarketingIntegrationWhereInput
    /**
     * Limit how many MarketingIntegrations to delete.
     */
    limit?: number
  }

  /**
   * MarketingIntegration without action
   */
  export type MarketingIntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingIntegration
     */
    select?: MarketingIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingIntegration
     */
    omit?: MarketingIntegrationOmit<ExtArgs> | null
  }


  /**
   * Model EmailIntegration
   */

  export type AggregateEmailIntegration = {
    _count: EmailIntegrationCountAggregateOutputType | null
    _avg: EmailIntegrationAvgAggregateOutputType | null
    _sum: EmailIntegrationSumAggregateOutputType | null
    _min: EmailIntegrationMinAggregateOutputType | null
    _max: EmailIntegrationMaxAggregateOutputType | null
  }

  export type EmailIntegrationAvgAggregateOutputType = {
    port: number | null
  }

  export type EmailIntegrationSumAggregateOutputType = {
    port: number | null
  }

  export type EmailIntegrationMinAggregateOutputType = {
    id: string | null
    provider: string | null
    name: string | null
    host: string | null
    port: number | null
    user: string | null
    pass: string | null
    secure: boolean | null
    fromEmail: string | null
    serviceId: string | null
    templateId: string | null
    publicKey: string | null
    privateKey: string | null
    apiKey: string | null
    isActive: boolean | null
    updatedAt: Date | null
  }

  export type EmailIntegrationMaxAggregateOutputType = {
    id: string | null
    provider: string | null
    name: string | null
    host: string | null
    port: number | null
    user: string | null
    pass: string | null
    secure: boolean | null
    fromEmail: string | null
    serviceId: string | null
    templateId: string | null
    publicKey: string | null
    privateKey: string | null
    apiKey: string | null
    isActive: boolean | null
    updatedAt: Date | null
  }

  export type EmailIntegrationCountAggregateOutputType = {
    id: number
    provider: number
    name: number
    host: number
    port: number
    user: number
    pass: number
    secure: number
    fromEmail: number
    serviceId: number
    templateId: number
    publicKey: number
    privateKey: number
    apiKey: number
    isActive: number
    updatedAt: number
    _all: number
  }


  export type EmailIntegrationAvgAggregateInputType = {
    port?: true
  }

  export type EmailIntegrationSumAggregateInputType = {
    port?: true
  }

  export type EmailIntegrationMinAggregateInputType = {
    id?: true
    provider?: true
    name?: true
    host?: true
    port?: true
    user?: true
    pass?: true
    secure?: true
    fromEmail?: true
    serviceId?: true
    templateId?: true
    publicKey?: true
    privateKey?: true
    apiKey?: true
    isActive?: true
    updatedAt?: true
  }

  export type EmailIntegrationMaxAggregateInputType = {
    id?: true
    provider?: true
    name?: true
    host?: true
    port?: true
    user?: true
    pass?: true
    secure?: true
    fromEmail?: true
    serviceId?: true
    templateId?: true
    publicKey?: true
    privateKey?: true
    apiKey?: true
    isActive?: true
    updatedAt?: true
  }

  export type EmailIntegrationCountAggregateInputType = {
    id?: true
    provider?: true
    name?: true
    host?: true
    port?: true
    user?: true
    pass?: true
    secure?: true
    fromEmail?: true
    serviceId?: true
    templateId?: true
    publicKey?: true
    privateKey?: true
    apiKey?: true
    isActive?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailIntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailIntegration to aggregate.
     */
    where?: EmailIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailIntegrations to fetch.
     */
    orderBy?: EmailIntegrationOrderByWithRelationInput | EmailIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailIntegrations
    **/
    _count?: true | EmailIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailIntegrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailIntegrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailIntegrationMaxAggregateInputType
  }

  export type GetEmailIntegrationAggregateType<T extends EmailIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailIntegration[P]>
      : GetScalarType<T[P], AggregateEmailIntegration[P]>
  }




  export type EmailIntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailIntegrationWhereInput
    orderBy?: EmailIntegrationOrderByWithAggregationInput | EmailIntegrationOrderByWithAggregationInput[]
    by: EmailIntegrationScalarFieldEnum[] | EmailIntegrationScalarFieldEnum
    having?: EmailIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailIntegrationCountAggregateInputType | true
    _avg?: EmailIntegrationAvgAggregateInputType
    _sum?: EmailIntegrationSumAggregateInputType
    _min?: EmailIntegrationMinAggregateInputType
    _max?: EmailIntegrationMaxAggregateInputType
  }

  export type EmailIntegrationGroupByOutputType = {
    id: string
    provider: string
    name: string | null
    host: string | null
    port: number | null
    user: string | null
    pass: string | null
    secure: boolean
    fromEmail: string | null
    serviceId: string | null
    templateId: string | null
    publicKey: string | null
    privateKey: string | null
    apiKey: string | null
    isActive: boolean
    updatedAt: Date
    _count: EmailIntegrationCountAggregateOutputType | null
    _avg: EmailIntegrationAvgAggregateOutputType | null
    _sum: EmailIntegrationSumAggregateOutputType | null
    _min: EmailIntegrationMinAggregateOutputType | null
    _max: EmailIntegrationMaxAggregateOutputType | null
  }

  type GetEmailIntegrationGroupByPayload<T extends EmailIntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], EmailIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type EmailIntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    name?: boolean
    host?: boolean
    port?: boolean
    user?: boolean
    pass?: boolean
    secure?: boolean
    fromEmail?: boolean
    serviceId?: boolean
    templateId?: boolean
    publicKey?: boolean
    privateKey?: boolean
    apiKey?: boolean
    isActive?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailIntegration"]>

  export type EmailIntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    name?: boolean
    host?: boolean
    port?: boolean
    user?: boolean
    pass?: boolean
    secure?: boolean
    fromEmail?: boolean
    serviceId?: boolean
    templateId?: boolean
    publicKey?: boolean
    privateKey?: boolean
    apiKey?: boolean
    isActive?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailIntegration"]>

  export type EmailIntegrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    name?: boolean
    host?: boolean
    port?: boolean
    user?: boolean
    pass?: boolean
    secure?: boolean
    fromEmail?: boolean
    serviceId?: boolean
    templateId?: boolean
    publicKey?: boolean
    privateKey?: boolean
    apiKey?: boolean
    isActive?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailIntegration"]>

  export type EmailIntegrationSelectScalar = {
    id?: boolean
    provider?: boolean
    name?: boolean
    host?: boolean
    port?: boolean
    user?: boolean
    pass?: boolean
    secure?: boolean
    fromEmail?: boolean
    serviceId?: boolean
    templateId?: boolean
    publicKey?: boolean
    privateKey?: boolean
    apiKey?: boolean
    isActive?: boolean
    updatedAt?: boolean
  }

  export type EmailIntegrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider" | "name" | "host" | "port" | "user" | "pass" | "secure" | "fromEmail" | "serviceId" | "templateId" | "publicKey" | "privateKey" | "apiKey" | "isActive" | "updatedAt", ExtArgs["result"]["emailIntegration"]>

  export type $EmailIntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailIntegration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: string
      name: string | null
      host: string | null
      port: number | null
      user: string | null
      pass: string | null
      secure: boolean
      fromEmail: string | null
      serviceId: string | null
      templateId: string | null
      publicKey: string | null
      privateKey: string | null
      apiKey: string | null
      isActive: boolean
      updatedAt: Date
    }, ExtArgs["result"]["emailIntegration"]>
    composites: {}
  }

  type EmailIntegrationGetPayload<S extends boolean | null | undefined | EmailIntegrationDefaultArgs> = $Result.GetResult<Prisma.$EmailIntegrationPayload, S>

  type EmailIntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailIntegrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailIntegrationCountAggregateInputType | true
    }

  export interface EmailIntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailIntegration'], meta: { name: 'EmailIntegration' } }
    /**
     * Find zero or one EmailIntegration that matches the filter.
     * @param {EmailIntegrationFindUniqueArgs} args - Arguments to find a EmailIntegration
     * @example
     * // Get one EmailIntegration
     * const emailIntegration = await prisma.emailIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailIntegrationFindUniqueArgs>(args: SelectSubset<T, EmailIntegrationFindUniqueArgs<ExtArgs>>): Prisma__EmailIntegrationClient<$Result.GetResult<Prisma.$EmailIntegrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailIntegration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailIntegrationFindUniqueOrThrowArgs} args - Arguments to find a EmailIntegration
     * @example
     * // Get one EmailIntegration
     * const emailIntegration = await prisma.emailIntegration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailIntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailIntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailIntegrationClient<$Result.GetResult<Prisma.$EmailIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailIntegrationFindFirstArgs} args - Arguments to find a EmailIntegration
     * @example
     * // Get one EmailIntegration
     * const emailIntegration = await prisma.emailIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailIntegrationFindFirstArgs>(args?: SelectSubset<T, EmailIntegrationFindFirstArgs<ExtArgs>>): Prisma__EmailIntegrationClient<$Result.GetResult<Prisma.$EmailIntegrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailIntegration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailIntegrationFindFirstOrThrowArgs} args - Arguments to find a EmailIntegration
     * @example
     * // Get one EmailIntegration
     * const emailIntegration = await prisma.emailIntegration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailIntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailIntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailIntegrationClient<$Result.GetResult<Prisma.$EmailIntegrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailIntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailIntegrations
     * const emailIntegrations = await prisma.emailIntegration.findMany()
     * 
     * // Get first 10 EmailIntegrations
     * const emailIntegrations = await prisma.emailIntegration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailIntegrationWithIdOnly = await prisma.emailIntegration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailIntegrationFindManyArgs>(args?: SelectSubset<T, EmailIntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailIntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailIntegration.
     * @param {EmailIntegrationCreateArgs} args - Arguments to create a EmailIntegration.
     * @example
     * // Create one EmailIntegration
     * const EmailIntegration = await prisma.emailIntegration.create({
     *   data: {
     *     // ... data to create a EmailIntegration
     *   }
     * })
     * 
     */
    create<T extends EmailIntegrationCreateArgs>(args: SelectSubset<T, EmailIntegrationCreateArgs<ExtArgs>>): Prisma__EmailIntegrationClient<$Result.GetResult<Prisma.$EmailIntegrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailIntegrations.
     * @param {EmailIntegrationCreateManyArgs} args - Arguments to create many EmailIntegrations.
     * @example
     * // Create many EmailIntegrations
     * const emailIntegration = await prisma.emailIntegration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailIntegrationCreateManyArgs>(args?: SelectSubset<T, EmailIntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailIntegrations and returns the data saved in the database.
     * @param {EmailIntegrationCreateManyAndReturnArgs} args - Arguments to create many EmailIntegrations.
     * @example
     * // Create many EmailIntegrations
     * const emailIntegration = await prisma.emailIntegration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailIntegrations and only return the `id`
     * const emailIntegrationWithIdOnly = await prisma.emailIntegration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailIntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailIntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailIntegrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailIntegration.
     * @param {EmailIntegrationDeleteArgs} args - Arguments to delete one EmailIntegration.
     * @example
     * // Delete one EmailIntegration
     * const EmailIntegration = await prisma.emailIntegration.delete({
     *   where: {
     *     // ... filter to delete one EmailIntegration
     *   }
     * })
     * 
     */
    delete<T extends EmailIntegrationDeleteArgs>(args: SelectSubset<T, EmailIntegrationDeleteArgs<ExtArgs>>): Prisma__EmailIntegrationClient<$Result.GetResult<Prisma.$EmailIntegrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailIntegration.
     * @param {EmailIntegrationUpdateArgs} args - Arguments to update one EmailIntegration.
     * @example
     * // Update one EmailIntegration
     * const emailIntegration = await prisma.emailIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailIntegrationUpdateArgs>(args: SelectSubset<T, EmailIntegrationUpdateArgs<ExtArgs>>): Prisma__EmailIntegrationClient<$Result.GetResult<Prisma.$EmailIntegrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailIntegrations.
     * @param {EmailIntegrationDeleteManyArgs} args - Arguments to filter EmailIntegrations to delete.
     * @example
     * // Delete a few EmailIntegrations
     * const { count } = await prisma.emailIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailIntegrationDeleteManyArgs>(args?: SelectSubset<T, EmailIntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailIntegrations
     * const emailIntegration = await prisma.emailIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailIntegrationUpdateManyArgs>(args: SelectSubset<T, EmailIntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailIntegrations and returns the data updated in the database.
     * @param {EmailIntegrationUpdateManyAndReturnArgs} args - Arguments to update many EmailIntegrations.
     * @example
     * // Update many EmailIntegrations
     * const emailIntegration = await prisma.emailIntegration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailIntegrations and only return the `id`
     * const emailIntegrationWithIdOnly = await prisma.emailIntegration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailIntegrationUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailIntegrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailIntegrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailIntegration.
     * @param {EmailIntegrationUpsertArgs} args - Arguments to update or create a EmailIntegration.
     * @example
     * // Update or create a EmailIntegration
     * const emailIntegration = await prisma.emailIntegration.upsert({
     *   create: {
     *     // ... data to create a EmailIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailIntegration we want to update
     *   }
     * })
     */
    upsert<T extends EmailIntegrationUpsertArgs>(args: SelectSubset<T, EmailIntegrationUpsertArgs<ExtArgs>>): Prisma__EmailIntegrationClient<$Result.GetResult<Prisma.$EmailIntegrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailIntegrationCountArgs} args - Arguments to filter EmailIntegrations to count.
     * @example
     * // Count the number of EmailIntegrations
     * const count = await prisma.emailIntegration.count({
     *   where: {
     *     // ... the filter for the EmailIntegrations we want to count
     *   }
     * })
    **/
    count<T extends EmailIntegrationCountArgs>(
      args?: Subset<T, EmailIntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailIntegrationAggregateArgs>(args: Subset<T, EmailIntegrationAggregateArgs>): Prisma.PrismaPromise<GetEmailIntegrationAggregateType<T>>

    /**
     * Group by EmailIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: EmailIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailIntegration model
   */
  readonly fields: EmailIntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailIntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailIntegration model
   */
  interface EmailIntegrationFieldRefs {
    readonly id: FieldRef<"EmailIntegration", 'String'>
    readonly provider: FieldRef<"EmailIntegration", 'String'>
    readonly name: FieldRef<"EmailIntegration", 'String'>
    readonly host: FieldRef<"EmailIntegration", 'String'>
    readonly port: FieldRef<"EmailIntegration", 'Int'>
    readonly user: FieldRef<"EmailIntegration", 'String'>
    readonly pass: FieldRef<"EmailIntegration", 'String'>
    readonly secure: FieldRef<"EmailIntegration", 'Boolean'>
    readonly fromEmail: FieldRef<"EmailIntegration", 'String'>
    readonly serviceId: FieldRef<"EmailIntegration", 'String'>
    readonly templateId: FieldRef<"EmailIntegration", 'String'>
    readonly publicKey: FieldRef<"EmailIntegration", 'String'>
    readonly privateKey: FieldRef<"EmailIntegration", 'String'>
    readonly apiKey: FieldRef<"EmailIntegration", 'String'>
    readonly isActive: FieldRef<"EmailIntegration", 'Boolean'>
    readonly updatedAt: FieldRef<"EmailIntegration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailIntegration findUnique
   */
  export type EmailIntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIntegration
     */
    select?: EmailIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIntegration
     */
    omit?: EmailIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which EmailIntegration to fetch.
     */
    where: EmailIntegrationWhereUniqueInput
  }

  /**
   * EmailIntegration findUniqueOrThrow
   */
  export type EmailIntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIntegration
     */
    select?: EmailIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIntegration
     */
    omit?: EmailIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which EmailIntegration to fetch.
     */
    where: EmailIntegrationWhereUniqueInput
  }

  /**
   * EmailIntegration findFirst
   */
  export type EmailIntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIntegration
     */
    select?: EmailIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIntegration
     */
    omit?: EmailIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which EmailIntegration to fetch.
     */
    where?: EmailIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailIntegrations to fetch.
     */
    orderBy?: EmailIntegrationOrderByWithRelationInput | EmailIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailIntegrations.
     */
    cursor?: EmailIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailIntegrations.
     */
    distinct?: EmailIntegrationScalarFieldEnum | EmailIntegrationScalarFieldEnum[]
  }

  /**
   * EmailIntegration findFirstOrThrow
   */
  export type EmailIntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIntegration
     */
    select?: EmailIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIntegration
     */
    omit?: EmailIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which EmailIntegration to fetch.
     */
    where?: EmailIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailIntegrations to fetch.
     */
    orderBy?: EmailIntegrationOrderByWithRelationInput | EmailIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailIntegrations.
     */
    cursor?: EmailIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailIntegrations.
     */
    distinct?: EmailIntegrationScalarFieldEnum | EmailIntegrationScalarFieldEnum[]
  }

  /**
   * EmailIntegration findMany
   */
  export type EmailIntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIntegration
     */
    select?: EmailIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIntegration
     */
    omit?: EmailIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which EmailIntegrations to fetch.
     */
    where?: EmailIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailIntegrations to fetch.
     */
    orderBy?: EmailIntegrationOrderByWithRelationInput | EmailIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailIntegrations.
     */
    cursor?: EmailIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailIntegrations.
     */
    skip?: number
    distinct?: EmailIntegrationScalarFieldEnum | EmailIntegrationScalarFieldEnum[]
  }

  /**
   * EmailIntegration create
   */
  export type EmailIntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIntegration
     */
    select?: EmailIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIntegration
     */
    omit?: EmailIntegrationOmit<ExtArgs> | null
    /**
     * The data needed to create a EmailIntegration.
     */
    data: XOR<EmailIntegrationCreateInput, EmailIntegrationUncheckedCreateInput>
  }

  /**
   * EmailIntegration createMany
   */
  export type EmailIntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailIntegrations.
     */
    data: EmailIntegrationCreateManyInput | EmailIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailIntegration createManyAndReturn
   */
  export type EmailIntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIntegration
     */
    select?: EmailIntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIntegration
     */
    omit?: EmailIntegrationOmit<ExtArgs> | null
    /**
     * The data used to create many EmailIntegrations.
     */
    data: EmailIntegrationCreateManyInput | EmailIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailIntegration update
   */
  export type EmailIntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIntegration
     */
    select?: EmailIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIntegration
     */
    omit?: EmailIntegrationOmit<ExtArgs> | null
    /**
     * The data needed to update a EmailIntegration.
     */
    data: XOR<EmailIntegrationUpdateInput, EmailIntegrationUncheckedUpdateInput>
    /**
     * Choose, which EmailIntegration to update.
     */
    where: EmailIntegrationWhereUniqueInput
  }

  /**
   * EmailIntegration updateMany
   */
  export type EmailIntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailIntegrations.
     */
    data: XOR<EmailIntegrationUpdateManyMutationInput, EmailIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which EmailIntegrations to update
     */
    where?: EmailIntegrationWhereInput
    /**
     * Limit how many EmailIntegrations to update.
     */
    limit?: number
  }

  /**
   * EmailIntegration updateManyAndReturn
   */
  export type EmailIntegrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIntegration
     */
    select?: EmailIntegrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIntegration
     */
    omit?: EmailIntegrationOmit<ExtArgs> | null
    /**
     * The data used to update EmailIntegrations.
     */
    data: XOR<EmailIntegrationUpdateManyMutationInput, EmailIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which EmailIntegrations to update
     */
    where?: EmailIntegrationWhereInput
    /**
     * Limit how many EmailIntegrations to update.
     */
    limit?: number
  }

  /**
   * EmailIntegration upsert
   */
  export type EmailIntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIntegration
     */
    select?: EmailIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIntegration
     */
    omit?: EmailIntegrationOmit<ExtArgs> | null
    /**
     * The filter to search for the EmailIntegration to update in case it exists.
     */
    where: EmailIntegrationWhereUniqueInput
    /**
     * In case the EmailIntegration found by the `where` argument doesn't exist, create a new EmailIntegration with this data.
     */
    create: XOR<EmailIntegrationCreateInput, EmailIntegrationUncheckedCreateInput>
    /**
     * In case the EmailIntegration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailIntegrationUpdateInput, EmailIntegrationUncheckedUpdateInput>
  }

  /**
   * EmailIntegration delete
   */
  export type EmailIntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIntegration
     */
    select?: EmailIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIntegration
     */
    omit?: EmailIntegrationOmit<ExtArgs> | null
    /**
     * Filter which EmailIntegration to delete.
     */
    where: EmailIntegrationWhereUniqueInput
  }

  /**
   * EmailIntegration deleteMany
   */
  export type EmailIntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailIntegrations to delete
     */
    where?: EmailIntegrationWhereInput
    /**
     * Limit how many EmailIntegrations to delete.
     */
    limit?: number
  }

  /**
   * EmailIntegration without action
   */
  export type EmailIntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailIntegration
     */
    select?: EmailIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailIntegration
     */
    omit?: EmailIntegrationOmit<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    priority: $Enums.Priority | null
    dueDate: Date | null
    assignedTo: string | null
    createdBy: string | null
    leadId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    priority: $Enums.Priority | null
    dueDate: Date | null
    assignedTo: string | null
    createdBy: string | null
    leadId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    priority: number
    dueDate: number
    assignedTo: number
    createdBy: number
    leadId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    assignedTo?: true
    createdBy?: true
    leadId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    assignedTo?: true
    createdBy?: true
    leadId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    dueDate?: true
    assignedTo?: true
    createdBy?: true
    leadId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    title: string
    description: string | null
    status: $Enums.TaskStatus
    priority: $Enums.Priority
    dueDate: Date | null
    assignedTo: string | null
    createdBy: string | null
    leadId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    assignedTo?: boolean
    createdBy?: boolean
    leadId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignee?: boolean | Task$assigneeArgs<ExtArgs>
    creator?: boolean | Task$creatorArgs<ExtArgs>
    lead?: boolean | Task$leadArgs<ExtArgs>
    comments?: boolean | Task$commentsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    assignedTo?: boolean
    createdBy?: boolean
    leadId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignee?: boolean | Task$assigneeArgs<ExtArgs>
    creator?: boolean | Task$creatorArgs<ExtArgs>
    lead?: boolean | Task$leadArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    assignedTo?: boolean
    createdBy?: boolean
    leadId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignee?: boolean | Task$assigneeArgs<ExtArgs>
    creator?: boolean | Task$creatorArgs<ExtArgs>
    lead?: boolean | Task$leadArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    dueDate?: boolean
    assignedTo?: boolean
    createdBy?: boolean
    leadId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "status" | "priority" | "dueDate" | "assignedTo" | "createdBy" | "leadId" | "createdAt" | "updatedAt", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignee?: boolean | Task$assigneeArgs<ExtArgs>
    creator?: boolean | Task$creatorArgs<ExtArgs>
    lead?: boolean | Task$leadArgs<ExtArgs>
    comments?: boolean | Task$commentsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignee?: boolean | Task$assigneeArgs<ExtArgs>
    creator?: boolean | Task$creatorArgs<ExtArgs>
    lead?: boolean | Task$leadArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignee?: boolean | Task$assigneeArgs<ExtArgs>
    creator?: boolean | Task$creatorArgs<ExtArgs>
    lead?: boolean | Task$leadArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      assignee: Prisma.$UserPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs> | null
      lead: Prisma.$LeadPayload<ExtArgs> | null
      comments: Prisma.$TaskCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      status: $Enums.TaskStatus
      priority: $Enums.Priority
      dueDate: Date | null
      assignedTo: string | null
      createdBy: string | null
      leadId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignee<T extends Task$assigneeArgs<ExtArgs> = {}>(args?: Subset<T, Task$assigneeArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creator<T extends Task$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Task$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lead<T extends Task$leadArgs<ExtArgs> = {}>(args?: Subset<T, Task$leadArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comments<T extends Task$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Task$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'TaskStatus'>
    readonly priority: FieldRef<"Task", 'Priority'>
    readonly dueDate: FieldRef<"Task", 'DateTime'>
    readonly assignedTo: FieldRef<"Task", 'String'>
    readonly createdBy: FieldRef<"Task", 'String'>
    readonly leadId: FieldRef<"Task", 'String'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.assignee
   */
  export type Task$assigneeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Task.creator
   */
  export type Task$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Task.lead
   */
  export type Task$leadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
  }

  /**
   * Task.comments
   */
  export type Task$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    where?: TaskCommentWhereInput
    orderBy?: TaskCommentOrderByWithRelationInput | TaskCommentOrderByWithRelationInput[]
    cursor?: TaskCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskCommentScalarFieldEnum | TaskCommentScalarFieldEnum[]
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model TaskComment
   */

  export type AggregateTaskComment = {
    _count: TaskCommentCountAggregateOutputType | null
    _min: TaskCommentMinAggregateOutputType | null
    _max: TaskCommentMaxAggregateOutputType | null
  }

  export type TaskCommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    taskId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type TaskCommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    taskId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type TaskCommentCountAggregateOutputType = {
    id: number
    content: number
    taskId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type TaskCommentMinAggregateInputType = {
    id?: true
    content?: true
    taskId?: true
    userId?: true
    createdAt?: true
  }

  export type TaskCommentMaxAggregateInputType = {
    id?: true
    content?: true
    taskId?: true
    userId?: true
    createdAt?: true
  }

  export type TaskCommentCountAggregateInputType = {
    id?: true
    content?: true
    taskId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type TaskCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskComment to aggregate.
     */
    where?: TaskCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskComments to fetch.
     */
    orderBy?: TaskCommentOrderByWithRelationInput | TaskCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskComments
    **/
    _count?: true | TaskCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskCommentMaxAggregateInputType
  }

  export type GetTaskCommentAggregateType<T extends TaskCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskComment[P]>
      : GetScalarType<T[P], AggregateTaskComment[P]>
  }




  export type TaskCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCommentWhereInput
    orderBy?: TaskCommentOrderByWithAggregationInput | TaskCommentOrderByWithAggregationInput[]
    by: TaskCommentScalarFieldEnum[] | TaskCommentScalarFieldEnum
    having?: TaskCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCommentCountAggregateInputType | true
    _min?: TaskCommentMinAggregateInputType
    _max?: TaskCommentMaxAggregateInputType
  }

  export type TaskCommentGroupByOutputType = {
    id: string
    content: string
    taskId: string
    userId: string
    createdAt: Date
    _count: TaskCommentCountAggregateOutputType | null
    _min: TaskCommentMinAggregateOutputType | null
    _max: TaskCommentMaxAggregateOutputType | null
  }

  type GetTaskCommentGroupByPayload<T extends TaskCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskCommentGroupByOutputType[P]>
            : GetScalarType<T[P], TaskCommentGroupByOutputType[P]>
        }
      >
    >


  export type TaskCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    taskId?: boolean
    userId?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskComment"]>

  export type TaskCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    taskId?: boolean
    userId?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskComment"]>

  export type TaskCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    taskId?: boolean
    userId?: boolean
    createdAt?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskComment"]>

  export type TaskCommentSelectScalar = {
    id?: boolean
    content?: boolean
    taskId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type TaskCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "taskId" | "userId" | "createdAt", ExtArgs["result"]["taskComment"]>
  export type TaskCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskComment"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      taskId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["taskComment"]>
    composites: {}
  }

  type TaskCommentGetPayload<S extends boolean | null | undefined | TaskCommentDefaultArgs> = $Result.GetResult<Prisma.$TaskCommentPayload, S>

  type TaskCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCommentCountAggregateInputType | true
    }

  export interface TaskCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskComment'], meta: { name: 'TaskComment' } }
    /**
     * Find zero or one TaskComment that matches the filter.
     * @param {TaskCommentFindUniqueArgs} args - Arguments to find a TaskComment
     * @example
     * // Get one TaskComment
     * const taskComment = await prisma.taskComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskCommentFindUniqueArgs>(args: SelectSubset<T, TaskCommentFindUniqueArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskCommentFindUniqueOrThrowArgs} args - Arguments to find a TaskComment
     * @example
     * // Get one TaskComment
     * const taskComment = await prisma.taskComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCommentFindFirstArgs} args - Arguments to find a TaskComment
     * @example
     * // Get one TaskComment
     * const taskComment = await prisma.taskComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskCommentFindFirstArgs>(args?: SelectSubset<T, TaskCommentFindFirstArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCommentFindFirstOrThrowArgs} args - Arguments to find a TaskComment
     * @example
     * // Get one TaskComment
     * const taskComment = await prisma.taskComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskComments
     * const taskComments = await prisma.taskComment.findMany()
     * 
     * // Get first 10 TaskComments
     * const taskComments = await prisma.taskComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskCommentWithIdOnly = await prisma.taskComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskCommentFindManyArgs>(args?: SelectSubset<T, TaskCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskComment.
     * @param {TaskCommentCreateArgs} args - Arguments to create a TaskComment.
     * @example
     * // Create one TaskComment
     * const TaskComment = await prisma.taskComment.create({
     *   data: {
     *     // ... data to create a TaskComment
     *   }
     * })
     * 
     */
    create<T extends TaskCommentCreateArgs>(args: SelectSubset<T, TaskCommentCreateArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskComments.
     * @param {TaskCommentCreateManyArgs} args - Arguments to create many TaskComments.
     * @example
     * // Create many TaskComments
     * const taskComment = await prisma.taskComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCommentCreateManyArgs>(args?: SelectSubset<T, TaskCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskComments and returns the data saved in the database.
     * @param {TaskCommentCreateManyAndReturnArgs} args - Arguments to create many TaskComments.
     * @example
     * // Create many TaskComments
     * const taskComment = await prisma.taskComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskComments and only return the `id`
     * const taskCommentWithIdOnly = await prisma.taskComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskComment.
     * @param {TaskCommentDeleteArgs} args - Arguments to delete one TaskComment.
     * @example
     * // Delete one TaskComment
     * const TaskComment = await prisma.taskComment.delete({
     *   where: {
     *     // ... filter to delete one TaskComment
     *   }
     * })
     * 
     */
    delete<T extends TaskCommentDeleteArgs>(args: SelectSubset<T, TaskCommentDeleteArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskComment.
     * @param {TaskCommentUpdateArgs} args - Arguments to update one TaskComment.
     * @example
     * // Update one TaskComment
     * const taskComment = await prisma.taskComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskCommentUpdateArgs>(args: SelectSubset<T, TaskCommentUpdateArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskComments.
     * @param {TaskCommentDeleteManyArgs} args - Arguments to filter TaskComments to delete.
     * @example
     * // Delete a few TaskComments
     * const { count } = await prisma.taskComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskCommentDeleteManyArgs>(args?: SelectSubset<T, TaskCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskComments
     * const taskComment = await prisma.taskComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskCommentUpdateManyArgs>(args: SelectSubset<T, TaskCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskComments and returns the data updated in the database.
     * @param {TaskCommentUpdateManyAndReturnArgs} args - Arguments to update many TaskComments.
     * @example
     * // Update many TaskComments
     * const taskComment = await prisma.taskComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskComments and only return the `id`
     * const taskCommentWithIdOnly = await prisma.taskComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskComment.
     * @param {TaskCommentUpsertArgs} args - Arguments to update or create a TaskComment.
     * @example
     * // Update or create a TaskComment
     * const taskComment = await prisma.taskComment.upsert({
     *   create: {
     *     // ... data to create a TaskComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskComment we want to update
     *   }
     * })
     */
    upsert<T extends TaskCommentUpsertArgs>(args: SelectSubset<T, TaskCommentUpsertArgs<ExtArgs>>): Prisma__TaskCommentClient<$Result.GetResult<Prisma.$TaskCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCommentCountArgs} args - Arguments to filter TaskComments to count.
     * @example
     * // Count the number of TaskComments
     * const count = await prisma.taskComment.count({
     *   where: {
     *     // ... the filter for the TaskComments we want to count
     *   }
     * })
    **/
    count<T extends TaskCommentCountArgs>(
      args?: Subset<T, TaskCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskCommentAggregateArgs>(args: Subset<T, TaskCommentAggregateArgs>): Prisma.PrismaPromise<GetTaskCommentAggregateType<T>>

    /**
     * Group by TaskComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskCommentGroupByArgs['orderBy'] }
        : { orderBy?: TaskCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskComment model
   */
  readonly fields: TaskCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskComment model
   */
  interface TaskCommentFieldRefs {
    readonly id: FieldRef<"TaskComment", 'String'>
    readonly content: FieldRef<"TaskComment", 'String'>
    readonly taskId: FieldRef<"TaskComment", 'String'>
    readonly userId: FieldRef<"TaskComment", 'String'>
    readonly createdAt: FieldRef<"TaskComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskComment findUnique
   */
  export type TaskCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * Filter, which TaskComment to fetch.
     */
    where: TaskCommentWhereUniqueInput
  }

  /**
   * TaskComment findUniqueOrThrow
   */
  export type TaskCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * Filter, which TaskComment to fetch.
     */
    where: TaskCommentWhereUniqueInput
  }

  /**
   * TaskComment findFirst
   */
  export type TaskCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * Filter, which TaskComment to fetch.
     */
    where?: TaskCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskComments to fetch.
     */
    orderBy?: TaskCommentOrderByWithRelationInput | TaskCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskComments.
     */
    cursor?: TaskCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskComments.
     */
    distinct?: TaskCommentScalarFieldEnum | TaskCommentScalarFieldEnum[]
  }

  /**
   * TaskComment findFirstOrThrow
   */
  export type TaskCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * Filter, which TaskComment to fetch.
     */
    where?: TaskCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskComments to fetch.
     */
    orderBy?: TaskCommentOrderByWithRelationInput | TaskCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskComments.
     */
    cursor?: TaskCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskComments.
     */
    distinct?: TaskCommentScalarFieldEnum | TaskCommentScalarFieldEnum[]
  }

  /**
   * TaskComment findMany
   */
  export type TaskCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * Filter, which TaskComments to fetch.
     */
    where?: TaskCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskComments to fetch.
     */
    orderBy?: TaskCommentOrderByWithRelationInput | TaskCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskComments.
     */
    cursor?: TaskCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskComments.
     */
    skip?: number
    distinct?: TaskCommentScalarFieldEnum | TaskCommentScalarFieldEnum[]
  }

  /**
   * TaskComment create
   */
  export type TaskCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskComment.
     */
    data: XOR<TaskCommentCreateInput, TaskCommentUncheckedCreateInput>
  }

  /**
   * TaskComment createMany
   */
  export type TaskCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskComments.
     */
    data: TaskCommentCreateManyInput | TaskCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskComment createManyAndReturn
   */
  export type TaskCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * The data used to create many TaskComments.
     */
    data: TaskCommentCreateManyInput | TaskCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskComment update
   */
  export type TaskCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskComment.
     */
    data: XOR<TaskCommentUpdateInput, TaskCommentUncheckedUpdateInput>
    /**
     * Choose, which TaskComment to update.
     */
    where: TaskCommentWhereUniqueInput
  }

  /**
   * TaskComment updateMany
   */
  export type TaskCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskComments.
     */
    data: XOR<TaskCommentUpdateManyMutationInput, TaskCommentUncheckedUpdateManyInput>
    /**
     * Filter which TaskComments to update
     */
    where?: TaskCommentWhereInput
    /**
     * Limit how many TaskComments to update.
     */
    limit?: number
  }

  /**
   * TaskComment updateManyAndReturn
   */
  export type TaskCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * The data used to update TaskComments.
     */
    data: XOR<TaskCommentUpdateManyMutationInput, TaskCommentUncheckedUpdateManyInput>
    /**
     * Filter which TaskComments to update
     */
    where?: TaskCommentWhereInput
    /**
     * Limit how many TaskComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskComment upsert
   */
  export type TaskCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskComment to update in case it exists.
     */
    where: TaskCommentWhereUniqueInput
    /**
     * In case the TaskComment found by the `where` argument doesn't exist, create a new TaskComment with this data.
     */
    create: XOR<TaskCommentCreateInput, TaskCommentUncheckedCreateInput>
    /**
     * In case the TaskComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskCommentUpdateInput, TaskCommentUncheckedUpdateInput>
  }

  /**
   * TaskComment delete
   */
  export type TaskCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
    /**
     * Filter which TaskComment to delete.
     */
    where: TaskCommentWhereUniqueInput
  }

  /**
   * TaskComment deleteMany
   */
  export type TaskCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskComments to delete
     */
    where?: TaskCommentWhereInput
    /**
     * Limit how many TaskComments to delete.
     */
    limit?: number
  }

  /**
   * TaskComment without action
   */
  export type TaskCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskComment
     */
    select?: TaskCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskComment
     */
    omit?: TaskCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCommentInclude<ExtArgs> | null
  }


  /**
   * Model BlogPost
   */

  export type AggregateBlogPost = {
    _count: BlogPostCountAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  export type BlogPostMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    content: string | null
    summary: string | null
    coverImage: string | null
    status: $Enums.BlogStatus | null
    authorId: string | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogPostMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    content: string | null
    summary: string | null
    coverImage: string | null
    status: $Enums.BlogStatus | null
    authorId: string | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogPostCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    content: number
    summary: number
    coverImage: number
    status: number
    tags: number
    authorId: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogPostMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    summary?: true
    coverImage?: true
    status?: true
    authorId?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogPostMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    summary?: true
    coverImage?: true
    status?: true
    authorId?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogPostCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    summary?: true
    coverImage?: true
    status?: true
    tags?: true
    authorId?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPost to aggregate.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogPosts
    **/
    _count?: true | BlogPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogPostMaxAggregateInputType
  }

  export type GetBlogPostAggregateType<T extends BlogPostAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogPost[P]>
      : GetScalarType<T[P], AggregateBlogPost[P]>
  }




  export type BlogPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithAggregationInput | BlogPostOrderByWithAggregationInput[]
    by: BlogPostScalarFieldEnum[] | BlogPostScalarFieldEnum
    having?: BlogPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogPostCountAggregateInputType | true
    _min?: BlogPostMinAggregateInputType
    _max?: BlogPostMaxAggregateInputType
  }

  export type BlogPostGroupByOutputType = {
    id: string
    title: string
    slug: string
    content: string
    summary: string | null
    coverImage: string | null
    status: $Enums.BlogStatus
    tags: JsonValue | null
    authorId: string
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: BlogPostCountAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  type GetBlogPostGroupByPayload<T extends BlogPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
            : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
        }
      >
    >


  export type BlogPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    summary?: boolean
    coverImage?: boolean
    status?: boolean
    tags?: boolean
    authorId?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    summary?: boolean
    coverImage?: boolean
    status?: boolean
    tags?: boolean
    authorId?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    summary?: boolean
    coverImage?: boolean
    status?: boolean
    tags?: boolean
    authorId?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    summary?: boolean
    coverImage?: boolean
    status?: boolean
    tags?: boolean
    authorId?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlogPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "content" | "summary" | "coverImage" | "status" | "tags" | "authorId" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["blogPost"]>
  export type BlogPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlogPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlogPostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BlogPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogPost"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      content: string
      summary: string | null
      coverImage: string | null
      status: $Enums.BlogStatus
      tags: Prisma.JsonValue | null
      authorId: string
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blogPost"]>
    composites: {}
  }

  type BlogPostGetPayload<S extends boolean | null | undefined | BlogPostDefaultArgs> = $Result.GetResult<Prisma.$BlogPostPayload, S>

  type BlogPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogPostCountAggregateInputType | true
    }

  export interface BlogPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogPost'], meta: { name: 'BlogPost' } }
    /**
     * Find zero or one BlogPost that matches the filter.
     * @param {BlogPostFindUniqueArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogPostFindUniqueArgs>(args: SelectSubset<T, BlogPostFindUniqueArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogPostFindUniqueOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogPostFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogPostFindFirstArgs>(args?: SelectSubset<T, BlogPostFindFirstArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogPostFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogPosts
     * const blogPosts = await prisma.blogPost.findMany()
     * 
     * // Get first 10 BlogPosts
     * const blogPosts = await prisma.blogPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogPostFindManyArgs>(args?: SelectSubset<T, BlogPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogPost.
     * @param {BlogPostCreateArgs} args - Arguments to create a BlogPost.
     * @example
     * // Create one BlogPost
     * const BlogPost = await prisma.blogPost.create({
     *   data: {
     *     // ... data to create a BlogPost
     *   }
     * })
     * 
     */
    create<T extends BlogPostCreateArgs>(args: SelectSubset<T, BlogPostCreateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogPosts.
     * @param {BlogPostCreateManyArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogPostCreateManyArgs>(args?: SelectSubset<T, BlogPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogPosts and returns the data saved in the database.
     * @param {BlogPostCreateManyAndReturnArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogPosts and only return the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogPostCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlogPost.
     * @param {BlogPostDeleteArgs} args - Arguments to delete one BlogPost.
     * @example
     * // Delete one BlogPost
     * const BlogPost = await prisma.blogPost.delete({
     *   where: {
     *     // ... filter to delete one BlogPost
     *   }
     * })
     * 
     */
    delete<T extends BlogPostDeleteArgs>(args: SelectSubset<T, BlogPostDeleteArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogPost.
     * @param {BlogPostUpdateArgs} args - Arguments to update one BlogPost.
     * @example
     * // Update one BlogPost
     * const blogPost = await prisma.blogPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogPostUpdateArgs>(args: SelectSubset<T, BlogPostUpdateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogPosts.
     * @param {BlogPostDeleteManyArgs} args - Arguments to filter BlogPosts to delete.
     * @example
     * // Delete a few BlogPosts
     * const { count } = await prisma.blogPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogPostDeleteManyArgs>(args?: SelectSubset<T, BlogPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogPostUpdateManyArgs>(args: SelectSubset<T, BlogPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts and returns the data updated in the database.
     * @param {BlogPostUpdateManyAndReturnArgs} args - Arguments to update many BlogPosts.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlogPosts and only return the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogPostUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogPostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlogPost.
     * @param {BlogPostUpsertArgs} args - Arguments to update or create a BlogPost.
     * @example
     * // Update or create a BlogPost
     * const blogPost = await prisma.blogPost.upsert({
     *   create: {
     *     // ... data to create a BlogPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogPost we want to update
     *   }
     * })
     */
    upsert<T extends BlogPostUpsertArgs>(args: SelectSubset<T, BlogPostUpsertArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostCountArgs} args - Arguments to filter BlogPosts to count.
     * @example
     * // Count the number of BlogPosts
     * const count = await prisma.blogPost.count({
     *   where: {
     *     // ... the filter for the BlogPosts we want to count
     *   }
     * })
    **/
    count<T extends BlogPostCountArgs>(
      args?: Subset<T, BlogPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogPostAggregateArgs>(args: Subset<T, BlogPostAggregateArgs>): Prisma.PrismaPromise<GetBlogPostAggregateType<T>>

    /**
     * Group by BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogPostGroupByArgs['orderBy'] }
        : { orderBy?: BlogPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogPost model
   */
  readonly fields: BlogPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogPost model
   */
  interface BlogPostFieldRefs {
    readonly id: FieldRef<"BlogPost", 'String'>
    readonly title: FieldRef<"BlogPost", 'String'>
    readonly slug: FieldRef<"BlogPost", 'String'>
    readonly content: FieldRef<"BlogPost", 'String'>
    readonly summary: FieldRef<"BlogPost", 'String'>
    readonly coverImage: FieldRef<"BlogPost", 'String'>
    readonly status: FieldRef<"BlogPost", 'BlogStatus'>
    readonly tags: FieldRef<"BlogPost", 'Json'>
    readonly authorId: FieldRef<"BlogPost", 'String'>
    readonly publishedAt: FieldRef<"BlogPost", 'DateTime'>
    readonly createdAt: FieldRef<"BlogPost", 'DateTime'>
    readonly updatedAt: FieldRef<"BlogPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogPost findUnique
   */
  export type BlogPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findUniqueOrThrow
   */
  export type BlogPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findFirst
   */
  export type BlogPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findFirstOrThrow
   */
  export type BlogPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findMany
   */
  export type BlogPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPosts to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost create
   */
  export type BlogPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogPost.
     */
    data: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
  }

  /**
   * BlogPost createMany
   */
  export type BlogPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPost createManyAndReturn
   */
  export type BlogPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPost update
   */
  export type BlogPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogPost.
     */
    data: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
    /**
     * Choose, which BlogPost to update.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost updateMany
   */
  export type BlogPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to update.
     */
    limit?: number
  }

  /**
   * BlogPost updateManyAndReturn
   */
  export type BlogPostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPost upsert
   */
  export type BlogPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogPost to update in case it exists.
     */
    where: BlogPostWhereUniqueInput
    /**
     * In case the BlogPost found by the `where` argument doesn't exist, create a new BlogPost with this data.
     */
    create: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
    /**
     * In case the BlogPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
  }

  /**
   * BlogPost delete
   */
  export type BlogPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter which BlogPost to delete.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost deleteMany
   */
  export type BlogPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPosts to delete
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to delete.
     */
    limit?: number
  }

  /**
   * BlogPost without action
   */
  export type BlogPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
  }


  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketMinAggregateOutputType = {
    id: string | null
    subject: string | null
    description: string | null
    status: $Enums.TicketStatus | null
    priority: $Enums.TicketPriority | null
    category: $Enums.TicketCategory | null
    userId: string | null
    assignedTo: string | null
    internalNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketMaxAggregateOutputType = {
    id: string | null
    subject: string | null
    description: string | null
    status: $Enums.TicketStatus | null
    priority: $Enums.TicketPriority | null
    category: $Enums.TicketCategory | null
    userId: string | null
    assignedTo: string | null
    internalNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    subject: number
    description: number
    status: number
    priority: number
    category: number
    userId: number
    assignedTo: number
    internalNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TicketMinAggregateInputType = {
    id?: true
    subject?: true
    description?: true
    status?: true
    priority?: true
    category?: true
    userId?: true
    assignedTo?: true
    internalNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
    subject?: true
    description?: true
    status?: true
    priority?: true
    category?: true
    userId?: true
    assignedTo?: true
    internalNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    subject?: true
    description?: true
    status?: true
    priority?: true
    category?: true
    userId?: true
    assignedTo?: true
    internalNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: string
    subject: string
    description: string
    status: $Enums.TicketStatus
    priority: $Enums.TicketPriority
    category: $Enums.TicketCategory
    userId: string
    assignedTo: string | null
    internalNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: TicketCountAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    category?: boolean
    userId?: boolean
    assignedTo?: boolean
    internalNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | Ticket$messagesArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    category?: boolean
    userId?: boolean
    assignedTo?: boolean
    internalNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    category?: boolean
    userId?: boolean
    assignedTo?: boolean
    internalNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectScalar = {
    id?: boolean
    subject?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    category?: boolean
    userId?: boolean
    assignedTo?: boolean
    internalNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subject" | "description" | "status" | "priority" | "category" | "userId" | "assignedTo" | "internalNotes" | "createdAt" | "updatedAt", ExtArgs["result"]["ticket"]>
  export type TicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | Ticket$messagesArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$TicketMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subject: string
      description: string
      status: $Enums.TicketStatus
      priority: $Enums.TicketPriority
      category: $Enums.TicketCategory
      userId: string
      assignedTo: string | null
      internalNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tickets and returns the data saved in the database.
     * @param {TicketCreateManyAndReturnArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets and returns the data updated in the database.
     * @param {TicketUpdateManyAndReturnArgs} args - Arguments to update many Tickets.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends Ticket$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'String'>
    readonly subject: FieldRef<"Ticket", 'String'>
    readonly description: FieldRef<"Ticket", 'String'>
    readonly status: FieldRef<"Ticket", 'TicketStatus'>
    readonly priority: FieldRef<"Ticket", 'TicketPriority'>
    readonly category: FieldRef<"Ticket", 'TicketCategory'>
    readonly userId: FieldRef<"Ticket", 'String'>
    readonly assignedTo: FieldRef<"Ticket", 'String'>
    readonly internalNotes: FieldRef<"Ticket", 'String'>
    readonly createdAt: FieldRef<"Ticket", 'DateTime'>
    readonly updatedAt: FieldRef<"Ticket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data: XOR<TicketCreateInput, TicketUncheckedCreateInput>
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ticket createManyAndReturn
   */
  export type TicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
  }

  /**
   * Ticket updateManyAndReturn
   */
  export type TicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to delete.
     */
    limit?: number
  }

  /**
   * Ticket.messages
   */
  export type Ticket$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMessage
     */
    omit?: TicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    where?: TicketMessageWhereInput
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    cursor?: TicketMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketMessageScalarFieldEnum | TicketMessageScalarFieldEnum[]
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
  }


  /**
   * Model TicketMessage
   */

  export type AggregateTicketMessage = {
    _count: TicketMessageCountAggregateOutputType | null
    _min: TicketMessageMinAggregateOutputType | null
    _max: TicketMessageMaxAggregateOutputType | null
  }

  export type TicketMessageMinAggregateOutputType = {
    id: string | null
    message: string | null
    attachmentUrl: string | null
    isStaffReply: boolean | null
    ticketId: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type TicketMessageMaxAggregateOutputType = {
    id: string | null
    message: string | null
    attachmentUrl: string | null
    isStaffReply: boolean | null
    ticketId: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type TicketMessageCountAggregateOutputType = {
    id: number
    message: number
    attachmentUrl: number
    isStaffReply: number
    ticketId: number
    createdAt: number
    userId: number
    _all: number
  }


  export type TicketMessageMinAggregateInputType = {
    id?: true
    message?: true
    attachmentUrl?: true
    isStaffReply?: true
    ticketId?: true
    createdAt?: true
    userId?: true
  }

  export type TicketMessageMaxAggregateInputType = {
    id?: true
    message?: true
    attachmentUrl?: true
    isStaffReply?: true
    ticketId?: true
    createdAt?: true
    userId?: true
  }

  export type TicketMessageCountAggregateInputType = {
    id?: true
    message?: true
    attachmentUrl?: true
    isStaffReply?: true
    ticketId?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type TicketMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketMessage to aggregate.
     */
    where?: TicketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketMessages to fetch.
     */
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketMessages
    **/
    _count?: true | TicketMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMessageMaxAggregateInputType
  }

  export type GetTicketMessageAggregateType<T extends TicketMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketMessage[P]>
      : GetScalarType<T[P], AggregateTicketMessage[P]>
  }




  export type TicketMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketMessageWhereInput
    orderBy?: TicketMessageOrderByWithAggregationInput | TicketMessageOrderByWithAggregationInput[]
    by: TicketMessageScalarFieldEnum[] | TicketMessageScalarFieldEnum
    having?: TicketMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketMessageCountAggregateInputType | true
    _min?: TicketMessageMinAggregateInputType
    _max?: TicketMessageMaxAggregateInputType
  }

  export type TicketMessageGroupByOutputType = {
    id: string
    message: string
    attachmentUrl: string | null
    isStaffReply: boolean
    ticketId: string
    createdAt: Date
    userId: string | null
    _count: TicketMessageCountAggregateOutputType | null
    _min: TicketMessageMinAggregateOutputType | null
    _max: TicketMessageMaxAggregateOutputType | null
  }

  type GetTicketMessageGroupByPayload<T extends TicketMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketMessageGroupByOutputType[P]>
            : GetScalarType<T[P], TicketMessageGroupByOutputType[P]>
        }
      >
    >


  export type TicketMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    attachmentUrl?: boolean
    isStaffReply?: boolean
    ticketId?: boolean
    createdAt?: boolean
    userId?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | TicketMessage$userArgs<ExtArgs>
  }, ExtArgs["result"]["ticketMessage"]>

  export type TicketMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    attachmentUrl?: boolean
    isStaffReply?: boolean
    ticketId?: boolean
    createdAt?: boolean
    userId?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | TicketMessage$userArgs<ExtArgs>
  }, ExtArgs["result"]["ticketMessage"]>

  export type TicketMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    attachmentUrl?: boolean
    isStaffReply?: boolean
    ticketId?: boolean
    createdAt?: boolean
    userId?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | TicketMessage$userArgs<ExtArgs>
  }, ExtArgs["result"]["ticketMessage"]>

  export type TicketMessageSelectScalar = {
    id?: boolean
    message?: boolean
    attachmentUrl?: boolean
    isStaffReply?: boolean
    ticketId?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type TicketMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "message" | "attachmentUrl" | "isStaffReply" | "ticketId" | "createdAt" | "userId", ExtArgs["result"]["ticketMessage"]>
  export type TicketMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | TicketMessage$userArgs<ExtArgs>
  }
  export type TicketMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | TicketMessage$userArgs<ExtArgs>
  }
  export type TicketMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | TicketMessage$userArgs<ExtArgs>
  }

  export type $TicketMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketMessage"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      message: string
      attachmentUrl: string | null
      isStaffReply: boolean
      ticketId: string
      createdAt: Date
      userId: string | null
    }, ExtArgs["result"]["ticketMessage"]>
    composites: {}
  }

  type TicketMessageGetPayload<S extends boolean | null | undefined | TicketMessageDefaultArgs> = $Result.GetResult<Prisma.$TicketMessagePayload, S>

  type TicketMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketMessageCountAggregateInputType | true
    }

  export interface TicketMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketMessage'], meta: { name: 'TicketMessage' } }
    /**
     * Find zero or one TicketMessage that matches the filter.
     * @param {TicketMessageFindUniqueArgs} args - Arguments to find a TicketMessage
     * @example
     * // Get one TicketMessage
     * const ticketMessage = await prisma.ticketMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketMessageFindUniqueArgs>(args: SelectSubset<T, TicketMessageFindUniqueArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketMessageFindUniqueOrThrowArgs} args - Arguments to find a TicketMessage
     * @example
     * // Get one TicketMessage
     * const ticketMessage = await prisma.ticketMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageFindFirstArgs} args - Arguments to find a TicketMessage
     * @example
     * // Get one TicketMessage
     * const ticketMessage = await prisma.ticketMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketMessageFindFirstArgs>(args?: SelectSubset<T, TicketMessageFindFirstArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageFindFirstOrThrowArgs} args - Arguments to find a TicketMessage
     * @example
     * // Get one TicketMessage
     * const ticketMessage = await prisma.ticketMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketMessages
     * const ticketMessages = await prisma.ticketMessage.findMany()
     * 
     * // Get first 10 TicketMessages
     * const ticketMessages = await prisma.ticketMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketMessageWithIdOnly = await prisma.ticketMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketMessageFindManyArgs>(args?: SelectSubset<T, TicketMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketMessage.
     * @param {TicketMessageCreateArgs} args - Arguments to create a TicketMessage.
     * @example
     * // Create one TicketMessage
     * const TicketMessage = await prisma.ticketMessage.create({
     *   data: {
     *     // ... data to create a TicketMessage
     *   }
     * })
     * 
     */
    create<T extends TicketMessageCreateArgs>(args: SelectSubset<T, TicketMessageCreateArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketMessages.
     * @param {TicketMessageCreateManyArgs} args - Arguments to create many TicketMessages.
     * @example
     * // Create many TicketMessages
     * const ticketMessage = await prisma.ticketMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketMessageCreateManyArgs>(args?: SelectSubset<T, TicketMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketMessages and returns the data saved in the database.
     * @param {TicketMessageCreateManyAndReturnArgs} args - Arguments to create many TicketMessages.
     * @example
     * // Create many TicketMessages
     * const ticketMessage = await prisma.ticketMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketMessages and only return the `id`
     * const ticketMessageWithIdOnly = await prisma.ticketMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TicketMessage.
     * @param {TicketMessageDeleteArgs} args - Arguments to delete one TicketMessage.
     * @example
     * // Delete one TicketMessage
     * const TicketMessage = await prisma.ticketMessage.delete({
     *   where: {
     *     // ... filter to delete one TicketMessage
     *   }
     * })
     * 
     */
    delete<T extends TicketMessageDeleteArgs>(args: SelectSubset<T, TicketMessageDeleteArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketMessage.
     * @param {TicketMessageUpdateArgs} args - Arguments to update one TicketMessage.
     * @example
     * // Update one TicketMessage
     * const ticketMessage = await prisma.ticketMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketMessageUpdateArgs>(args: SelectSubset<T, TicketMessageUpdateArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketMessages.
     * @param {TicketMessageDeleteManyArgs} args - Arguments to filter TicketMessages to delete.
     * @example
     * // Delete a few TicketMessages
     * const { count } = await prisma.ticketMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketMessageDeleteManyArgs>(args?: SelectSubset<T, TicketMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketMessages
     * const ticketMessage = await prisma.ticketMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketMessageUpdateManyArgs>(args: SelectSubset<T, TicketMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketMessages and returns the data updated in the database.
     * @param {TicketMessageUpdateManyAndReturnArgs} args - Arguments to update many TicketMessages.
     * @example
     * // Update many TicketMessages
     * const ticketMessage = await prisma.ticketMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketMessages and only return the `id`
     * const ticketMessageWithIdOnly = await prisma.ticketMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TicketMessage.
     * @param {TicketMessageUpsertArgs} args - Arguments to update or create a TicketMessage.
     * @example
     * // Update or create a TicketMessage
     * const ticketMessage = await prisma.ticketMessage.upsert({
     *   create: {
     *     // ... data to create a TicketMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketMessage we want to update
     *   }
     * })
     */
    upsert<T extends TicketMessageUpsertArgs>(args: SelectSubset<T, TicketMessageUpsertArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TicketMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageCountArgs} args - Arguments to filter TicketMessages to count.
     * @example
     * // Count the number of TicketMessages
     * const count = await prisma.ticketMessage.count({
     *   where: {
     *     // ... the filter for the TicketMessages we want to count
     *   }
     * })
    **/
    count<T extends TicketMessageCountArgs>(
      args?: Subset<T, TicketMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketMessageAggregateArgs>(args: Subset<T, TicketMessageAggregateArgs>): Prisma.PrismaPromise<GetTicketMessageAggregateType<T>>

    /**
     * Group by TicketMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketMessageGroupByArgs['orderBy'] }
        : { orderBy?: TicketMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketMessage model
   */
  readonly fields: TicketMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends TicketMessage$userArgs<ExtArgs> = {}>(args?: Subset<T, TicketMessage$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketMessage model
   */
  interface TicketMessageFieldRefs {
    readonly id: FieldRef<"TicketMessage", 'String'>
    readonly message: FieldRef<"TicketMessage", 'String'>
    readonly attachmentUrl: FieldRef<"TicketMessage", 'String'>
    readonly isStaffReply: FieldRef<"TicketMessage", 'Boolean'>
    readonly ticketId: FieldRef<"TicketMessage", 'String'>
    readonly createdAt: FieldRef<"TicketMessage", 'DateTime'>
    readonly userId: FieldRef<"TicketMessage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TicketMessage findUnique
   */
  export type TicketMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMessage
     */
    omit?: TicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which TicketMessage to fetch.
     */
    where: TicketMessageWhereUniqueInput
  }

  /**
   * TicketMessage findUniqueOrThrow
   */
  export type TicketMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMessage
     */
    omit?: TicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which TicketMessage to fetch.
     */
    where: TicketMessageWhereUniqueInput
  }

  /**
   * TicketMessage findFirst
   */
  export type TicketMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMessage
     */
    omit?: TicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which TicketMessage to fetch.
     */
    where?: TicketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketMessages to fetch.
     */
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketMessages.
     */
    cursor?: TicketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketMessages.
     */
    distinct?: TicketMessageScalarFieldEnum | TicketMessageScalarFieldEnum[]
  }

  /**
   * TicketMessage findFirstOrThrow
   */
  export type TicketMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMessage
     */
    omit?: TicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which TicketMessage to fetch.
     */
    where?: TicketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketMessages to fetch.
     */
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketMessages.
     */
    cursor?: TicketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketMessages.
     */
    distinct?: TicketMessageScalarFieldEnum | TicketMessageScalarFieldEnum[]
  }

  /**
   * TicketMessage findMany
   */
  export type TicketMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMessage
     */
    omit?: TicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which TicketMessages to fetch.
     */
    where?: TicketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketMessages to fetch.
     */
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketMessages.
     */
    cursor?: TicketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketMessages.
     */
    skip?: number
    distinct?: TicketMessageScalarFieldEnum | TicketMessageScalarFieldEnum[]
  }

  /**
   * TicketMessage create
   */
  export type TicketMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMessage
     */
    omit?: TicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketMessage.
     */
    data: XOR<TicketMessageCreateInput, TicketMessageUncheckedCreateInput>
  }

  /**
   * TicketMessage createMany
   */
  export type TicketMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketMessages.
     */
    data: TicketMessageCreateManyInput | TicketMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketMessage createManyAndReturn
   */
  export type TicketMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMessage
     */
    omit?: TicketMessageOmit<ExtArgs> | null
    /**
     * The data used to create many TicketMessages.
     */
    data: TicketMessageCreateManyInput | TicketMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketMessage update
   */
  export type TicketMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMessage
     */
    omit?: TicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketMessage.
     */
    data: XOR<TicketMessageUpdateInput, TicketMessageUncheckedUpdateInput>
    /**
     * Choose, which TicketMessage to update.
     */
    where: TicketMessageWhereUniqueInput
  }

  /**
   * TicketMessage updateMany
   */
  export type TicketMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketMessages.
     */
    data: XOR<TicketMessageUpdateManyMutationInput, TicketMessageUncheckedUpdateManyInput>
    /**
     * Filter which TicketMessages to update
     */
    where?: TicketMessageWhereInput
    /**
     * Limit how many TicketMessages to update.
     */
    limit?: number
  }

  /**
   * TicketMessage updateManyAndReturn
   */
  export type TicketMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMessage
     */
    omit?: TicketMessageOmit<ExtArgs> | null
    /**
     * The data used to update TicketMessages.
     */
    data: XOR<TicketMessageUpdateManyMutationInput, TicketMessageUncheckedUpdateManyInput>
    /**
     * Filter which TicketMessages to update
     */
    where?: TicketMessageWhereInput
    /**
     * Limit how many TicketMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketMessage upsert
   */
  export type TicketMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMessage
     */
    omit?: TicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketMessage to update in case it exists.
     */
    where: TicketMessageWhereUniqueInput
    /**
     * In case the TicketMessage found by the `where` argument doesn't exist, create a new TicketMessage with this data.
     */
    create: XOR<TicketMessageCreateInput, TicketMessageUncheckedCreateInput>
    /**
     * In case the TicketMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketMessageUpdateInput, TicketMessageUncheckedUpdateInput>
  }

  /**
   * TicketMessage delete
   */
  export type TicketMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMessage
     */
    omit?: TicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter which TicketMessage to delete.
     */
    where: TicketMessageWhereUniqueInput
  }

  /**
   * TicketMessage deleteMany
   */
  export type TicketMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketMessages to delete
     */
    where?: TicketMessageWhereInput
    /**
     * Limit how many TicketMessages to delete.
     */
    limit?: number
  }

  /**
   * TicketMessage.user
   */
  export type TicketMessage$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TicketMessage without action
   */
  export type TicketMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMessage
     */
    omit?: TicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
  }


  /**
   * Model PaymentConfig
   */

  export type AggregatePaymentConfig = {
    _count: PaymentConfigCountAggregateOutputType | null
    _min: PaymentConfigMinAggregateOutputType | null
    _max: PaymentConfigMaxAggregateOutputType | null
  }

  export type PaymentConfigMinAggregateOutputType = {
    id: string | null
    razorpayKeyId: string | null
    razorpayKeySecret: string | null
    stripePublishableKey: string | null
    stripeSecretKey: string | null
    activeGateway: $Enums.Gateway | null
    currency: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentConfigMaxAggregateOutputType = {
    id: string | null
    razorpayKeyId: string | null
    razorpayKeySecret: string | null
    stripePublishableKey: string | null
    stripeSecretKey: string | null
    activeGateway: $Enums.Gateway | null
    currency: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentConfigCountAggregateOutputType = {
    id: number
    razorpayKeyId: number
    razorpayKeySecret: number
    stripePublishableKey: number
    stripeSecretKey: number
    activeGateway: number
    currency: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentConfigMinAggregateInputType = {
    id?: true
    razorpayKeyId?: true
    razorpayKeySecret?: true
    stripePublishableKey?: true
    stripeSecretKey?: true
    activeGateway?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentConfigMaxAggregateInputType = {
    id?: true
    razorpayKeyId?: true
    razorpayKeySecret?: true
    stripePublishableKey?: true
    stripeSecretKey?: true
    activeGateway?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentConfigCountAggregateInputType = {
    id?: true
    razorpayKeyId?: true
    razorpayKeySecret?: true
    stripePublishableKey?: true
    stripeSecretKey?: true
    activeGateway?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentConfig to aggregate.
     */
    where?: PaymentConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentConfigs to fetch.
     */
    orderBy?: PaymentConfigOrderByWithRelationInput | PaymentConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentConfigs
    **/
    _count?: true | PaymentConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentConfigMaxAggregateInputType
  }

  export type GetPaymentConfigAggregateType<T extends PaymentConfigAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentConfig[P]>
      : GetScalarType<T[P], AggregatePaymentConfig[P]>
  }




  export type PaymentConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentConfigWhereInput
    orderBy?: PaymentConfigOrderByWithAggregationInput | PaymentConfigOrderByWithAggregationInput[]
    by: PaymentConfigScalarFieldEnum[] | PaymentConfigScalarFieldEnum
    having?: PaymentConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentConfigCountAggregateInputType | true
    _min?: PaymentConfigMinAggregateInputType
    _max?: PaymentConfigMaxAggregateInputType
  }

  export type PaymentConfigGroupByOutputType = {
    id: string
    razorpayKeyId: string | null
    razorpayKeySecret: string | null
    stripePublishableKey: string | null
    stripeSecretKey: string | null
    activeGateway: $Enums.Gateway
    currency: string
    createdAt: Date
    updatedAt: Date
    _count: PaymentConfigCountAggregateOutputType | null
    _min: PaymentConfigMinAggregateOutputType | null
    _max: PaymentConfigMaxAggregateOutputType | null
  }

  type GetPaymentConfigGroupByPayload<T extends PaymentConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentConfigGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentConfigGroupByOutputType[P]>
        }
      >
    >


  export type PaymentConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razorpayKeyId?: boolean
    razorpayKeySecret?: boolean
    stripePublishableKey?: boolean
    stripeSecretKey?: boolean
    activeGateway?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentConfig"]>

  export type PaymentConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razorpayKeyId?: boolean
    razorpayKeySecret?: boolean
    stripePublishableKey?: boolean
    stripeSecretKey?: boolean
    activeGateway?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentConfig"]>

  export type PaymentConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razorpayKeyId?: boolean
    razorpayKeySecret?: boolean
    stripePublishableKey?: boolean
    stripeSecretKey?: boolean
    activeGateway?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentConfig"]>

  export type PaymentConfigSelectScalar = {
    id?: boolean
    razorpayKeyId?: boolean
    razorpayKeySecret?: boolean
    stripePublishableKey?: boolean
    stripeSecretKey?: boolean
    activeGateway?: boolean
    currency?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "razorpayKeyId" | "razorpayKeySecret" | "stripePublishableKey" | "stripeSecretKey" | "activeGateway" | "currency" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentConfig"]>

  export type $PaymentConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      razorpayKeyId: string | null
      razorpayKeySecret: string | null
      stripePublishableKey: string | null
      stripeSecretKey: string | null
      activeGateway: $Enums.Gateway
      currency: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentConfig"]>
    composites: {}
  }

  type PaymentConfigGetPayload<S extends boolean | null | undefined | PaymentConfigDefaultArgs> = $Result.GetResult<Prisma.$PaymentConfigPayload, S>

  type PaymentConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentConfigCountAggregateInputType | true
    }

  export interface PaymentConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentConfig'], meta: { name: 'PaymentConfig' } }
    /**
     * Find zero or one PaymentConfig that matches the filter.
     * @param {PaymentConfigFindUniqueArgs} args - Arguments to find a PaymentConfig
     * @example
     * // Get one PaymentConfig
     * const paymentConfig = await prisma.paymentConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentConfigFindUniqueArgs>(args: SelectSubset<T, PaymentConfigFindUniqueArgs<ExtArgs>>): Prisma__PaymentConfigClient<$Result.GetResult<Prisma.$PaymentConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentConfigFindUniqueOrThrowArgs} args - Arguments to find a PaymentConfig
     * @example
     * // Get one PaymentConfig
     * const paymentConfig = await prisma.paymentConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentConfigClient<$Result.GetResult<Prisma.$PaymentConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentConfigFindFirstArgs} args - Arguments to find a PaymentConfig
     * @example
     * // Get one PaymentConfig
     * const paymentConfig = await prisma.paymentConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentConfigFindFirstArgs>(args?: SelectSubset<T, PaymentConfigFindFirstArgs<ExtArgs>>): Prisma__PaymentConfigClient<$Result.GetResult<Prisma.$PaymentConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentConfigFindFirstOrThrowArgs} args - Arguments to find a PaymentConfig
     * @example
     * // Get one PaymentConfig
     * const paymentConfig = await prisma.paymentConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentConfigClient<$Result.GetResult<Prisma.$PaymentConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentConfigs
     * const paymentConfigs = await prisma.paymentConfig.findMany()
     * 
     * // Get first 10 PaymentConfigs
     * const paymentConfigs = await prisma.paymentConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentConfigWithIdOnly = await prisma.paymentConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentConfigFindManyArgs>(args?: SelectSubset<T, PaymentConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentConfig.
     * @param {PaymentConfigCreateArgs} args - Arguments to create a PaymentConfig.
     * @example
     * // Create one PaymentConfig
     * const PaymentConfig = await prisma.paymentConfig.create({
     *   data: {
     *     // ... data to create a PaymentConfig
     *   }
     * })
     * 
     */
    create<T extends PaymentConfigCreateArgs>(args: SelectSubset<T, PaymentConfigCreateArgs<ExtArgs>>): Prisma__PaymentConfigClient<$Result.GetResult<Prisma.$PaymentConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentConfigs.
     * @param {PaymentConfigCreateManyArgs} args - Arguments to create many PaymentConfigs.
     * @example
     * // Create many PaymentConfigs
     * const paymentConfig = await prisma.paymentConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentConfigCreateManyArgs>(args?: SelectSubset<T, PaymentConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentConfigs and returns the data saved in the database.
     * @param {PaymentConfigCreateManyAndReturnArgs} args - Arguments to create many PaymentConfigs.
     * @example
     * // Create many PaymentConfigs
     * const paymentConfig = await prisma.paymentConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentConfigs and only return the `id`
     * const paymentConfigWithIdOnly = await prisma.paymentConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentConfig.
     * @param {PaymentConfigDeleteArgs} args - Arguments to delete one PaymentConfig.
     * @example
     * // Delete one PaymentConfig
     * const PaymentConfig = await prisma.paymentConfig.delete({
     *   where: {
     *     // ... filter to delete one PaymentConfig
     *   }
     * })
     * 
     */
    delete<T extends PaymentConfigDeleteArgs>(args: SelectSubset<T, PaymentConfigDeleteArgs<ExtArgs>>): Prisma__PaymentConfigClient<$Result.GetResult<Prisma.$PaymentConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentConfig.
     * @param {PaymentConfigUpdateArgs} args - Arguments to update one PaymentConfig.
     * @example
     * // Update one PaymentConfig
     * const paymentConfig = await prisma.paymentConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentConfigUpdateArgs>(args: SelectSubset<T, PaymentConfigUpdateArgs<ExtArgs>>): Prisma__PaymentConfigClient<$Result.GetResult<Prisma.$PaymentConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentConfigs.
     * @param {PaymentConfigDeleteManyArgs} args - Arguments to filter PaymentConfigs to delete.
     * @example
     * // Delete a few PaymentConfigs
     * const { count } = await prisma.paymentConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentConfigDeleteManyArgs>(args?: SelectSubset<T, PaymentConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentConfigs
     * const paymentConfig = await prisma.paymentConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentConfigUpdateManyArgs>(args: SelectSubset<T, PaymentConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentConfigs and returns the data updated in the database.
     * @param {PaymentConfigUpdateManyAndReturnArgs} args - Arguments to update many PaymentConfigs.
     * @example
     * // Update many PaymentConfigs
     * const paymentConfig = await prisma.paymentConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentConfigs and only return the `id`
     * const paymentConfigWithIdOnly = await prisma.paymentConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentConfig.
     * @param {PaymentConfigUpsertArgs} args - Arguments to update or create a PaymentConfig.
     * @example
     * // Update or create a PaymentConfig
     * const paymentConfig = await prisma.paymentConfig.upsert({
     *   create: {
     *     // ... data to create a PaymentConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentConfig we want to update
     *   }
     * })
     */
    upsert<T extends PaymentConfigUpsertArgs>(args: SelectSubset<T, PaymentConfigUpsertArgs<ExtArgs>>): Prisma__PaymentConfigClient<$Result.GetResult<Prisma.$PaymentConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentConfigCountArgs} args - Arguments to filter PaymentConfigs to count.
     * @example
     * // Count the number of PaymentConfigs
     * const count = await prisma.paymentConfig.count({
     *   where: {
     *     // ... the filter for the PaymentConfigs we want to count
     *   }
     * })
    **/
    count<T extends PaymentConfigCountArgs>(
      args?: Subset<T, PaymentConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentConfigAggregateArgs>(args: Subset<T, PaymentConfigAggregateArgs>): Prisma.PrismaPromise<GetPaymentConfigAggregateType<T>>

    /**
     * Group by PaymentConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentConfigGroupByArgs['orderBy'] }
        : { orderBy?: PaymentConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentConfig model
   */
  readonly fields: PaymentConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentConfig model
   */
  interface PaymentConfigFieldRefs {
    readonly id: FieldRef<"PaymentConfig", 'String'>
    readonly razorpayKeyId: FieldRef<"PaymentConfig", 'String'>
    readonly razorpayKeySecret: FieldRef<"PaymentConfig", 'String'>
    readonly stripePublishableKey: FieldRef<"PaymentConfig", 'String'>
    readonly stripeSecretKey: FieldRef<"PaymentConfig", 'String'>
    readonly activeGateway: FieldRef<"PaymentConfig", 'Gateway'>
    readonly currency: FieldRef<"PaymentConfig", 'String'>
    readonly createdAt: FieldRef<"PaymentConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentConfig findUnique
   */
  export type PaymentConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConfig
     */
    select?: PaymentConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConfig
     */
    omit?: PaymentConfigOmit<ExtArgs> | null
    /**
     * Filter, which PaymentConfig to fetch.
     */
    where: PaymentConfigWhereUniqueInput
  }

  /**
   * PaymentConfig findUniqueOrThrow
   */
  export type PaymentConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConfig
     */
    select?: PaymentConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConfig
     */
    omit?: PaymentConfigOmit<ExtArgs> | null
    /**
     * Filter, which PaymentConfig to fetch.
     */
    where: PaymentConfigWhereUniqueInput
  }

  /**
   * PaymentConfig findFirst
   */
  export type PaymentConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConfig
     */
    select?: PaymentConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConfig
     */
    omit?: PaymentConfigOmit<ExtArgs> | null
    /**
     * Filter, which PaymentConfig to fetch.
     */
    where?: PaymentConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentConfigs to fetch.
     */
    orderBy?: PaymentConfigOrderByWithRelationInput | PaymentConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentConfigs.
     */
    cursor?: PaymentConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentConfigs.
     */
    distinct?: PaymentConfigScalarFieldEnum | PaymentConfigScalarFieldEnum[]
  }

  /**
   * PaymentConfig findFirstOrThrow
   */
  export type PaymentConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConfig
     */
    select?: PaymentConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConfig
     */
    omit?: PaymentConfigOmit<ExtArgs> | null
    /**
     * Filter, which PaymentConfig to fetch.
     */
    where?: PaymentConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentConfigs to fetch.
     */
    orderBy?: PaymentConfigOrderByWithRelationInput | PaymentConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentConfigs.
     */
    cursor?: PaymentConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentConfigs.
     */
    distinct?: PaymentConfigScalarFieldEnum | PaymentConfigScalarFieldEnum[]
  }

  /**
   * PaymentConfig findMany
   */
  export type PaymentConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConfig
     */
    select?: PaymentConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConfig
     */
    omit?: PaymentConfigOmit<ExtArgs> | null
    /**
     * Filter, which PaymentConfigs to fetch.
     */
    where?: PaymentConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentConfigs to fetch.
     */
    orderBy?: PaymentConfigOrderByWithRelationInput | PaymentConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentConfigs.
     */
    cursor?: PaymentConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentConfigs.
     */
    skip?: number
    distinct?: PaymentConfigScalarFieldEnum | PaymentConfigScalarFieldEnum[]
  }

  /**
   * PaymentConfig create
   */
  export type PaymentConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConfig
     */
    select?: PaymentConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConfig
     */
    omit?: PaymentConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a PaymentConfig.
     */
    data: XOR<PaymentConfigCreateInput, PaymentConfigUncheckedCreateInput>
  }

  /**
   * PaymentConfig createMany
   */
  export type PaymentConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentConfigs.
     */
    data: PaymentConfigCreateManyInput | PaymentConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentConfig createManyAndReturn
   */
  export type PaymentConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConfig
     */
    select?: PaymentConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConfig
     */
    omit?: PaymentConfigOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentConfigs.
     */
    data: PaymentConfigCreateManyInput | PaymentConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentConfig update
   */
  export type PaymentConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConfig
     */
    select?: PaymentConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConfig
     */
    omit?: PaymentConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a PaymentConfig.
     */
    data: XOR<PaymentConfigUpdateInput, PaymentConfigUncheckedUpdateInput>
    /**
     * Choose, which PaymentConfig to update.
     */
    where: PaymentConfigWhereUniqueInput
  }

  /**
   * PaymentConfig updateMany
   */
  export type PaymentConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentConfigs.
     */
    data: XOR<PaymentConfigUpdateManyMutationInput, PaymentConfigUncheckedUpdateManyInput>
    /**
     * Filter which PaymentConfigs to update
     */
    where?: PaymentConfigWhereInput
    /**
     * Limit how many PaymentConfigs to update.
     */
    limit?: number
  }

  /**
   * PaymentConfig updateManyAndReturn
   */
  export type PaymentConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConfig
     */
    select?: PaymentConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConfig
     */
    omit?: PaymentConfigOmit<ExtArgs> | null
    /**
     * The data used to update PaymentConfigs.
     */
    data: XOR<PaymentConfigUpdateManyMutationInput, PaymentConfigUncheckedUpdateManyInput>
    /**
     * Filter which PaymentConfigs to update
     */
    where?: PaymentConfigWhereInput
    /**
     * Limit how many PaymentConfigs to update.
     */
    limit?: number
  }

  /**
   * PaymentConfig upsert
   */
  export type PaymentConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConfig
     */
    select?: PaymentConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConfig
     */
    omit?: PaymentConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the PaymentConfig to update in case it exists.
     */
    where: PaymentConfigWhereUniqueInput
    /**
     * In case the PaymentConfig found by the `where` argument doesn't exist, create a new PaymentConfig with this data.
     */
    create: XOR<PaymentConfigCreateInput, PaymentConfigUncheckedCreateInput>
    /**
     * In case the PaymentConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentConfigUpdateInput, PaymentConfigUncheckedUpdateInput>
  }

  /**
   * PaymentConfig delete
   */
  export type PaymentConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConfig
     */
    select?: PaymentConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConfig
     */
    omit?: PaymentConfigOmit<ExtArgs> | null
    /**
     * Filter which PaymentConfig to delete.
     */
    where: PaymentConfigWhereUniqueInput
  }

  /**
   * PaymentConfig deleteMany
   */
  export type PaymentConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentConfigs to delete
     */
    where?: PaymentConfigWhereInput
    /**
     * Limit how many PaymentConfigs to delete.
     */
    limit?: number
  }

  /**
   * PaymentConfig without action
   */
  export type PaymentConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentConfig
     */
    select?: PaymentConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentConfig
     */
    omit?: PaymentConfigOmit<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    amount: number | null
  }

  export type ExpenseSumAggregateOutputType = {
    amount: number | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: string | null
    title: string | null
    amount: number | null
    category: string | null
    description: string | null
    date: Date | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: string | null
    title: string | null
    amount: number | null
    category: string | null
    description: string | null
    date: Date | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    title: number
    amount: number
    category: number
    description: number
    date: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    amount?: true
  }

  export type ExpenseSumAggregateInputType = {
    amount?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    title?: true
    amount?: true
    category?: true
    description?: true
    date?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    title?: true
    amount?: true
    category?: true
    description?: true
    date?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    title?: true
    amount?: true
    category?: true
    description?: true
    date?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: string
    title: string
    amount: number
    category: string
    description: string | null
    date: Date
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    amount?: boolean
    category?: boolean
    description?: boolean
    date?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    amount?: boolean
    category?: boolean
    description?: boolean
    date?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    amount?: boolean
    category?: boolean
    description?: boolean
    date?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    id?: boolean
    title?: boolean
    amount?: boolean
    category?: boolean
    description?: boolean
    date?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "amount" | "category" | "description" | "date" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["expense"]>

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      amount: number
      category: string
      description: string | null
      date: Date
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses and returns the data updated in the database.
     * @param {ExpenseUpdateManyAndReturnArgs} args - Arguments to update many Expenses.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'String'>
    readonly title: FieldRef<"Expense", 'String'>
    readonly amount: FieldRef<"Expense", 'Float'>
    readonly category: FieldRef<"Expense", 'String'>
    readonly description: FieldRef<"Expense", 'String'>
    readonly date: FieldRef<"Expense", 'DateTime'>
    readonly createdBy: FieldRef<"Expense", 'String'>
    readonly createdAt: FieldRef<"Expense", 'DateTime'>
    readonly updatedAt: FieldRef<"Expense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense createManyAndReturn
   */
  export type ExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
  }

  /**
   * Expense updateManyAndReturn
   */
  export type ExpenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to delete.
     */
    limit?: number
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
  }


  /**
   * Model SystemSettings
   */

  export type AggregateSystemSettings = {
    _count: SystemSettingsCountAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  export type SystemSettingsMinAggregateOutputType = {
    id: string | null
    platformName: string | null
    supportEmail: string | null
    logoUrl: string | null
    faviconUrl: string | null
    primaryColor: string | null
    isMaintenanceMode: boolean | null
    address: string | null
    phone: string | null
    updatedAt: Date | null
  }

  export type SystemSettingsMaxAggregateOutputType = {
    id: string | null
    platformName: string | null
    supportEmail: string | null
    logoUrl: string | null
    faviconUrl: string | null
    primaryColor: string | null
    isMaintenanceMode: boolean | null
    address: string | null
    phone: string | null
    updatedAt: Date | null
  }

  export type SystemSettingsCountAggregateOutputType = {
    id: number
    platformName: number
    supportEmail: number
    logoUrl: number
    faviconUrl: number
    primaryColor: number
    isMaintenanceMode: number
    address: number
    phone: number
    updatedAt: number
    _all: number
  }


  export type SystemSettingsMinAggregateInputType = {
    id?: true
    platformName?: true
    supportEmail?: true
    logoUrl?: true
    faviconUrl?: true
    primaryColor?: true
    isMaintenanceMode?: true
    address?: true
    phone?: true
    updatedAt?: true
  }

  export type SystemSettingsMaxAggregateInputType = {
    id?: true
    platformName?: true
    supportEmail?: true
    logoUrl?: true
    faviconUrl?: true
    primaryColor?: true
    isMaintenanceMode?: true
    address?: true
    phone?: true
    updatedAt?: true
  }

  export type SystemSettingsCountAggregateInputType = {
    id?: true
    platformName?: true
    supportEmail?: true
    logoUrl?: true
    faviconUrl?: true
    primaryColor?: true
    isMaintenanceMode?: true
    address?: true
    phone?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to aggregate.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type GetSystemSettingsAggregateType<T extends SystemSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSettings[P]>
      : GetScalarType<T[P], AggregateSystemSettings[P]>
  }




  export type SystemSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingsWhereInput
    orderBy?: SystemSettingsOrderByWithAggregationInput | SystemSettingsOrderByWithAggregationInput[]
    by: SystemSettingsScalarFieldEnum[] | SystemSettingsScalarFieldEnum
    having?: SystemSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingsCountAggregateInputType | true
    _min?: SystemSettingsMinAggregateInputType
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type SystemSettingsGroupByOutputType = {
    id: string
    platformName: string
    supportEmail: string
    logoUrl: string | null
    faviconUrl: string | null
    primaryColor: string
    isMaintenanceMode: boolean
    address: string | null
    phone: string | null
    updatedAt: Date
    _count: SystemSettingsCountAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  type GetSystemSettingsGroupByPayload<T extends SystemSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platformName?: boolean
    supportEmail?: boolean
    logoUrl?: boolean
    faviconUrl?: boolean
    primaryColor?: boolean
    isMaintenanceMode?: boolean
    address?: boolean
    phone?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platformName?: boolean
    supportEmail?: boolean
    logoUrl?: boolean
    faviconUrl?: boolean
    primaryColor?: boolean
    isMaintenanceMode?: boolean
    address?: boolean
    phone?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platformName?: boolean
    supportEmail?: boolean
    logoUrl?: boolean
    faviconUrl?: boolean
    primaryColor?: boolean
    isMaintenanceMode?: boolean
    address?: boolean
    phone?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectScalar = {
    id?: boolean
    platformName?: boolean
    supportEmail?: boolean
    logoUrl?: boolean
    faviconUrl?: boolean
    primaryColor?: boolean
    isMaintenanceMode?: boolean
    address?: boolean
    phone?: boolean
    updatedAt?: boolean
  }

  export type SystemSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "platformName" | "supportEmail" | "logoUrl" | "faviconUrl" | "primaryColor" | "isMaintenanceMode" | "address" | "phone" | "updatedAt", ExtArgs["result"]["systemSettings"]>

  export type $SystemSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      platformName: string
      supportEmail: string
      logoUrl: string | null
      faviconUrl: string | null
      primaryColor: string
      isMaintenanceMode: boolean
      address: string | null
      phone: string | null
      updatedAt: Date
    }, ExtArgs["result"]["systemSettings"]>
    composites: {}
  }

  type SystemSettingsGetPayload<S extends boolean | null | undefined | SystemSettingsDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingsPayload, S>

  type SystemSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingsCountAggregateInputType | true
    }

  export interface SystemSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSettings'], meta: { name: 'SystemSettings' } }
    /**
     * Find zero or one SystemSettings that matches the filter.
     * @param {SystemSettingsFindUniqueArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingsFindUniqueArgs>(args: SelectSubset<T, SystemSettingsFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingsFindUniqueOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingsFindFirstArgs>(args?: SelectSubset<T, SystemSettingsFindFirstArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingsFindManyArgs>(args?: SelectSubset<T, SystemSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSettings.
     * @param {SystemSettingsCreateArgs} args - Arguments to create a SystemSettings.
     * @example
     * // Create one SystemSettings
     * const SystemSettings = await prisma.systemSettings.create({
     *   data: {
     *     // ... data to create a SystemSettings
     *   }
     * })
     * 
     */
    create<T extends SystemSettingsCreateArgs>(args: SelectSubset<T, SystemSettingsCreateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingsCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingsCreateManyArgs>(args?: SelectSubset<T, SystemSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingsCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemSettings and only return the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemSettings.
     * @param {SystemSettingsDeleteArgs} args - Arguments to delete one SystemSettings.
     * @example
     * // Delete one SystemSettings
     * const SystemSettings = await prisma.systemSettings.delete({
     *   where: {
     *     // ... filter to delete one SystemSettings
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingsDeleteArgs>(args: SelectSubset<T, SystemSettingsDeleteArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSettings.
     * @param {SystemSettingsUpdateArgs} args - Arguments to update one SystemSettings.
     * @example
     * // Update one SystemSettings
     * const systemSettings = await prisma.systemSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingsUpdateArgs>(args: SelectSubset<T, SystemSettingsUpdateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingsDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingsDeleteManyArgs>(args?: SelectSubset<T, SystemSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSettings = await prisma.systemSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingsUpdateManyArgs>(args: SelectSubset<T, SystemSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings and returns the data updated in the database.
     * @param {SystemSettingsUpdateManyAndReturnArgs} args - Arguments to update many SystemSettings.
     * @example
     * // Update many SystemSettings
     * const systemSettings = await prisma.systemSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemSettings and only return the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemSettings.
     * @param {SystemSettingsUpsertArgs} args - Arguments to update or create a SystemSettings.
     * @example
     * // Update or create a SystemSettings
     * const systemSettings = await prisma.systemSettings.upsert({
     *   create: {
     *     // ... data to create a SystemSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSettings we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingsUpsertArgs>(args: SelectSubset<T, SystemSettingsUpsertArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSettings.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingsCountArgs>(
      args?: Subset<T, SystemSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingsAggregateArgs>(args: Subset<T, SystemSettingsAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingsAggregateType<T>>

    /**
     * Group by SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingsGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSettings model
   */
  readonly fields: SystemSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSettings model
   */
  interface SystemSettingsFieldRefs {
    readonly id: FieldRef<"SystemSettings", 'String'>
    readonly platformName: FieldRef<"SystemSettings", 'String'>
    readonly supportEmail: FieldRef<"SystemSettings", 'String'>
    readonly logoUrl: FieldRef<"SystemSettings", 'String'>
    readonly faviconUrl: FieldRef<"SystemSettings", 'String'>
    readonly primaryColor: FieldRef<"SystemSettings", 'String'>
    readonly isMaintenanceMode: FieldRef<"SystemSettings", 'Boolean'>
    readonly address: FieldRef<"SystemSettings", 'String'>
    readonly phone: FieldRef<"SystemSettings", 'String'>
    readonly updatedAt: FieldRef<"SystemSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSettings findUnique
   */
  export type SystemSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findUniqueOrThrow
   */
  export type SystemSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findFirst
   */
  export type SystemSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findFirstOrThrow
   */
  export type SystemSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findMany
   */
  export type SystemSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings create
   */
  export type SystemSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemSettings.
     */
    data: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
  }

  /**
   * SystemSettings createMany
   */
  export type SystemSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSettings createManyAndReturn
   */
  export type SystemSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSettings update
   */
  export type SystemSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemSettings.
     */
    data: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
    /**
     * Choose, which SystemSettings to update.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings updateMany
   */
  export type SystemSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingsUpdateManyMutationInput, SystemSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSettings updateManyAndReturn
   */
  export type SystemSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingsUpdateManyMutationInput, SystemSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSettings upsert
   */
  export type SystemSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemSettings to update in case it exists.
     */
    where: SystemSettingsWhereUniqueInput
    /**
     * In case the SystemSettings found by the `where` argument doesn't exist, create a new SystemSettings with this data.
     */
    create: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
    /**
     * In case the SystemSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
  }

  /**
   * SystemSettings delete
   */
  export type SystemSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter which SystemSettings to delete.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings deleteMany
   */
  export type SystemSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSettings without action
   */
  export type SystemSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
  }


  /**
   * Model EmployerProfile
   */

  export type AggregateEmployerProfile = {
    _count: EmployerProfileCountAggregateOutputType | null
    _min: EmployerProfileMinAggregateOutputType | null
    _max: EmployerProfileMaxAggregateOutputType | null
  }

  export type EmployerProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyName: string | null
    website: string | null
    description: string | null
    logo: string | null
    location: string | null
    industry: string | null
    companySize: string | null
    status: $Enums.EmployerStatus | null
    documentsVerified: boolean | null
    verificationNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployerProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyName: string | null
    website: string | null
    description: string | null
    logo: string | null
    location: string | null
    industry: string | null
    companySize: string | null
    status: $Enums.EmployerStatus | null
    documentsVerified: boolean | null
    verificationNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployerProfileCountAggregateOutputType = {
    id: number
    userId: number
    companyName: number
    website: number
    description: number
    logo: number
    location: number
    industry: number
    companySize: number
    status: number
    documentsVerified: number
    verificationNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployerProfileMinAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    website?: true
    description?: true
    logo?: true
    location?: true
    industry?: true
    companySize?: true
    status?: true
    documentsVerified?: true
    verificationNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployerProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    website?: true
    description?: true
    logo?: true
    location?: true
    industry?: true
    companySize?: true
    status?: true
    documentsVerified?: true
    verificationNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployerProfileCountAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    website?: true
    description?: true
    logo?: true
    location?: true
    industry?: true
    companySize?: true
    status?: true
    documentsVerified?: true
    verificationNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployerProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployerProfile to aggregate.
     */
    where?: EmployerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployerProfiles to fetch.
     */
    orderBy?: EmployerProfileOrderByWithRelationInput | EmployerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployerProfiles
    **/
    _count?: true | EmployerProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployerProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployerProfileMaxAggregateInputType
  }

  export type GetEmployerProfileAggregateType<T extends EmployerProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployerProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployerProfile[P]>
      : GetScalarType<T[P], AggregateEmployerProfile[P]>
  }




  export type EmployerProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployerProfileWhereInput
    orderBy?: EmployerProfileOrderByWithAggregationInput | EmployerProfileOrderByWithAggregationInput[]
    by: EmployerProfileScalarFieldEnum[] | EmployerProfileScalarFieldEnum
    having?: EmployerProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployerProfileCountAggregateInputType | true
    _min?: EmployerProfileMinAggregateInputType
    _max?: EmployerProfileMaxAggregateInputType
  }

  export type EmployerProfileGroupByOutputType = {
    id: string
    userId: string
    companyName: string
    website: string | null
    description: string | null
    logo: string | null
    location: string | null
    industry: string | null
    companySize: string | null
    status: $Enums.EmployerStatus
    documentsVerified: boolean
    verificationNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmployerProfileCountAggregateOutputType | null
    _min: EmployerProfileMinAggregateOutputType | null
    _max: EmployerProfileMaxAggregateOutputType | null
  }

  type GetEmployerProfileGroupByPayload<T extends EmployerProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployerProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployerProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployerProfileGroupByOutputType[P]>
            : GetScalarType<T[P], EmployerProfileGroupByOutputType[P]>
        }
      >
    >


  export type EmployerProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    website?: boolean
    description?: boolean
    logo?: boolean
    location?: boolean
    industry?: boolean
    companySize?: boolean
    status?: boolean
    documentsVerified?: boolean
    verificationNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employerProfile"]>

  export type EmployerProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    website?: boolean
    description?: boolean
    logo?: boolean
    location?: boolean
    industry?: boolean
    companySize?: boolean
    status?: boolean
    documentsVerified?: boolean
    verificationNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employerProfile"]>

  export type EmployerProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    website?: boolean
    description?: boolean
    logo?: boolean
    location?: boolean
    industry?: boolean
    companySize?: boolean
    status?: boolean
    documentsVerified?: boolean
    verificationNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employerProfile"]>

  export type EmployerProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    companyName?: boolean
    website?: boolean
    description?: boolean
    logo?: boolean
    location?: boolean
    industry?: boolean
    companySize?: boolean
    status?: boolean
    documentsVerified?: boolean
    verificationNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployerProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "companyName" | "website" | "description" | "logo" | "location" | "industry" | "companySize" | "status" | "documentsVerified" | "verificationNotes" | "createdAt" | "updatedAt", ExtArgs["result"]["employerProfile"]>
  export type EmployerProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmployerProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmployerProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmployerProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployerProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyName: string
      website: string | null
      description: string | null
      logo: string | null
      location: string | null
      industry: string | null
      companySize: string | null
      status: $Enums.EmployerStatus
      documentsVerified: boolean
      verificationNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employerProfile"]>
    composites: {}
  }

  type EmployerProfileGetPayload<S extends boolean | null | undefined | EmployerProfileDefaultArgs> = $Result.GetResult<Prisma.$EmployerProfilePayload, S>

  type EmployerProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployerProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployerProfileCountAggregateInputType | true
    }

  export interface EmployerProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployerProfile'], meta: { name: 'EmployerProfile' } }
    /**
     * Find zero or one EmployerProfile that matches the filter.
     * @param {EmployerProfileFindUniqueArgs} args - Arguments to find a EmployerProfile
     * @example
     * // Get one EmployerProfile
     * const employerProfile = await prisma.employerProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployerProfileFindUniqueArgs>(args: SelectSubset<T, EmployerProfileFindUniqueArgs<ExtArgs>>): Prisma__EmployerProfileClient<$Result.GetResult<Prisma.$EmployerProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployerProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployerProfileFindUniqueOrThrowArgs} args - Arguments to find a EmployerProfile
     * @example
     * // Get one EmployerProfile
     * const employerProfile = await prisma.employerProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployerProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployerProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployerProfileClient<$Result.GetResult<Prisma.$EmployerProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployerProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployerProfileFindFirstArgs} args - Arguments to find a EmployerProfile
     * @example
     * // Get one EmployerProfile
     * const employerProfile = await prisma.employerProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployerProfileFindFirstArgs>(args?: SelectSubset<T, EmployerProfileFindFirstArgs<ExtArgs>>): Prisma__EmployerProfileClient<$Result.GetResult<Prisma.$EmployerProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployerProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployerProfileFindFirstOrThrowArgs} args - Arguments to find a EmployerProfile
     * @example
     * // Get one EmployerProfile
     * const employerProfile = await prisma.employerProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployerProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployerProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployerProfileClient<$Result.GetResult<Prisma.$EmployerProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployerProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployerProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployerProfiles
     * const employerProfiles = await prisma.employerProfile.findMany()
     * 
     * // Get first 10 EmployerProfiles
     * const employerProfiles = await prisma.employerProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employerProfileWithIdOnly = await prisma.employerProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployerProfileFindManyArgs>(args?: SelectSubset<T, EmployerProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployerProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployerProfile.
     * @param {EmployerProfileCreateArgs} args - Arguments to create a EmployerProfile.
     * @example
     * // Create one EmployerProfile
     * const EmployerProfile = await prisma.employerProfile.create({
     *   data: {
     *     // ... data to create a EmployerProfile
     *   }
     * })
     * 
     */
    create<T extends EmployerProfileCreateArgs>(args: SelectSubset<T, EmployerProfileCreateArgs<ExtArgs>>): Prisma__EmployerProfileClient<$Result.GetResult<Prisma.$EmployerProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployerProfiles.
     * @param {EmployerProfileCreateManyArgs} args - Arguments to create many EmployerProfiles.
     * @example
     * // Create many EmployerProfiles
     * const employerProfile = await prisma.employerProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployerProfileCreateManyArgs>(args?: SelectSubset<T, EmployerProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployerProfiles and returns the data saved in the database.
     * @param {EmployerProfileCreateManyAndReturnArgs} args - Arguments to create many EmployerProfiles.
     * @example
     * // Create many EmployerProfiles
     * const employerProfile = await prisma.employerProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployerProfiles and only return the `id`
     * const employerProfileWithIdOnly = await prisma.employerProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployerProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployerProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployerProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmployerProfile.
     * @param {EmployerProfileDeleteArgs} args - Arguments to delete one EmployerProfile.
     * @example
     * // Delete one EmployerProfile
     * const EmployerProfile = await prisma.employerProfile.delete({
     *   where: {
     *     // ... filter to delete one EmployerProfile
     *   }
     * })
     * 
     */
    delete<T extends EmployerProfileDeleteArgs>(args: SelectSubset<T, EmployerProfileDeleteArgs<ExtArgs>>): Prisma__EmployerProfileClient<$Result.GetResult<Prisma.$EmployerProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployerProfile.
     * @param {EmployerProfileUpdateArgs} args - Arguments to update one EmployerProfile.
     * @example
     * // Update one EmployerProfile
     * const employerProfile = await prisma.employerProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployerProfileUpdateArgs>(args: SelectSubset<T, EmployerProfileUpdateArgs<ExtArgs>>): Prisma__EmployerProfileClient<$Result.GetResult<Prisma.$EmployerProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployerProfiles.
     * @param {EmployerProfileDeleteManyArgs} args - Arguments to filter EmployerProfiles to delete.
     * @example
     * // Delete a few EmployerProfiles
     * const { count } = await prisma.employerProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployerProfileDeleteManyArgs>(args?: SelectSubset<T, EmployerProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployerProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployerProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployerProfiles
     * const employerProfile = await prisma.employerProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployerProfileUpdateManyArgs>(args: SelectSubset<T, EmployerProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployerProfiles and returns the data updated in the database.
     * @param {EmployerProfileUpdateManyAndReturnArgs} args - Arguments to update many EmployerProfiles.
     * @example
     * // Update many EmployerProfiles
     * const employerProfile = await prisma.employerProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmployerProfiles and only return the `id`
     * const employerProfileWithIdOnly = await prisma.employerProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployerProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployerProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployerProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmployerProfile.
     * @param {EmployerProfileUpsertArgs} args - Arguments to update or create a EmployerProfile.
     * @example
     * // Update or create a EmployerProfile
     * const employerProfile = await prisma.employerProfile.upsert({
     *   create: {
     *     // ... data to create a EmployerProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployerProfile we want to update
     *   }
     * })
     */
    upsert<T extends EmployerProfileUpsertArgs>(args: SelectSubset<T, EmployerProfileUpsertArgs<ExtArgs>>): Prisma__EmployerProfileClient<$Result.GetResult<Prisma.$EmployerProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployerProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployerProfileCountArgs} args - Arguments to filter EmployerProfiles to count.
     * @example
     * // Count the number of EmployerProfiles
     * const count = await prisma.employerProfile.count({
     *   where: {
     *     // ... the filter for the EmployerProfiles we want to count
     *   }
     * })
    **/
    count<T extends EmployerProfileCountArgs>(
      args?: Subset<T, EmployerProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployerProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployerProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployerProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployerProfileAggregateArgs>(args: Subset<T, EmployerProfileAggregateArgs>): Prisma.PrismaPromise<GetEmployerProfileAggregateType<T>>

    /**
     * Group by EmployerProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployerProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployerProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployerProfileGroupByArgs['orderBy'] }
        : { orderBy?: EmployerProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployerProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployerProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployerProfile model
   */
  readonly fields: EmployerProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployerProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployerProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployerProfile model
   */
  interface EmployerProfileFieldRefs {
    readonly id: FieldRef<"EmployerProfile", 'String'>
    readonly userId: FieldRef<"EmployerProfile", 'String'>
    readonly companyName: FieldRef<"EmployerProfile", 'String'>
    readonly website: FieldRef<"EmployerProfile", 'String'>
    readonly description: FieldRef<"EmployerProfile", 'String'>
    readonly logo: FieldRef<"EmployerProfile", 'String'>
    readonly location: FieldRef<"EmployerProfile", 'String'>
    readonly industry: FieldRef<"EmployerProfile", 'String'>
    readonly companySize: FieldRef<"EmployerProfile", 'String'>
    readonly status: FieldRef<"EmployerProfile", 'EmployerStatus'>
    readonly documentsVerified: FieldRef<"EmployerProfile", 'Boolean'>
    readonly verificationNotes: FieldRef<"EmployerProfile", 'String'>
    readonly createdAt: FieldRef<"EmployerProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployerProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployerProfile findUnique
   */
  export type EmployerProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployerProfile
     */
    select?: EmployerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployerProfile
     */
    omit?: EmployerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployerProfile to fetch.
     */
    where: EmployerProfileWhereUniqueInput
  }

  /**
   * EmployerProfile findUniqueOrThrow
   */
  export type EmployerProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployerProfile
     */
    select?: EmployerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployerProfile
     */
    omit?: EmployerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployerProfile to fetch.
     */
    where: EmployerProfileWhereUniqueInput
  }

  /**
   * EmployerProfile findFirst
   */
  export type EmployerProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployerProfile
     */
    select?: EmployerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployerProfile
     */
    omit?: EmployerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployerProfile to fetch.
     */
    where?: EmployerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployerProfiles to fetch.
     */
    orderBy?: EmployerProfileOrderByWithRelationInput | EmployerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployerProfiles.
     */
    cursor?: EmployerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployerProfiles.
     */
    distinct?: EmployerProfileScalarFieldEnum | EmployerProfileScalarFieldEnum[]
  }

  /**
   * EmployerProfile findFirstOrThrow
   */
  export type EmployerProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployerProfile
     */
    select?: EmployerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployerProfile
     */
    omit?: EmployerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployerProfile to fetch.
     */
    where?: EmployerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployerProfiles to fetch.
     */
    orderBy?: EmployerProfileOrderByWithRelationInput | EmployerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployerProfiles.
     */
    cursor?: EmployerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployerProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployerProfiles.
     */
    distinct?: EmployerProfileScalarFieldEnum | EmployerProfileScalarFieldEnum[]
  }

  /**
   * EmployerProfile findMany
   */
  export type EmployerProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployerProfile
     */
    select?: EmployerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployerProfile
     */
    omit?: EmployerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployerProfiles to fetch.
     */
    where?: EmployerProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployerProfiles to fetch.
     */
    orderBy?: EmployerProfileOrderByWithRelationInput | EmployerProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployerProfiles.
     */
    cursor?: EmployerProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployerProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployerProfiles.
     */
    skip?: number
    distinct?: EmployerProfileScalarFieldEnum | EmployerProfileScalarFieldEnum[]
  }

  /**
   * EmployerProfile create
   */
  export type EmployerProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployerProfile
     */
    select?: EmployerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployerProfile
     */
    omit?: EmployerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployerProfile.
     */
    data: XOR<EmployerProfileCreateInput, EmployerProfileUncheckedCreateInput>
  }

  /**
   * EmployerProfile createMany
   */
  export type EmployerProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployerProfiles.
     */
    data: EmployerProfileCreateManyInput | EmployerProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployerProfile createManyAndReturn
   */
  export type EmployerProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployerProfile
     */
    select?: EmployerProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployerProfile
     */
    omit?: EmployerProfileOmit<ExtArgs> | null
    /**
     * The data used to create many EmployerProfiles.
     */
    data: EmployerProfileCreateManyInput | EmployerProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployerProfile update
   */
  export type EmployerProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployerProfile
     */
    select?: EmployerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployerProfile
     */
    omit?: EmployerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployerProfile.
     */
    data: XOR<EmployerProfileUpdateInput, EmployerProfileUncheckedUpdateInput>
    /**
     * Choose, which EmployerProfile to update.
     */
    where: EmployerProfileWhereUniqueInput
  }

  /**
   * EmployerProfile updateMany
   */
  export type EmployerProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployerProfiles.
     */
    data: XOR<EmployerProfileUpdateManyMutationInput, EmployerProfileUncheckedUpdateManyInput>
    /**
     * Filter which EmployerProfiles to update
     */
    where?: EmployerProfileWhereInput
    /**
     * Limit how many EmployerProfiles to update.
     */
    limit?: number
  }

  /**
   * EmployerProfile updateManyAndReturn
   */
  export type EmployerProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployerProfile
     */
    select?: EmployerProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployerProfile
     */
    omit?: EmployerProfileOmit<ExtArgs> | null
    /**
     * The data used to update EmployerProfiles.
     */
    data: XOR<EmployerProfileUpdateManyMutationInput, EmployerProfileUncheckedUpdateManyInput>
    /**
     * Filter which EmployerProfiles to update
     */
    where?: EmployerProfileWhereInput
    /**
     * Limit how many EmployerProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployerProfile upsert
   */
  export type EmployerProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployerProfile
     */
    select?: EmployerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployerProfile
     */
    omit?: EmployerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployerProfile to update in case it exists.
     */
    where: EmployerProfileWhereUniqueInput
    /**
     * In case the EmployerProfile found by the `where` argument doesn't exist, create a new EmployerProfile with this data.
     */
    create: XOR<EmployerProfileCreateInput, EmployerProfileUncheckedCreateInput>
    /**
     * In case the EmployerProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployerProfileUpdateInput, EmployerProfileUncheckedUpdateInput>
  }

  /**
   * EmployerProfile delete
   */
  export type EmployerProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployerProfile
     */
    select?: EmployerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployerProfile
     */
    omit?: EmployerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerProfileInclude<ExtArgs> | null
    /**
     * Filter which EmployerProfile to delete.
     */
    where: EmployerProfileWhereUniqueInput
  }

  /**
   * EmployerProfile deleteMany
   */
  export type EmployerProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployerProfiles to delete
     */
    where?: EmployerProfileWhereInput
    /**
     * Limit how many EmployerProfiles to delete.
     */
    limit?: number
  }

  /**
   * EmployerProfile without action
   */
  export type EmployerProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployerProfile
     */
    select?: EmployerProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployerProfile
     */
    omit?: EmployerProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployerProfileInclude<ExtArgs> | null
  }


  /**
   * Model Job
   */

  export type AggregateJob = {
    _count: JobCountAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  export type JobMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    requirements: string | null
    location: string | null
    type: $Enums.JobType | null
    experience: string | null
    salary: string | null
    skills: string | null
    clientName: string | null
    shift: string | null
    domain: string | null
    qualification: string | null
    employerId: string | null
    status: $Enums.JobStatus | null
    publishedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    requirements: string | null
    location: string | null
    type: $Enums.JobType | null
    experience: string | null
    salary: string | null
    skills: string | null
    clientName: string | null
    shift: string | null
    domain: string | null
    qualification: string | null
    employerId: string | null
    status: $Enums.JobStatus | null
    publishedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobCountAggregateOutputType = {
    id: number
    title: number
    description: number
    requirements: number
    location: number
    type: number
    experience: number
    salary: number
    skills: number
    clientName: number
    shift: number
    domain: number
    qualification: number
    employerId: number
    status: number
    publishedAt: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JobMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    requirements?: true
    location?: true
    type?: true
    experience?: true
    salary?: true
    skills?: true
    clientName?: true
    shift?: true
    domain?: true
    qualification?: true
    employerId?: true
    status?: true
    publishedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    requirements?: true
    location?: true
    type?: true
    experience?: true
    salary?: true
    skills?: true
    clientName?: true
    shift?: true
    domain?: true
    qualification?: true
    employerId?: true
    status?: true
    publishedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    requirements?: true
    location?: true
    type?: true
    experience?: true
    salary?: true
    skills?: true
    clientName?: true
    shift?: true
    domain?: true
    qualification?: true
    employerId?: true
    status?: true
    publishedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Job to aggregate.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobs
    **/
    _count?: true | JobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobMaxAggregateInputType
  }

  export type GetJobAggregateType<T extends JobAggregateArgs> = {
        [P in keyof T & keyof AggregateJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob[P]>
      : GetScalarType<T[P], AggregateJob[P]>
  }




  export type JobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
    orderBy?: JobOrderByWithAggregationInput | JobOrderByWithAggregationInput[]
    by: JobScalarFieldEnum[] | JobScalarFieldEnum
    having?: JobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobCountAggregateInputType | true
    _min?: JobMinAggregateInputType
    _max?: JobMaxAggregateInputType
  }

  export type JobGroupByOutputType = {
    id: string
    title: string
    description: string
    requirements: string | null
    location: string
    type: $Enums.JobType
    experience: string | null
    salary: string | null
    skills: string | null
    clientName: string | null
    shift: string | null
    domain: string | null
    qualification: string | null
    employerId: string
    status: $Enums.JobStatus
    publishedAt: Date | null
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: JobCountAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  type GetJobGroupByPayload<T extends JobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobGroupByOutputType[P]>
            : GetScalarType<T[P], JobGroupByOutputType[P]>
        }
      >
    >


  export type JobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    requirements?: boolean
    location?: boolean
    type?: boolean
    experience?: boolean
    salary?: boolean
    skills?: boolean
    clientName?: boolean
    shift?: boolean
    domain?: boolean
    qualification?: boolean
    employerId?: boolean
    status?: boolean
    publishedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employer?: boolean | UserDefaultArgs<ExtArgs>
    applications?: boolean | Job$applicationsArgs<ExtArgs>
    _count?: boolean | JobCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    requirements?: boolean
    location?: boolean
    type?: boolean
    experience?: boolean
    salary?: boolean
    skills?: boolean
    clientName?: boolean
    shift?: boolean
    domain?: boolean
    qualification?: boolean
    employerId?: boolean
    status?: boolean
    publishedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    requirements?: boolean
    location?: boolean
    type?: boolean
    experience?: boolean
    salary?: boolean
    skills?: boolean
    clientName?: boolean
    shift?: boolean
    domain?: boolean
    qualification?: boolean
    employerId?: boolean
    status?: boolean
    publishedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    requirements?: boolean
    location?: boolean
    type?: boolean
    experience?: boolean
    salary?: boolean
    skills?: boolean
    clientName?: boolean
    shift?: boolean
    domain?: boolean
    qualification?: boolean
    employerId?: boolean
    status?: boolean
    publishedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "requirements" | "location" | "type" | "experience" | "salary" | "skills" | "clientName" | "shift" | "domain" | "qualification" | "employerId" | "status" | "publishedAt" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["job"]>
  export type JobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employer?: boolean | UserDefaultArgs<ExtArgs>
    applications?: boolean | Job$applicationsArgs<ExtArgs>
    _count?: boolean | JobCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type JobIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $JobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Job"
    objects: {
      employer: Prisma.$UserPayload<ExtArgs>
      applications: Prisma.$JobApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      requirements: string | null
      location: string
      type: $Enums.JobType
      experience: string | null
      salary: string | null
      skills: string | null
      clientName: string | null
      shift: string | null
      domain: string | null
      qualification: string | null
      employerId: string
      status: $Enums.JobStatus
      publishedAt: Date | null
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["job"]>
    composites: {}
  }

  type JobGetPayload<S extends boolean | null | undefined | JobDefaultArgs> = $Result.GetResult<Prisma.$JobPayload, S>

  type JobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobCountAggregateInputType | true
    }

  export interface JobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Job'], meta: { name: 'Job' } }
    /**
     * Find zero or one Job that matches the filter.
     * @param {JobFindUniqueArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobFindUniqueArgs>(args: SelectSubset<T, JobFindUniqueArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobFindUniqueOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobFindUniqueOrThrowArgs>(args: SelectSubset<T, JobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobFindFirstArgs>(args?: SelectSubset<T, JobFindFirstArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobFindFirstOrThrowArgs>(args?: SelectSubset<T, JobFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.job.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.job.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobWithIdOnly = await prisma.job.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobFindManyArgs>(args?: SelectSubset<T, JobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job.
     * @param {JobCreateArgs} args - Arguments to create a Job.
     * @example
     * // Create one Job
     * const Job = await prisma.job.create({
     *   data: {
     *     // ... data to create a Job
     *   }
     * })
     * 
     */
    create<T extends JobCreateArgs>(args: SelectSubset<T, JobCreateArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jobs.
     * @param {JobCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobCreateManyArgs>(args?: SelectSubset<T, JobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Jobs and returns the data saved in the database.
     * @param {JobCreateManyAndReturnArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Jobs and only return the `id`
     * const jobWithIdOnly = await prisma.job.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobCreateManyAndReturnArgs>(args?: SelectSubset<T, JobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job.
     * @param {JobDeleteArgs} args - Arguments to delete one Job.
     * @example
     * // Delete one Job
     * const Job = await prisma.job.delete({
     *   where: {
     *     // ... filter to delete one Job
     *   }
     * })
     * 
     */
    delete<T extends JobDeleteArgs>(args: SelectSubset<T, JobDeleteArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job.
     * @param {JobUpdateArgs} args - Arguments to update one Job.
     * @example
     * // Update one Job
     * const job = await prisma.job.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobUpdateArgs>(args: SelectSubset<T, JobUpdateArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jobs.
     * @param {JobDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.job.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobDeleteManyArgs>(args?: SelectSubset<T, JobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobUpdateManyArgs>(args: SelectSubset<T, JobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs and returns the data updated in the database.
     * @param {JobUpdateManyAndReturnArgs} args - Arguments to update many Jobs.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Jobs and only return the `id`
     * const jobWithIdOnly = await prisma.job.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobUpdateManyAndReturnArgs>(args: SelectSubset<T, JobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job.
     * @param {JobUpsertArgs} args - Arguments to update or create a Job.
     * @example
     * // Update or create a Job
     * const job = await prisma.job.upsert({
     *   create: {
     *     // ... data to create a Job
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job we want to update
     *   }
     * })
     */
    upsert<T extends JobUpsertArgs>(args: SelectSubset<T, JobUpsertArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.job.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends JobCountArgs>(
      args?: Subset<T, JobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobAggregateArgs>(args: Subset<T, JobAggregateArgs>): Prisma.PrismaPromise<GetJobAggregateType<T>>

    /**
     * Group by Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobGroupByArgs['orderBy'] }
        : { orderBy?: JobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Job model
   */
  readonly fields: JobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Job.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    applications<T extends Job$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, Job$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Job model
   */
  interface JobFieldRefs {
    readonly id: FieldRef<"Job", 'String'>
    readonly title: FieldRef<"Job", 'String'>
    readonly description: FieldRef<"Job", 'String'>
    readonly requirements: FieldRef<"Job", 'String'>
    readonly location: FieldRef<"Job", 'String'>
    readonly type: FieldRef<"Job", 'JobType'>
    readonly experience: FieldRef<"Job", 'String'>
    readonly salary: FieldRef<"Job", 'String'>
    readonly skills: FieldRef<"Job", 'String'>
    readonly clientName: FieldRef<"Job", 'String'>
    readonly shift: FieldRef<"Job", 'String'>
    readonly domain: FieldRef<"Job", 'String'>
    readonly qualification: FieldRef<"Job", 'String'>
    readonly employerId: FieldRef<"Job", 'String'>
    readonly status: FieldRef<"Job", 'JobStatus'>
    readonly publishedAt: FieldRef<"Job", 'DateTime'>
    readonly expiresAt: FieldRef<"Job", 'DateTime'>
    readonly createdAt: FieldRef<"Job", 'DateTime'>
    readonly updatedAt: FieldRef<"Job", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Job findUnique
   */
  export type JobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job findUniqueOrThrow
   */
  export type JobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job findFirst
   */
  export type JobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job findFirstOrThrow
   */
  export type JobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job findMany
   */
  export type JobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job create
   */
  export type JobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The data needed to create a Job.
     */
    data: XOR<JobCreateInput, JobUncheckedCreateInput>
  }

  /**
   * Job createMany
   */
  export type JobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Jobs.
     */
    data: JobCreateManyInput | JobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Job createManyAndReturn
   */
  export type JobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * The data used to create many Jobs.
     */
    data: JobCreateManyInput | JobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Job update
   */
  export type JobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The data needed to update a Job.
     */
    data: XOR<JobUpdateInput, JobUncheckedUpdateInput>
    /**
     * Choose, which Job to update.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job updateMany
   */
  export type JobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobWhereInput
    /**
     * Limit how many Jobs to update.
     */
    limit?: number
  }

  /**
   * Job updateManyAndReturn
   */
  export type JobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobWhereInput
    /**
     * Limit how many Jobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Job upsert
   */
  export type JobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The filter to search for the Job to update in case it exists.
     */
    where: JobWhereUniqueInput
    /**
     * In case the Job found by the `where` argument doesn't exist, create a new Job with this data.
     */
    create: XOR<JobCreateInput, JobUncheckedCreateInput>
    /**
     * In case the Job was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobUpdateInput, JobUncheckedUpdateInput>
  }

  /**
   * Job delete
   */
  export type JobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter which Job to delete.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job deleteMany
   */
  export type JobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to delete
     */
    where?: JobWhereInput
    /**
     * Limit how many Jobs to delete.
     */
    limit?: number
  }

  /**
   * Job.applications
   */
  export type Job$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    where?: JobApplicationWhereInput
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    cursor?: JobApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }

  /**
   * Job without action
   */
  export type JobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
  }


  /**
   * Model JobApplication
   */

  export type AggregateJobApplication = {
    _count: JobApplicationCountAggregateOutputType | null
    _avg: JobApplicationAvgAggregateOutputType | null
    _sum: JobApplicationSumAggregateOutputType | null
    _min: JobApplicationMinAggregateOutputType | null
    _max: JobApplicationMaxAggregateOutputType | null
  }

  export type JobApplicationAvgAggregateOutputType = {
    atsScore: number | null
  }

  export type JobApplicationSumAggregateOutputType = {
    atsScore: number | null
  }

  export type JobApplicationMinAggregateOutputType = {
    id: string | null
    jobId: string | null
    applicantId: string | null
    source: $Enums.CandidateSource | null
    externalName: string | null
    externalEmail: string | null
    externalPhone: string | null
    resumeUrl: string | null
    coverLetter: string | null
    resumeParsedText: string | null
    atsScore: number | null
    status: $Enums.ApplicationStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobApplicationMaxAggregateOutputType = {
    id: string | null
    jobId: string | null
    applicantId: string | null
    source: $Enums.CandidateSource | null
    externalName: string | null
    externalEmail: string | null
    externalPhone: string | null
    resumeUrl: string | null
    coverLetter: string | null
    resumeParsedText: string | null
    atsScore: number | null
    status: $Enums.ApplicationStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobApplicationCountAggregateOutputType = {
    id: number
    jobId: number
    applicantId: number
    source: number
    externalName: number
    externalEmail: number
    externalPhone: number
    resumeUrl: number
    coverLetter: number
    resumeParsedText: number
    atsScore: number
    status: number
    statusHistory: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JobApplicationAvgAggregateInputType = {
    atsScore?: true
  }

  export type JobApplicationSumAggregateInputType = {
    atsScore?: true
  }

  export type JobApplicationMinAggregateInputType = {
    id?: true
    jobId?: true
    applicantId?: true
    source?: true
    externalName?: true
    externalEmail?: true
    externalPhone?: true
    resumeUrl?: true
    coverLetter?: true
    resumeParsedText?: true
    atsScore?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobApplicationMaxAggregateInputType = {
    id?: true
    jobId?: true
    applicantId?: true
    source?: true
    externalName?: true
    externalEmail?: true
    externalPhone?: true
    resumeUrl?: true
    coverLetter?: true
    resumeParsedText?: true
    atsScore?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobApplicationCountAggregateInputType = {
    id?: true
    jobId?: true
    applicantId?: true
    source?: true
    externalName?: true
    externalEmail?: true
    externalPhone?: true
    resumeUrl?: true
    coverLetter?: true
    resumeParsedText?: true
    atsScore?: true
    status?: true
    statusHistory?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JobApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobApplication to aggregate.
     */
    where?: JobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplications to fetch.
     */
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobApplications
    **/
    _count?: true | JobApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobApplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobApplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobApplicationMaxAggregateInputType
  }

  export type GetJobApplicationAggregateType<T extends JobApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateJobApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobApplication[P]>
      : GetScalarType<T[P], AggregateJobApplication[P]>
  }




  export type JobApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobApplicationWhereInput
    orderBy?: JobApplicationOrderByWithAggregationInput | JobApplicationOrderByWithAggregationInput[]
    by: JobApplicationScalarFieldEnum[] | JobApplicationScalarFieldEnum
    having?: JobApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobApplicationCountAggregateInputType | true
    _avg?: JobApplicationAvgAggregateInputType
    _sum?: JobApplicationSumAggregateInputType
    _min?: JobApplicationMinAggregateInputType
    _max?: JobApplicationMaxAggregateInputType
  }

  export type JobApplicationGroupByOutputType = {
    id: string
    jobId: string
    applicantId: string | null
    source: $Enums.CandidateSource
    externalName: string | null
    externalEmail: string | null
    externalPhone: string | null
    resumeUrl: string | null
    coverLetter: string | null
    resumeParsedText: string | null
    atsScore: number
    status: $Enums.ApplicationStatus
    statusHistory: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: JobApplicationCountAggregateOutputType | null
    _avg: JobApplicationAvgAggregateOutputType | null
    _sum: JobApplicationSumAggregateOutputType | null
    _min: JobApplicationMinAggregateOutputType | null
    _max: JobApplicationMaxAggregateOutputType | null
  }

  type GetJobApplicationGroupByPayload<T extends JobApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], JobApplicationGroupByOutputType[P]>
        }
      >
    >


  export type JobApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    applicantId?: boolean
    source?: boolean
    externalName?: boolean
    externalEmail?: boolean
    externalPhone?: boolean
    resumeUrl?: boolean
    coverLetter?: boolean
    resumeParsedText?: boolean
    atsScore?: boolean
    status?: boolean
    statusHistory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
    applicant?: boolean | JobApplication$applicantArgs<ExtArgs>
    interviews?: boolean | JobApplication$interviewsArgs<ExtArgs>
    emailLogs?: boolean | JobApplication$emailLogsArgs<ExtArgs>
    auditLogs?: boolean | JobApplication$auditLogsArgs<ExtArgs>
    _count?: boolean | JobApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobApplication"]>

  export type JobApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    applicantId?: boolean
    source?: boolean
    externalName?: boolean
    externalEmail?: boolean
    externalPhone?: boolean
    resumeUrl?: boolean
    coverLetter?: boolean
    resumeParsedText?: boolean
    atsScore?: boolean
    status?: boolean
    statusHistory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
    applicant?: boolean | JobApplication$applicantArgs<ExtArgs>
  }, ExtArgs["result"]["jobApplication"]>

  export type JobApplicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    applicantId?: boolean
    source?: boolean
    externalName?: boolean
    externalEmail?: boolean
    externalPhone?: boolean
    resumeUrl?: boolean
    coverLetter?: boolean
    resumeParsedText?: boolean
    atsScore?: boolean
    status?: boolean
    statusHistory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
    applicant?: boolean | JobApplication$applicantArgs<ExtArgs>
  }, ExtArgs["result"]["jobApplication"]>

  export type JobApplicationSelectScalar = {
    id?: boolean
    jobId?: boolean
    applicantId?: boolean
    source?: boolean
    externalName?: boolean
    externalEmail?: boolean
    externalPhone?: boolean
    resumeUrl?: boolean
    coverLetter?: boolean
    resumeParsedText?: boolean
    atsScore?: boolean
    status?: boolean
    statusHistory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JobApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobId" | "applicantId" | "source" | "externalName" | "externalEmail" | "externalPhone" | "resumeUrl" | "coverLetter" | "resumeParsedText" | "atsScore" | "status" | "statusHistory" | "createdAt" | "updatedAt", ExtArgs["result"]["jobApplication"]>
  export type JobApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
    applicant?: boolean | JobApplication$applicantArgs<ExtArgs>
    interviews?: boolean | JobApplication$interviewsArgs<ExtArgs>
    emailLogs?: boolean | JobApplication$emailLogsArgs<ExtArgs>
    auditLogs?: boolean | JobApplication$auditLogsArgs<ExtArgs>
    _count?: boolean | JobApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JobApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
    applicant?: boolean | JobApplication$applicantArgs<ExtArgs>
  }
  export type JobApplicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
    applicant?: boolean | JobApplication$applicantArgs<ExtArgs>
  }

  export type $JobApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobApplication"
    objects: {
      job: Prisma.$JobPayload<ExtArgs>
      applicant: Prisma.$UserPayload<ExtArgs> | null
      interviews: Prisma.$JobInterviewPayload<ExtArgs>[]
      emailLogs: Prisma.$EmailLogPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobId: string
      applicantId: string | null
      source: $Enums.CandidateSource
      externalName: string | null
      externalEmail: string | null
      externalPhone: string | null
      resumeUrl: string | null
      coverLetter: string | null
      resumeParsedText: string | null
      atsScore: number
      status: $Enums.ApplicationStatus
      statusHistory: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["jobApplication"]>
    composites: {}
  }

  type JobApplicationGetPayload<S extends boolean | null | undefined | JobApplicationDefaultArgs> = $Result.GetResult<Prisma.$JobApplicationPayload, S>

  type JobApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobApplicationCountAggregateInputType | true
    }

  export interface JobApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobApplication'], meta: { name: 'JobApplication' } }
    /**
     * Find zero or one JobApplication that matches the filter.
     * @param {JobApplicationFindUniqueArgs} args - Arguments to find a JobApplication
     * @example
     * // Get one JobApplication
     * const jobApplication = await prisma.jobApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobApplicationFindUniqueArgs>(args: SelectSubset<T, JobApplicationFindUniqueArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobApplication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobApplicationFindUniqueOrThrowArgs} args - Arguments to find a JobApplication
     * @example
     * // Get one JobApplication
     * const jobApplication = await prisma.jobApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, JobApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationFindFirstArgs} args - Arguments to find a JobApplication
     * @example
     * // Get one JobApplication
     * const jobApplication = await prisma.jobApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobApplicationFindFirstArgs>(args?: SelectSubset<T, JobApplicationFindFirstArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationFindFirstOrThrowArgs} args - Arguments to find a JobApplication
     * @example
     * // Get one JobApplication
     * const jobApplication = await prisma.jobApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, JobApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobApplications
     * const jobApplications = await prisma.jobApplication.findMany()
     * 
     * // Get first 10 JobApplications
     * const jobApplications = await prisma.jobApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobApplicationWithIdOnly = await prisma.jobApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobApplicationFindManyArgs>(args?: SelectSubset<T, JobApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobApplication.
     * @param {JobApplicationCreateArgs} args - Arguments to create a JobApplication.
     * @example
     * // Create one JobApplication
     * const JobApplication = await prisma.jobApplication.create({
     *   data: {
     *     // ... data to create a JobApplication
     *   }
     * })
     * 
     */
    create<T extends JobApplicationCreateArgs>(args: SelectSubset<T, JobApplicationCreateArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobApplications.
     * @param {JobApplicationCreateManyArgs} args - Arguments to create many JobApplications.
     * @example
     * // Create many JobApplications
     * const jobApplication = await prisma.jobApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobApplicationCreateManyArgs>(args?: SelectSubset<T, JobApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobApplications and returns the data saved in the database.
     * @param {JobApplicationCreateManyAndReturnArgs} args - Arguments to create many JobApplications.
     * @example
     * // Create many JobApplications
     * const jobApplication = await prisma.jobApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobApplications and only return the `id`
     * const jobApplicationWithIdOnly = await prisma.jobApplication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, JobApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobApplication.
     * @param {JobApplicationDeleteArgs} args - Arguments to delete one JobApplication.
     * @example
     * // Delete one JobApplication
     * const JobApplication = await prisma.jobApplication.delete({
     *   where: {
     *     // ... filter to delete one JobApplication
     *   }
     * })
     * 
     */
    delete<T extends JobApplicationDeleteArgs>(args: SelectSubset<T, JobApplicationDeleteArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobApplication.
     * @param {JobApplicationUpdateArgs} args - Arguments to update one JobApplication.
     * @example
     * // Update one JobApplication
     * const jobApplication = await prisma.jobApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobApplicationUpdateArgs>(args: SelectSubset<T, JobApplicationUpdateArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobApplications.
     * @param {JobApplicationDeleteManyArgs} args - Arguments to filter JobApplications to delete.
     * @example
     * // Delete a few JobApplications
     * const { count } = await prisma.jobApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobApplicationDeleteManyArgs>(args?: SelectSubset<T, JobApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobApplications
     * const jobApplication = await prisma.jobApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobApplicationUpdateManyArgs>(args: SelectSubset<T, JobApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobApplications and returns the data updated in the database.
     * @param {JobApplicationUpdateManyAndReturnArgs} args - Arguments to update many JobApplications.
     * @example
     * // Update many JobApplications
     * const jobApplication = await prisma.jobApplication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobApplications and only return the `id`
     * const jobApplicationWithIdOnly = await prisma.jobApplication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobApplicationUpdateManyAndReturnArgs>(args: SelectSubset<T, JobApplicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobApplication.
     * @param {JobApplicationUpsertArgs} args - Arguments to update or create a JobApplication.
     * @example
     * // Update or create a JobApplication
     * const jobApplication = await prisma.jobApplication.upsert({
     *   create: {
     *     // ... data to create a JobApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobApplication we want to update
     *   }
     * })
     */
    upsert<T extends JobApplicationUpsertArgs>(args: SelectSubset<T, JobApplicationUpsertArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationCountArgs} args - Arguments to filter JobApplications to count.
     * @example
     * // Count the number of JobApplications
     * const count = await prisma.jobApplication.count({
     *   where: {
     *     // ... the filter for the JobApplications we want to count
     *   }
     * })
    **/
    count<T extends JobApplicationCountArgs>(
      args?: Subset<T, JobApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobApplicationAggregateArgs>(args: Subset<T, JobApplicationAggregateArgs>): Prisma.PrismaPromise<GetJobApplicationAggregateType<T>>

    /**
     * Group by JobApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobApplicationGroupByArgs['orderBy'] }
        : { orderBy?: JobApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobApplication model
   */
  readonly fields: JobApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends JobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobDefaultArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    applicant<T extends JobApplication$applicantArgs<ExtArgs> = {}>(args?: Subset<T, JobApplication$applicantArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    interviews<T extends JobApplication$interviewsArgs<ExtArgs> = {}>(args?: Subset<T, JobApplication$interviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobInterviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailLogs<T extends JobApplication$emailLogsArgs<ExtArgs> = {}>(args?: Subset<T, JobApplication$emailLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends JobApplication$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, JobApplication$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobApplication model
   */
  interface JobApplicationFieldRefs {
    readonly id: FieldRef<"JobApplication", 'String'>
    readonly jobId: FieldRef<"JobApplication", 'String'>
    readonly applicantId: FieldRef<"JobApplication", 'String'>
    readonly source: FieldRef<"JobApplication", 'CandidateSource'>
    readonly externalName: FieldRef<"JobApplication", 'String'>
    readonly externalEmail: FieldRef<"JobApplication", 'String'>
    readonly externalPhone: FieldRef<"JobApplication", 'String'>
    readonly resumeUrl: FieldRef<"JobApplication", 'String'>
    readonly coverLetter: FieldRef<"JobApplication", 'String'>
    readonly resumeParsedText: FieldRef<"JobApplication", 'String'>
    readonly atsScore: FieldRef<"JobApplication", 'Float'>
    readonly status: FieldRef<"JobApplication", 'ApplicationStatus'>
    readonly statusHistory: FieldRef<"JobApplication", 'Json'>
    readonly createdAt: FieldRef<"JobApplication", 'DateTime'>
    readonly updatedAt: FieldRef<"JobApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JobApplication findUnique
   */
  export type JobApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplication to fetch.
     */
    where: JobApplicationWhereUniqueInput
  }

  /**
   * JobApplication findUniqueOrThrow
   */
  export type JobApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplication to fetch.
     */
    where: JobApplicationWhereUniqueInput
  }

  /**
   * JobApplication findFirst
   */
  export type JobApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplication to fetch.
     */
    where?: JobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplications to fetch.
     */
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobApplications.
     */
    cursor?: JobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobApplications.
     */
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }

  /**
   * JobApplication findFirstOrThrow
   */
  export type JobApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplication to fetch.
     */
    where?: JobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplications to fetch.
     */
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobApplications.
     */
    cursor?: JobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobApplications.
     */
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }

  /**
   * JobApplication findMany
   */
  export type JobApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter, which JobApplications to fetch.
     */
    where?: JobApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobApplications to fetch.
     */
    orderBy?: JobApplicationOrderByWithRelationInput | JobApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobApplications.
     */
    cursor?: JobApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobApplications.
     */
    skip?: number
    distinct?: JobApplicationScalarFieldEnum | JobApplicationScalarFieldEnum[]
  }

  /**
   * JobApplication create
   */
  export type JobApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a JobApplication.
     */
    data: XOR<JobApplicationCreateInput, JobApplicationUncheckedCreateInput>
  }

  /**
   * JobApplication createMany
   */
  export type JobApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobApplications.
     */
    data: JobApplicationCreateManyInput | JobApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobApplication createManyAndReturn
   */
  export type JobApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * The data used to create many JobApplications.
     */
    data: JobApplicationCreateManyInput | JobApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobApplication update
   */
  export type JobApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a JobApplication.
     */
    data: XOR<JobApplicationUpdateInput, JobApplicationUncheckedUpdateInput>
    /**
     * Choose, which JobApplication to update.
     */
    where: JobApplicationWhereUniqueInput
  }

  /**
   * JobApplication updateMany
   */
  export type JobApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobApplications.
     */
    data: XOR<JobApplicationUpdateManyMutationInput, JobApplicationUncheckedUpdateManyInput>
    /**
     * Filter which JobApplications to update
     */
    where?: JobApplicationWhereInput
    /**
     * Limit how many JobApplications to update.
     */
    limit?: number
  }

  /**
   * JobApplication updateManyAndReturn
   */
  export type JobApplicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * The data used to update JobApplications.
     */
    data: XOR<JobApplicationUpdateManyMutationInput, JobApplicationUncheckedUpdateManyInput>
    /**
     * Filter which JobApplications to update
     */
    where?: JobApplicationWhereInput
    /**
     * Limit how many JobApplications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobApplication upsert
   */
  export type JobApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the JobApplication to update in case it exists.
     */
    where: JobApplicationWhereUniqueInput
    /**
     * In case the JobApplication found by the `where` argument doesn't exist, create a new JobApplication with this data.
     */
    create: XOR<JobApplicationCreateInput, JobApplicationUncheckedCreateInput>
    /**
     * In case the JobApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobApplicationUpdateInput, JobApplicationUncheckedUpdateInput>
  }

  /**
   * JobApplication delete
   */
  export type JobApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    /**
     * Filter which JobApplication to delete.
     */
    where: JobApplicationWhereUniqueInput
  }

  /**
   * JobApplication deleteMany
   */
  export type JobApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobApplications to delete
     */
    where?: JobApplicationWhereInput
    /**
     * Limit how many JobApplications to delete.
     */
    limit?: number
  }

  /**
   * JobApplication.applicant
   */
  export type JobApplication$applicantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * JobApplication.interviews
   */
  export type JobApplication$interviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobInterview
     */
    select?: JobInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobInterview
     */
    omit?: JobInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInterviewInclude<ExtArgs> | null
    where?: JobInterviewWhereInput
    orderBy?: JobInterviewOrderByWithRelationInput | JobInterviewOrderByWithRelationInput[]
    cursor?: JobInterviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobInterviewScalarFieldEnum | JobInterviewScalarFieldEnum[]
  }

  /**
   * JobApplication.emailLogs
   */
  export type JobApplication$emailLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    where?: EmailLogWhereInput
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    cursor?: EmailLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * JobApplication.auditLogs
   */
  export type JobApplication$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * JobApplication without action
   */
  export type JobApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
  }


  /**
   * Model JobInterview
   */

  export type AggregateJobInterview = {
    _count: JobInterviewCountAggregateOutputType | null
    _avg: JobInterviewAvgAggregateOutputType | null
    _sum: JobInterviewSumAggregateOutputType | null
    _min: JobInterviewMinAggregateOutputType | null
    _max: JobInterviewMaxAggregateOutputType | null
  }

  export type JobInterviewAvgAggregateOutputType = {
    duration: number | null
    score: number | null
  }

  export type JobInterviewSumAggregateOutputType = {
    duration: number | null
    score: number | null
  }

  export type JobInterviewMinAggregateOutputType = {
    id: string | null
    applicationId: string | null
    roundName: string | null
    roundType: $Enums.InterviewRoundType | null
    scheduledAt: Date | null
    duration: number | null
    meetingLink: string | null
    location: string | null
    interviewerId: string | null
    status: $Enums.InterviewStatus | null
    feedback: string | null
    score: number | null
    result: $Enums.InterviewResult | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobInterviewMaxAggregateOutputType = {
    id: string | null
    applicationId: string | null
    roundName: string | null
    roundType: $Enums.InterviewRoundType | null
    scheduledAt: Date | null
    duration: number | null
    meetingLink: string | null
    location: string | null
    interviewerId: string | null
    status: $Enums.InterviewStatus | null
    feedback: string | null
    score: number | null
    result: $Enums.InterviewResult | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobInterviewCountAggregateOutputType = {
    id: number
    applicationId: number
    roundName: number
    roundType: number
    scheduledAt: number
    duration: number
    meetingLink: number
    location: number
    interviewerId: number
    status: number
    feedback: number
    score: number
    result: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JobInterviewAvgAggregateInputType = {
    duration?: true
    score?: true
  }

  export type JobInterviewSumAggregateInputType = {
    duration?: true
    score?: true
  }

  export type JobInterviewMinAggregateInputType = {
    id?: true
    applicationId?: true
    roundName?: true
    roundType?: true
    scheduledAt?: true
    duration?: true
    meetingLink?: true
    location?: true
    interviewerId?: true
    status?: true
    feedback?: true
    score?: true
    result?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobInterviewMaxAggregateInputType = {
    id?: true
    applicationId?: true
    roundName?: true
    roundType?: true
    scheduledAt?: true
    duration?: true
    meetingLink?: true
    location?: true
    interviewerId?: true
    status?: true
    feedback?: true
    score?: true
    result?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobInterviewCountAggregateInputType = {
    id?: true
    applicationId?: true
    roundName?: true
    roundType?: true
    scheduledAt?: true
    duration?: true
    meetingLink?: true
    location?: true
    interviewerId?: true
    status?: true
    feedback?: true
    score?: true
    result?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JobInterviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobInterview to aggregate.
     */
    where?: JobInterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobInterviews to fetch.
     */
    orderBy?: JobInterviewOrderByWithRelationInput | JobInterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobInterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobInterviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobInterviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobInterviews
    **/
    _count?: true | JobInterviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobInterviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobInterviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobInterviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobInterviewMaxAggregateInputType
  }

  export type GetJobInterviewAggregateType<T extends JobInterviewAggregateArgs> = {
        [P in keyof T & keyof AggregateJobInterview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobInterview[P]>
      : GetScalarType<T[P], AggregateJobInterview[P]>
  }




  export type JobInterviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobInterviewWhereInput
    orderBy?: JobInterviewOrderByWithAggregationInput | JobInterviewOrderByWithAggregationInput[]
    by: JobInterviewScalarFieldEnum[] | JobInterviewScalarFieldEnum
    having?: JobInterviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobInterviewCountAggregateInputType | true
    _avg?: JobInterviewAvgAggregateInputType
    _sum?: JobInterviewSumAggregateInputType
    _min?: JobInterviewMinAggregateInputType
    _max?: JobInterviewMaxAggregateInputType
  }

  export type JobInterviewGroupByOutputType = {
    id: string
    applicationId: string
    roundName: string
    roundType: $Enums.InterviewRoundType
    scheduledAt: Date
    duration: number
    meetingLink: string | null
    location: string | null
    interviewerId: string
    status: $Enums.InterviewStatus
    feedback: string | null
    score: number | null
    result: $Enums.InterviewResult | null
    createdAt: Date
    updatedAt: Date
    _count: JobInterviewCountAggregateOutputType | null
    _avg: JobInterviewAvgAggregateOutputType | null
    _sum: JobInterviewSumAggregateOutputType | null
    _min: JobInterviewMinAggregateOutputType | null
    _max: JobInterviewMaxAggregateOutputType | null
  }

  type GetJobInterviewGroupByPayload<T extends JobInterviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobInterviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobInterviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobInterviewGroupByOutputType[P]>
            : GetScalarType<T[P], JobInterviewGroupByOutputType[P]>
        }
      >
    >


  export type JobInterviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    roundName?: boolean
    roundType?: boolean
    scheduledAt?: boolean
    duration?: boolean
    meetingLink?: boolean
    location?: boolean
    interviewerId?: boolean
    status?: boolean
    feedback?: boolean
    score?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
    interviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobInterview"]>

  export type JobInterviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    roundName?: boolean
    roundType?: boolean
    scheduledAt?: boolean
    duration?: boolean
    meetingLink?: boolean
    location?: boolean
    interviewerId?: boolean
    status?: boolean
    feedback?: boolean
    score?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
    interviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobInterview"]>

  export type JobInterviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    roundName?: boolean
    roundType?: boolean
    scheduledAt?: boolean
    duration?: boolean
    meetingLink?: boolean
    location?: boolean
    interviewerId?: boolean
    status?: boolean
    feedback?: boolean
    score?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
    interviewer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobInterview"]>

  export type JobInterviewSelectScalar = {
    id?: boolean
    applicationId?: boolean
    roundName?: boolean
    roundType?: boolean
    scheduledAt?: boolean
    duration?: boolean
    meetingLink?: boolean
    location?: boolean
    interviewerId?: boolean
    status?: boolean
    feedback?: boolean
    score?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JobInterviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "applicationId" | "roundName" | "roundType" | "scheduledAt" | "duration" | "meetingLink" | "location" | "interviewerId" | "status" | "feedback" | "score" | "result" | "createdAt" | "updatedAt", ExtArgs["result"]["jobInterview"]>
  export type JobInterviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
    interviewer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type JobInterviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
    interviewer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type JobInterviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | JobApplicationDefaultArgs<ExtArgs>
    interviewer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $JobInterviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobInterview"
    objects: {
      application: Prisma.$JobApplicationPayload<ExtArgs>
      interviewer: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicationId: string
      roundName: string
      roundType: $Enums.InterviewRoundType
      scheduledAt: Date
      duration: number
      meetingLink: string | null
      location: string | null
      interviewerId: string
      status: $Enums.InterviewStatus
      feedback: string | null
      score: number | null
      result: $Enums.InterviewResult | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["jobInterview"]>
    composites: {}
  }

  type JobInterviewGetPayload<S extends boolean | null | undefined | JobInterviewDefaultArgs> = $Result.GetResult<Prisma.$JobInterviewPayload, S>

  type JobInterviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobInterviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobInterviewCountAggregateInputType | true
    }

  export interface JobInterviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobInterview'], meta: { name: 'JobInterview' } }
    /**
     * Find zero or one JobInterview that matches the filter.
     * @param {JobInterviewFindUniqueArgs} args - Arguments to find a JobInterview
     * @example
     * // Get one JobInterview
     * const jobInterview = await prisma.jobInterview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobInterviewFindUniqueArgs>(args: SelectSubset<T, JobInterviewFindUniqueArgs<ExtArgs>>): Prisma__JobInterviewClient<$Result.GetResult<Prisma.$JobInterviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobInterview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobInterviewFindUniqueOrThrowArgs} args - Arguments to find a JobInterview
     * @example
     * // Get one JobInterview
     * const jobInterview = await prisma.jobInterview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobInterviewFindUniqueOrThrowArgs>(args: SelectSubset<T, JobInterviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobInterviewClient<$Result.GetResult<Prisma.$JobInterviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobInterview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobInterviewFindFirstArgs} args - Arguments to find a JobInterview
     * @example
     * // Get one JobInterview
     * const jobInterview = await prisma.jobInterview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobInterviewFindFirstArgs>(args?: SelectSubset<T, JobInterviewFindFirstArgs<ExtArgs>>): Prisma__JobInterviewClient<$Result.GetResult<Prisma.$JobInterviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobInterview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobInterviewFindFirstOrThrowArgs} args - Arguments to find a JobInterview
     * @example
     * // Get one JobInterview
     * const jobInterview = await prisma.jobInterview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobInterviewFindFirstOrThrowArgs>(args?: SelectSubset<T, JobInterviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobInterviewClient<$Result.GetResult<Prisma.$JobInterviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobInterviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobInterviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobInterviews
     * const jobInterviews = await prisma.jobInterview.findMany()
     * 
     * // Get first 10 JobInterviews
     * const jobInterviews = await prisma.jobInterview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobInterviewWithIdOnly = await prisma.jobInterview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobInterviewFindManyArgs>(args?: SelectSubset<T, JobInterviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobInterviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobInterview.
     * @param {JobInterviewCreateArgs} args - Arguments to create a JobInterview.
     * @example
     * // Create one JobInterview
     * const JobInterview = await prisma.jobInterview.create({
     *   data: {
     *     // ... data to create a JobInterview
     *   }
     * })
     * 
     */
    create<T extends JobInterviewCreateArgs>(args: SelectSubset<T, JobInterviewCreateArgs<ExtArgs>>): Prisma__JobInterviewClient<$Result.GetResult<Prisma.$JobInterviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobInterviews.
     * @param {JobInterviewCreateManyArgs} args - Arguments to create many JobInterviews.
     * @example
     * // Create many JobInterviews
     * const jobInterview = await prisma.jobInterview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobInterviewCreateManyArgs>(args?: SelectSubset<T, JobInterviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobInterviews and returns the data saved in the database.
     * @param {JobInterviewCreateManyAndReturnArgs} args - Arguments to create many JobInterviews.
     * @example
     * // Create many JobInterviews
     * const jobInterview = await prisma.jobInterview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobInterviews and only return the `id`
     * const jobInterviewWithIdOnly = await prisma.jobInterview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobInterviewCreateManyAndReturnArgs>(args?: SelectSubset<T, JobInterviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobInterviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobInterview.
     * @param {JobInterviewDeleteArgs} args - Arguments to delete one JobInterview.
     * @example
     * // Delete one JobInterview
     * const JobInterview = await prisma.jobInterview.delete({
     *   where: {
     *     // ... filter to delete one JobInterview
     *   }
     * })
     * 
     */
    delete<T extends JobInterviewDeleteArgs>(args: SelectSubset<T, JobInterviewDeleteArgs<ExtArgs>>): Prisma__JobInterviewClient<$Result.GetResult<Prisma.$JobInterviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobInterview.
     * @param {JobInterviewUpdateArgs} args - Arguments to update one JobInterview.
     * @example
     * // Update one JobInterview
     * const jobInterview = await prisma.jobInterview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobInterviewUpdateArgs>(args: SelectSubset<T, JobInterviewUpdateArgs<ExtArgs>>): Prisma__JobInterviewClient<$Result.GetResult<Prisma.$JobInterviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobInterviews.
     * @param {JobInterviewDeleteManyArgs} args - Arguments to filter JobInterviews to delete.
     * @example
     * // Delete a few JobInterviews
     * const { count } = await prisma.jobInterview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobInterviewDeleteManyArgs>(args?: SelectSubset<T, JobInterviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobInterviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobInterviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobInterviews
     * const jobInterview = await prisma.jobInterview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobInterviewUpdateManyArgs>(args: SelectSubset<T, JobInterviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobInterviews and returns the data updated in the database.
     * @param {JobInterviewUpdateManyAndReturnArgs} args - Arguments to update many JobInterviews.
     * @example
     * // Update many JobInterviews
     * const jobInterview = await prisma.jobInterview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobInterviews and only return the `id`
     * const jobInterviewWithIdOnly = await prisma.jobInterview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobInterviewUpdateManyAndReturnArgs>(args: SelectSubset<T, JobInterviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobInterviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobInterview.
     * @param {JobInterviewUpsertArgs} args - Arguments to update or create a JobInterview.
     * @example
     * // Update or create a JobInterview
     * const jobInterview = await prisma.jobInterview.upsert({
     *   create: {
     *     // ... data to create a JobInterview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobInterview we want to update
     *   }
     * })
     */
    upsert<T extends JobInterviewUpsertArgs>(args: SelectSubset<T, JobInterviewUpsertArgs<ExtArgs>>): Prisma__JobInterviewClient<$Result.GetResult<Prisma.$JobInterviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobInterviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobInterviewCountArgs} args - Arguments to filter JobInterviews to count.
     * @example
     * // Count the number of JobInterviews
     * const count = await prisma.jobInterview.count({
     *   where: {
     *     // ... the filter for the JobInterviews we want to count
     *   }
     * })
    **/
    count<T extends JobInterviewCountArgs>(
      args?: Subset<T, JobInterviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobInterviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobInterview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobInterviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobInterviewAggregateArgs>(args: Subset<T, JobInterviewAggregateArgs>): Prisma.PrismaPromise<GetJobInterviewAggregateType<T>>

    /**
     * Group by JobInterview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobInterviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobInterviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobInterviewGroupByArgs['orderBy'] }
        : { orderBy?: JobInterviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobInterviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobInterviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobInterview model
   */
  readonly fields: JobInterviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobInterview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobInterviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends JobApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobApplicationDefaultArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    interviewer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobInterview model
   */
  interface JobInterviewFieldRefs {
    readonly id: FieldRef<"JobInterview", 'String'>
    readonly applicationId: FieldRef<"JobInterview", 'String'>
    readonly roundName: FieldRef<"JobInterview", 'String'>
    readonly roundType: FieldRef<"JobInterview", 'InterviewRoundType'>
    readonly scheduledAt: FieldRef<"JobInterview", 'DateTime'>
    readonly duration: FieldRef<"JobInterview", 'Int'>
    readonly meetingLink: FieldRef<"JobInterview", 'String'>
    readonly location: FieldRef<"JobInterview", 'String'>
    readonly interviewerId: FieldRef<"JobInterview", 'String'>
    readonly status: FieldRef<"JobInterview", 'InterviewStatus'>
    readonly feedback: FieldRef<"JobInterview", 'String'>
    readonly score: FieldRef<"JobInterview", 'Int'>
    readonly result: FieldRef<"JobInterview", 'InterviewResult'>
    readonly createdAt: FieldRef<"JobInterview", 'DateTime'>
    readonly updatedAt: FieldRef<"JobInterview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JobInterview findUnique
   */
  export type JobInterviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobInterview
     */
    select?: JobInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobInterview
     */
    omit?: JobInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInterviewInclude<ExtArgs> | null
    /**
     * Filter, which JobInterview to fetch.
     */
    where: JobInterviewWhereUniqueInput
  }

  /**
   * JobInterview findUniqueOrThrow
   */
  export type JobInterviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobInterview
     */
    select?: JobInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobInterview
     */
    omit?: JobInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInterviewInclude<ExtArgs> | null
    /**
     * Filter, which JobInterview to fetch.
     */
    where: JobInterviewWhereUniqueInput
  }

  /**
   * JobInterview findFirst
   */
  export type JobInterviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobInterview
     */
    select?: JobInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobInterview
     */
    omit?: JobInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInterviewInclude<ExtArgs> | null
    /**
     * Filter, which JobInterview to fetch.
     */
    where?: JobInterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobInterviews to fetch.
     */
    orderBy?: JobInterviewOrderByWithRelationInput | JobInterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobInterviews.
     */
    cursor?: JobInterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobInterviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobInterviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobInterviews.
     */
    distinct?: JobInterviewScalarFieldEnum | JobInterviewScalarFieldEnum[]
  }

  /**
   * JobInterview findFirstOrThrow
   */
  export type JobInterviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobInterview
     */
    select?: JobInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobInterview
     */
    omit?: JobInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInterviewInclude<ExtArgs> | null
    /**
     * Filter, which JobInterview to fetch.
     */
    where?: JobInterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobInterviews to fetch.
     */
    orderBy?: JobInterviewOrderByWithRelationInput | JobInterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobInterviews.
     */
    cursor?: JobInterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobInterviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobInterviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobInterviews.
     */
    distinct?: JobInterviewScalarFieldEnum | JobInterviewScalarFieldEnum[]
  }

  /**
   * JobInterview findMany
   */
  export type JobInterviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobInterview
     */
    select?: JobInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobInterview
     */
    omit?: JobInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInterviewInclude<ExtArgs> | null
    /**
     * Filter, which JobInterviews to fetch.
     */
    where?: JobInterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobInterviews to fetch.
     */
    orderBy?: JobInterviewOrderByWithRelationInput | JobInterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobInterviews.
     */
    cursor?: JobInterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobInterviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobInterviews.
     */
    skip?: number
    distinct?: JobInterviewScalarFieldEnum | JobInterviewScalarFieldEnum[]
  }

  /**
   * JobInterview create
   */
  export type JobInterviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobInterview
     */
    select?: JobInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobInterview
     */
    omit?: JobInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInterviewInclude<ExtArgs> | null
    /**
     * The data needed to create a JobInterview.
     */
    data: XOR<JobInterviewCreateInput, JobInterviewUncheckedCreateInput>
  }

  /**
   * JobInterview createMany
   */
  export type JobInterviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobInterviews.
     */
    data: JobInterviewCreateManyInput | JobInterviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobInterview createManyAndReturn
   */
  export type JobInterviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobInterview
     */
    select?: JobInterviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobInterview
     */
    omit?: JobInterviewOmit<ExtArgs> | null
    /**
     * The data used to create many JobInterviews.
     */
    data: JobInterviewCreateManyInput | JobInterviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInterviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobInterview update
   */
  export type JobInterviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobInterview
     */
    select?: JobInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobInterview
     */
    omit?: JobInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInterviewInclude<ExtArgs> | null
    /**
     * The data needed to update a JobInterview.
     */
    data: XOR<JobInterviewUpdateInput, JobInterviewUncheckedUpdateInput>
    /**
     * Choose, which JobInterview to update.
     */
    where: JobInterviewWhereUniqueInput
  }

  /**
   * JobInterview updateMany
   */
  export type JobInterviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobInterviews.
     */
    data: XOR<JobInterviewUpdateManyMutationInput, JobInterviewUncheckedUpdateManyInput>
    /**
     * Filter which JobInterviews to update
     */
    where?: JobInterviewWhereInput
    /**
     * Limit how many JobInterviews to update.
     */
    limit?: number
  }

  /**
   * JobInterview updateManyAndReturn
   */
  export type JobInterviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobInterview
     */
    select?: JobInterviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JobInterview
     */
    omit?: JobInterviewOmit<ExtArgs> | null
    /**
     * The data used to update JobInterviews.
     */
    data: XOR<JobInterviewUpdateManyMutationInput, JobInterviewUncheckedUpdateManyInput>
    /**
     * Filter which JobInterviews to update
     */
    where?: JobInterviewWhereInput
    /**
     * Limit how many JobInterviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInterviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JobInterview upsert
   */
  export type JobInterviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobInterview
     */
    select?: JobInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobInterview
     */
    omit?: JobInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInterviewInclude<ExtArgs> | null
    /**
     * The filter to search for the JobInterview to update in case it exists.
     */
    where: JobInterviewWhereUniqueInput
    /**
     * In case the JobInterview found by the `where` argument doesn't exist, create a new JobInterview with this data.
     */
    create: XOR<JobInterviewCreateInput, JobInterviewUncheckedCreateInput>
    /**
     * In case the JobInterview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobInterviewUpdateInput, JobInterviewUncheckedUpdateInput>
  }

  /**
   * JobInterview delete
   */
  export type JobInterviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobInterview
     */
    select?: JobInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobInterview
     */
    omit?: JobInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInterviewInclude<ExtArgs> | null
    /**
     * Filter which JobInterview to delete.
     */
    where: JobInterviewWhereUniqueInput
  }

  /**
   * JobInterview deleteMany
   */
  export type JobInterviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobInterviews to delete
     */
    where?: JobInterviewWhereInput
    /**
     * Limit how many JobInterviews to delete.
     */
    limit?: number
  }

  /**
   * JobInterview without action
   */
  export type JobInterviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobInterview
     */
    select?: JobInterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobInterview
     */
    omit?: JobInterviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInterviewInclude<ExtArgs> | null
  }


  /**
   * Model EmailLog
   */

  export type AggregateEmailLog = {
    _count: EmailLogCountAggregateOutputType | null
    _min: EmailLogMinAggregateOutputType | null
    _max: EmailLogMaxAggregateOutputType | null
  }

  export type EmailLogMinAggregateOutputType = {
    id: string | null
    jobId: string | null
    applicationId: string | null
    recipientEmail: string | null
    recipientName: string | null
    templateName: string | null
    subject: string | null
    body: string | null
    status: $Enums.EmailStatus | null
    sentAt: Date | null
    error: string | null
    triggeredBy: string | null
  }

  export type EmailLogMaxAggregateOutputType = {
    id: string | null
    jobId: string | null
    applicationId: string | null
    recipientEmail: string | null
    recipientName: string | null
    templateName: string | null
    subject: string | null
    body: string | null
    status: $Enums.EmailStatus | null
    sentAt: Date | null
    error: string | null
    triggeredBy: string | null
  }

  export type EmailLogCountAggregateOutputType = {
    id: number
    jobId: number
    applicationId: number
    recipientEmail: number
    recipientName: number
    templateName: number
    subject: number
    body: number
    status: number
    sentAt: number
    error: number
    triggeredBy: number
    _all: number
  }


  export type EmailLogMinAggregateInputType = {
    id?: true
    jobId?: true
    applicationId?: true
    recipientEmail?: true
    recipientName?: true
    templateName?: true
    subject?: true
    body?: true
    status?: true
    sentAt?: true
    error?: true
    triggeredBy?: true
  }

  export type EmailLogMaxAggregateInputType = {
    id?: true
    jobId?: true
    applicationId?: true
    recipientEmail?: true
    recipientName?: true
    templateName?: true
    subject?: true
    body?: true
    status?: true
    sentAt?: true
    error?: true
    triggeredBy?: true
  }

  export type EmailLogCountAggregateInputType = {
    id?: true
    jobId?: true
    applicationId?: true
    recipientEmail?: true
    recipientName?: true
    templateName?: true
    subject?: true
    body?: true
    status?: true
    sentAt?: true
    error?: true
    triggeredBy?: true
    _all?: true
  }

  export type EmailLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailLog to aggregate.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailLogs
    **/
    _count?: true | EmailLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailLogMaxAggregateInputType
  }

  export type GetEmailLogAggregateType<T extends EmailLogAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailLog[P]>
      : GetScalarType<T[P], AggregateEmailLog[P]>
  }




  export type EmailLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailLogWhereInput
    orderBy?: EmailLogOrderByWithAggregationInput | EmailLogOrderByWithAggregationInput[]
    by: EmailLogScalarFieldEnum[] | EmailLogScalarFieldEnum
    having?: EmailLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailLogCountAggregateInputType | true
    _min?: EmailLogMinAggregateInputType
    _max?: EmailLogMaxAggregateInputType
  }

  export type EmailLogGroupByOutputType = {
    id: string
    jobId: string | null
    applicationId: string | null
    recipientEmail: string
    recipientName: string | null
    templateName: string
    subject: string
    body: string
    status: $Enums.EmailStatus
    sentAt: Date
    error: string | null
    triggeredBy: string | null
    _count: EmailLogCountAggregateOutputType | null
    _min: EmailLogMinAggregateOutputType | null
    _max: EmailLogMaxAggregateOutputType | null
  }

  type GetEmailLogGroupByPayload<T extends EmailLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailLogGroupByOutputType[P]>
            : GetScalarType<T[P], EmailLogGroupByOutputType[P]>
        }
      >
    >


  export type EmailLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    applicationId?: boolean
    recipientEmail?: boolean
    recipientName?: boolean
    templateName?: boolean
    subject?: boolean
    body?: boolean
    status?: boolean
    sentAt?: boolean
    error?: boolean
    triggeredBy?: boolean
    application?: boolean | EmailLog$applicationArgs<ExtArgs>
  }, ExtArgs["result"]["emailLog"]>

  export type EmailLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    applicationId?: boolean
    recipientEmail?: boolean
    recipientName?: boolean
    templateName?: boolean
    subject?: boolean
    body?: boolean
    status?: boolean
    sentAt?: boolean
    error?: boolean
    triggeredBy?: boolean
    application?: boolean | EmailLog$applicationArgs<ExtArgs>
  }, ExtArgs["result"]["emailLog"]>

  export type EmailLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    applicationId?: boolean
    recipientEmail?: boolean
    recipientName?: boolean
    templateName?: boolean
    subject?: boolean
    body?: boolean
    status?: boolean
    sentAt?: boolean
    error?: boolean
    triggeredBy?: boolean
    application?: boolean | EmailLog$applicationArgs<ExtArgs>
  }, ExtArgs["result"]["emailLog"]>

  export type EmailLogSelectScalar = {
    id?: boolean
    jobId?: boolean
    applicationId?: boolean
    recipientEmail?: boolean
    recipientName?: boolean
    templateName?: boolean
    subject?: boolean
    body?: boolean
    status?: boolean
    sentAt?: boolean
    error?: boolean
    triggeredBy?: boolean
  }

  export type EmailLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobId" | "applicationId" | "recipientEmail" | "recipientName" | "templateName" | "subject" | "body" | "status" | "sentAt" | "error" | "triggeredBy", ExtArgs["result"]["emailLog"]>
  export type EmailLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | EmailLog$applicationArgs<ExtArgs>
  }
  export type EmailLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | EmailLog$applicationArgs<ExtArgs>
  }
  export type EmailLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | EmailLog$applicationArgs<ExtArgs>
  }

  export type $EmailLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailLog"
    objects: {
      application: Prisma.$JobApplicationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobId: string | null
      applicationId: string | null
      recipientEmail: string
      recipientName: string | null
      templateName: string
      subject: string
      body: string
      status: $Enums.EmailStatus
      sentAt: Date
      error: string | null
      triggeredBy: string | null
    }, ExtArgs["result"]["emailLog"]>
    composites: {}
  }

  type EmailLogGetPayload<S extends boolean | null | undefined | EmailLogDefaultArgs> = $Result.GetResult<Prisma.$EmailLogPayload, S>

  type EmailLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailLogCountAggregateInputType | true
    }

  export interface EmailLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailLog'], meta: { name: 'EmailLog' } }
    /**
     * Find zero or one EmailLog that matches the filter.
     * @param {EmailLogFindUniqueArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailLogFindUniqueArgs>(args: SelectSubset<T, EmailLogFindUniqueArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailLogFindUniqueOrThrowArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailLogFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogFindFirstArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailLogFindFirstArgs>(args?: SelectSubset<T, EmailLogFindFirstArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogFindFirstOrThrowArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailLogFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailLogs
     * const emailLogs = await prisma.emailLog.findMany()
     * 
     * // Get first 10 EmailLogs
     * const emailLogs = await prisma.emailLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailLogWithIdOnly = await prisma.emailLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailLogFindManyArgs>(args?: SelectSubset<T, EmailLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailLog.
     * @param {EmailLogCreateArgs} args - Arguments to create a EmailLog.
     * @example
     * // Create one EmailLog
     * const EmailLog = await prisma.emailLog.create({
     *   data: {
     *     // ... data to create a EmailLog
     *   }
     * })
     * 
     */
    create<T extends EmailLogCreateArgs>(args: SelectSubset<T, EmailLogCreateArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailLogs.
     * @param {EmailLogCreateManyArgs} args - Arguments to create many EmailLogs.
     * @example
     * // Create many EmailLogs
     * const emailLog = await prisma.emailLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailLogCreateManyArgs>(args?: SelectSubset<T, EmailLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailLogs and returns the data saved in the database.
     * @param {EmailLogCreateManyAndReturnArgs} args - Arguments to create many EmailLogs.
     * @example
     * // Create many EmailLogs
     * const emailLog = await prisma.emailLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailLogs and only return the `id`
     * const emailLogWithIdOnly = await prisma.emailLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailLogCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailLog.
     * @param {EmailLogDeleteArgs} args - Arguments to delete one EmailLog.
     * @example
     * // Delete one EmailLog
     * const EmailLog = await prisma.emailLog.delete({
     *   where: {
     *     // ... filter to delete one EmailLog
     *   }
     * })
     * 
     */
    delete<T extends EmailLogDeleteArgs>(args: SelectSubset<T, EmailLogDeleteArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailLog.
     * @param {EmailLogUpdateArgs} args - Arguments to update one EmailLog.
     * @example
     * // Update one EmailLog
     * const emailLog = await prisma.emailLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailLogUpdateArgs>(args: SelectSubset<T, EmailLogUpdateArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailLogs.
     * @param {EmailLogDeleteManyArgs} args - Arguments to filter EmailLogs to delete.
     * @example
     * // Delete a few EmailLogs
     * const { count } = await prisma.emailLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailLogDeleteManyArgs>(args?: SelectSubset<T, EmailLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailLogs
     * const emailLog = await prisma.emailLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailLogUpdateManyArgs>(args: SelectSubset<T, EmailLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailLogs and returns the data updated in the database.
     * @param {EmailLogUpdateManyAndReturnArgs} args - Arguments to update many EmailLogs.
     * @example
     * // Update many EmailLogs
     * const emailLog = await prisma.emailLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailLogs and only return the `id`
     * const emailLogWithIdOnly = await prisma.emailLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailLogUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailLog.
     * @param {EmailLogUpsertArgs} args - Arguments to update or create a EmailLog.
     * @example
     * // Update or create a EmailLog
     * const emailLog = await prisma.emailLog.upsert({
     *   create: {
     *     // ... data to create a EmailLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailLog we want to update
     *   }
     * })
     */
    upsert<T extends EmailLogUpsertArgs>(args: SelectSubset<T, EmailLogUpsertArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogCountArgs} args - Arguments to filter EmailLogs to count.
     * @example
     * // Count the number of EmailLogs
     * const count = await prisma.emailLog.count({
     *   where: {
     *     // ... the filter for the EmailLogs we want to count
     *   }
     * })
    **/
    count<T extends EmailLogCountArgs>(
      args?: Subset<T, EmailLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailLogAggregateArgs>(args: Subset<T, EmailLogAggregateArgs>): Prisma.PrismaPromise<GetEmailLogAggregateType<T>>

    /**
     * Group by EmailLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailLogGroupByArgs['orderBy'] }
        : { orderBy?: EmailLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailLog model
   */
  readonly fields: EmailLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends EmailLog$applicationArgs<ExtArgs> = {}>(args?: Subset<T, EmailLog$applicationArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailLog model
   */
  interface EmailLogFieldRefs {
    readonly id: FieldRef<"EmailLog", 'String'>
    readonly jobId: FieldRef<"EmailLog", 'String'>
    readonly applicationId: FieldRef<"EmailLog", 'String'>
    readonly recipientEmail: FieldRef<"EmailLog", 'String'>
    readonly recipientName: FieldRef<"EmailLog", 'String'>
    readonly templateName: FieldRef<"EmailLog", 'String'>
    readonly subject: FieldRef<"EmailLog", 'String'>
    readonly body: FieldRef<"EmailLog", 'String'>
    readonly status: FieldRef<"EmailLog", 'EmailStatus'>
    readonly sentAt: FieldRef<"EmailLog", 'DateTime'>
    readonly error: FieldRef<"EmailLog", 'String'>
    readonly triggeredBy: FieldRef<"EmailLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmailLog findUnique
   */
  export type EmailLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog findUniqueOrThrow
   */
  export type EmailLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog findFirst
   */
  export type EmailLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailLogs.
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailLogs.
     */
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * EmailLog findFirstOrThrow
   */
  export type EmailLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailLogs.
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailLogs.
     */
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * EmailLog findMany
   */
  export type EmailLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLogs to fetch.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailLogs.
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * EmailLog create
   */
  export type EmailLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailLog.
     */
    data: XOR<EmailLogCreateInput, EmailLogUncheckedCreateInput>
  }

  /**
   * EmailLog createMany
   */
  export type EmailLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailLogs.
     */
    data: EmailLogCreateManyInput | EmailLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailLog createManyAndReturn
   */
  export type EmailLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * The data used to create many EmailLogs.
     */
    data: EmailLogCreateManyInput | EmailLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailLog update
   */
  export type EmailLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailLog.
     */
    data: XOR<EmailLogUpdateInput, EmailLogUncheckedUpdateInput>
    /**
     * Choose, which EmailLog to update.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog updateMany
   */
  export type EmailLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailLogs.
     */
    data: XOR<EmailLogUpdateManyMutationInput, EmailLogUncheckedUpdateManyInput>
    /**
     * Filter which EmailLogs to update
     */
    where?: EmailLogWhereInput
    /**
     * Limit how many EmailLogs to update.
     */
    limit?: number
  }

  /**
   * EmailLog updateManyAndReturn
   */
  export type EmailLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * The data used to update EmailLogs.
     */
    data: XOR<EmailLogUpdateManyMutationInput, EmailLogUncheckedUpdateManyInput>
    /**
     * Filter which EmailLogs to update
     */
    where?: EmailLogWhereInput
    /**
     * Limit how many EmailLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailLog upsert
   */
  export type EmailLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailLog to update in case it exists.
     */
    where: EmailLogWhereUniqueInput
    /**
     * In case the EmailLog found by the `where` argument doesn't exist, create a new EmailLog with this data.
     */
    create: XOR<EmailLogCreateInput, EmailLogUncheckedCreateInput>
    /**
     * In case the EmailLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailLogUpdateInput, EmailLogUncheckedUpdateInput>
  }

  /**
   * EmailLog delete
   */
  export type EmailLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter which EmailLog to delete.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog deleteMany
   */
  export type EmailLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailLogs to delete
     */
    where?: EmailLogWhereInput
    /**
     * Limit how many EmailLogs to delete.
     */
    limit?: number
  }

  /**
   * EmailLog.application
   */
  export type EmailLog$applicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    where?: JobApplicationWhereInput
  }

  /**
   * EmailLog without action
   */
  export type EmailLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailLog
     */
    omit?: EmailLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    action: string | null
    method: string | null
    path: string | null
    ipAddress: string | null
    userAgent: string | null
    applicationId: string | null
    performedBy: string | null
    timestamp: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    action: string | null
    method: string | null
    path: string | null
    ipAddress: string | null
    userAgent: string | null
    applicationId: string | null
    performedBy: string | null
    timestamp: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    action: number
    method: number
    path: number
    ipAddress: number
    userAgent: number
    oldValue: number
    newValue: number
    applicationId: number
    performedBy: number
    details: number
    timestamp: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    method?: true
    path?: true
    ipAddress?: true
    userAgent?: true
    applicationId?: true
    performedBy?: true
    timestamp?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    method?: true
    path?: true
    ipAddress?: true
    userAgent?: true
    applicationId?: true
    performedBy?: true
    timestamp?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    method?: true
    path?: true
    ipAddress?: true
    userAgent?: true
    oldValue?: true
    newValue?: true
    applicationId?: true
    performedBy?: true
    details?: true
    timestamp?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    entityType: string
    entityId: string | null
    action: string
    method: string | null
    path: string | null
    ipAddress: string | null
    userAgent: string | null
    oldValue: JsonValue | null
    newValue: JsonValue | null
    applicationId: string | null
    performedBy: string
    details: JsonValue | null
    timestamp: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    method?: boolean
    path?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    oldValue?: boolean
    newValue?: boolean
    applicationId?: boolean
    performedBy?: boolean
    details?: boolean
    timestamp?: boolean
    application?: boolean | AuditLog$applicationArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    method?: boolean
    path?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    oldValue?: boolean
    newValue?: boolean
    applicationId?: boolean
    performedBy?: boolean
    details?: boolean
    timestamp?: boolean
    application?: boolean | AuditLog$applicationArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    method?: boolean
    path?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    oldValue?: boolean
    newValue?: boolean
    applicationId?: boolean
    performedBy?: boolean
    details?: boolean
    timestamp?: boolean
    application?: boolean | AuditLog$applicationArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    method?: boolean
    path?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    oldValue?: boolean
    newValue?: boolean
    applicationId?: boolean
    performedBy?: boolean
    details?: boolean
    timestamp?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityType" | "entityId" | "action" | "method" | "path" | "ipAddress" | "userAgent" | "oldValue" | "newValue" | "applicationId" | "performedBy" | "details" | "timestamp", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | AuditLog$applicationArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | AuditLog$applicationArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | AuditLog$applicationArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      application: Prisma.$JobApplicationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: string
      entityId: string | null
      action: string
      method: string | null
      path: string | null
      ipAddress: string | null
      userAgent: string | null
      oldValue: Prisma.JsonValue | null
      newValue: Prisma.JsonValue | null
      applicationId: string | null
      performedBy: string
      details: Prisma.JsonValue | null
      timestamp: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends AuditLog$applicationArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$applicationArgs<ExtArgs>>): Prisma__JobApplicationClient<$Result.GetResult<Prisma.$JobApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly method: FieldRef<"AuditLog", 'String'>
    readonly path: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly oldValue: FieldRef<"AuditLog", 'Json'>
    readonly newValue: FieldRef<"AuditLog", 'Json'>
    readonly applicationId: FieldRef<"AuditLog", 'String'>
    readonly performedBy: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.application
   */
  export type AuditLog$applicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobApplication
     */
    select?: JobApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobApplication
     */
    omit?: JobApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobApplicationInclude<ExtArgs> | null
    where?: JobApplicationWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model SavedFilter
   */

  export type AggregateSavedFilter = {
    _count: SavedFilterCountAggregateOutputType | null
    _min: SavedFilterMinAggregateOutputType | null
    _max: SavedFilterMaxAggregateOutputType | null
  }

  export type SavedFilterMinAggregateOutputType = {
    id: string | null
    name: string | null
    userId: string | null
    page: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SavedFilterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    userId: string | null
    page: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SavedFilterCountAggregateOutputType = {
    id: number
    name: number
    userId: number
    page: number
    config: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SavedFilterMinAggregateInputType = {
    id?: true
    name?: true
    userId?: true
    page?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SavedFilterMaxAggregateInputType = {
    id?: true
    name?: true
    userId?: true
    page?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SavedFilterCountAggregateInputType = {
    id?: true
    name?: true
    userId?: true
    page?: true
    config?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SavedFilterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedFilter to aggregate.
     */
    where?: SavedFilterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedFilters to fetch.
     */
    orderBy?: SavedFilterOrderByWithRelationInput | SavedFilterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SavedFilterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedFilters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedFilters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SavedFilters
    **/
    _count?: true | SavedFilterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SavedFilterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SavedFilterMaxAggregateInputType
  }

  export type GetSavedFilterAggregateType<T extends SavedFilterAggregateArgs> = {
        [P in keyof T & keyof AggregateSavedFilter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSavedFilter[P]>
      : GetScalarType<T[P], AggregateSavedFilter[P]>
  }




  export type SavedFilterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedFilterWhereInput
    orderBy?: SavedFilterOrderByWithAggregationInput | SavedFilterOrderByWithAggregationInput[]
    by: SavedFilterScalarFieldEnum[] | SavedFilterScalarFieldEnum
    having?: SavedFilterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SavedFilterCountAggregateInputType | true
    _min?: SavedFilterMinAggregateInputType
    _max?: SavedFilterMaxAggregateInputType
  }

  export type SavedFilterGroupByOutputType = {
    id: string
    name: string
    userId: string
    page: string
    config: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: SavedFilterCountAggregateOutputType | null
    _min: SavedFilterMinAggregateOutputType | null
    _max: SavedFilterMaxAggregateOutputType | null
  }

  type GetSavedFilterGroupByPayload<T extends SavedFilterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SavedFilterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SavedFilterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SavedFilterGroupByOutputType[P]>
            : GetScalarType<T[P], SavedFilterGroupByOutputType[P]>
        }
      >
    >


  export type SavedFilterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    userId?: boolean
    page?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["savedFilter"]>

  export type SavedFilterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    userId?: boolean
    page?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["savedFilter"]>

  export type SavedFilterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    userId?: boolean
    page?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["savedFilter"]>

  export type SavedFilterSelectScalar = {
    id?: boolean
    name?: boolean
    userId?: boolean
    page?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SavedFilterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "userId" | "page" | "config" | "createdAt" | "updatedAt", ExtArgs["result"]["savedFilter"]>

  export type $SavedFilterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SavedFilter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      userId: string
      page: string
      config: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["savedFilter"]>
    composites: {}
  }

  type SavedFilterGetPayload<S extends boolean | null | undefined | SavedFilterDefaultArgs> = $Result.GetResult<Prisma.$SavedFilterPayload, S>

  type SavedFilterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SavedFilterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SavedFilterCountAggregateInputType | true
    }

  export interface SavedFilterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SavedFilter'], meta: { name: 'SavedFilter' } }
    /**
     * Find zero or one SavedFilter that matches the filter.
     * @param {SavedFilterFindUniqueArgs} args - Arguments to find a SavedFilter
     * @example
     * // Get one SavedFilter
     * const savedFilter = await prisma.savedFilter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SavedFilterFindUniqueArgs>(args: SelectSubset<T, SavedFilterFindUniqueArgs<ExtArgs>>): Prisma__SavedFilterClient<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SavedFilter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SavedFilterFindUniqueOrThrowArgs} args - Arguments to find a SavedFilter
     * @example
     * // Get one SavedFilter
     * const savedFilter = await prisma.savedFilter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SavedFilterFindUniqueOrThrowArgs>(args: SelectSubset<T, SavedFilterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SavedFilterClient<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SavedFilter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedFilterFindFirstArgs} args - Arguments to find a SavedFilter
     * @example
     * // Get one SavedFilter
     * const savedFilter = await prisma.savedFilter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SavedFilterFindFirstArgs>(args?: SelectSubset<T, SavedFilterFindFirstArgs<ExtArgs>>): Prisma__SavedFilterClient<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SavedFilter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedFilterFindFirstOrThrowArgs} args - Arguments to find a SavedFilter
     * @example
     * // Get one SavedFilter
     * const savedFilter = await prisma.savedFilter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SavedFilterFindFirstOrThrowArgs>(args?: SelectSubset<T, SavedFilterFindFirstOrThrowArgs<ExtArgs>>): Prisma__SavedFilterClient<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SavedFilters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedFilterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SavedFilters
     * const savedFilters = await prisma.savedFilter.findMany()
     * 
     * // Get first 10 SavedFilters
     * const savedFilters = await prisma.savedFilter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const savedFilterWithIdOnly = await prisma.savedFilter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SavedFilterFindManyArgs>(args?: SelectSubset<T, SavedFilterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SavedFilter.
     * @param {SavedFilterCreateArgs} args - Arguments to create a SavedFilter.
     * @example
     * // Create one SavedFilter
     * const SavedFilter = await prisma.savedFilter.create({
     *   data: {
     *     // ... data to create a SavedFilter
     *   }
     * })
     * 
     */
    create<T extends SavedFilterCreateArgs>(args: SelectSubset<T, SavedFilterCreateArgs<ExtArgs>>): Prisma__SavedFilterClient<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SavedFilters.
     * @param {SavedFilterCreateManyArgs} args - Arguments to create many SavedFilters.
     * @example
     * // Create many SavedFilters
     * const savedFilter = await prisma.savedFilter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SavedFilterCreateManyArgs>(args?: SelectSubset<T, SavedFilterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SavedFilters and returns the data saved in the database.
     * @param {SavedFilterCreateManyAndReturnArgs} args - Arguments to create many SavedFilters.
     * @example
     * // Create many SavedFilters
     * const savedFilter = await prisma.savedFilter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SavedFilters and only return the `id`
     * const savedFilterWithIdOnly = await prisma.savedFilter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SavedFilterCreateManyAndReturnArgs>(args?: SelectSubset<T, SavedFilterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SavedFilter.
     * @param {SavedFilterDeleteArgs} args - Arguments to delete one SavedFilter.
     * @example
     * // Delete one SavedFilter
     * const SavedFilter = await prisma.savedFilter.delete({
     *   where: {
     *     // ... filter to delete one SavedFilter
     *   }
     * })
     * 
     */
    delete<T extends SavedFilterDeleteArgs>(args: SelectSubset<T, SavedFilterDeleteArgs<ExtArgs>>): Prisma__SavedFilterClient<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SavedFilter.
     * @param {SavedFilterUpdateArgs} args - Arguments to update one SavedFilter.
     * @example
     * // Update one SavedFilter
     * const savedFilter = await prisma.savedFilter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SavedFilterUpdateArgs>(args: SelectSubset<T, SavedFilterUpdateArgs<ExtArgs>>): Prisma__SavedFilterClient<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SavedFilters.
     * @param {SavedFilterDeleteManyArgs} args - Arguments to filter SavedFilters to delete.
     * @example
     * // Delete a few SavedFilters
     * const { count } = await prisma.savedFilter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SavedFilterDeleteManyArgs>(args?: SelectSubset<T, SavedFilterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedFilters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedFilterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SavedFilters
     * const savedFilter = await prisma.savedFilter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SavedFilterUpdateManyArgs>(args: SelectSubset<T, SavedFilterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedFilters and returns the data updated in the database.
     * @param {SavedFilterUpdateManyAndReturnArgs} args - Arguments to update many SavedFilters.
     * @example
     * // Update many SavedFilters
     * const savedFilter = await prisma.savedFilter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SavedFilters and only return the `id`
     * const savedFilterWithIdOnly = await prisma.savedFilter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SavedFilterUpdateManyAndReturnArgs>(args: SelectSubset<T, SavedFilterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SavedFilter.
     * @param {SavedFilterUpsertArgs} args - Arguments to update or create a SavedFilter.
     * @example
     * // Update or create a SavedFilter
     * const savedFilter = await prisma.savedFilter.upsert({
     *   create: {
     *     // ... data to create a SavedFilter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SavedFilter we want to update
     *   }
     * })
     */
    upsert<T extends SavedFilterUpsertArgs>(args: SelectSubset<T, SavedFilterUpsertArgs<ExtArgs>>): Prisma__SavedFilterClient<$Result.GetResult<Prisma.$SavedFilterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SavedFilters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedFilterCountArgs} args - Arguments to filter SavedFilters to count.
     * @example
     * // Count the number of SavedFilters
     * const count = await prisma.savedFilter.count({
     *   where: {
     *     // ... the filter for the SavedFilters we want to count
     *   }
     * })
    **/
    count<T extends SavedFilterCountArgs>(
      args?: Subset<T, SavedFilterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SavedFilterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SavedFilter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedFilterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SavedFilterAggregateArgs>(args: Subset<T, SavedFilterAggregateArgs>): Prisma.PrismaPromise<GetSavedFilterAggregateType<T>>

    /**
     * Group by SavedFilter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedFilterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SavedFilterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SavedFilterGroupByArgs['orderBy'] }
        : { orderBy?: SavedFilterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SavedFilterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSavedFilterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SavedFilter model
   */
  readonly fields: SavedFilterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SavedFilter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SavedFilterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SavedFilter model
   */
  interface SavedFilterFieldRefs {
    readonly id: FieldRef<"SavedFilter", 'String'>
    readonly name: FieldRef<"SavedFilter", 'String'>
    readonly userId: FieldRef<"SavedFilter", 'String'>
    readonly page: FieldRef<"SavedFilter", 'String'>
    readonly config: FieldRef<"SavedFilter", 'Json'>
    readonly createdAt: FieldRef<"SavedFilter", 'DateTime'>
    readonly updatedAt: FieldRef<"SavedFilter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SavedFilter findUnique
   */
  export type SavedFilterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * Filter, which SavedFilter to fetch.
     */
    where: SavedFilterWhereUniqueInput
  }

  /**
   * SavedFilter findUniqueOrThrow
   */
  export type SavedFilterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * Filter, which SavedFilter to fetch.
     */
    where: SavedFilterWhereUniqueInput
  }

  /**
   * SavedFilter findFirst
   */
  export type SavedFilterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * Filter, which SavedFilter to fetch.
     */
    where?: SavedFilterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedFilters to fetch.
     */
    orderBy?: SavedFilterOrderByWithRelationInput | SavedFilterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedFilters.
     */
    cursor?: SavedFilterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedFilters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedFilters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedFilters.
     */
    distinct?: SavedFilterScalarFieldEnum | SavedFilterScalarFieldEnum[]
  }

  /**
   * SavedFilter findFirstOrThrow
   */
  export type SavedFilterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * Filter, which SavedFilter to fetch.
     */
    where?: SavedFilterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedFilters to fetch.
     */
    orderBy?: SavedFilterOrderByWithRelationInput | SavedFilterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedFilters.
     */
    cursor?: SavedFilterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedFilters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedFilters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedFilters.
     */
    distinct?: SavedFilterScalarFieldEnum | SavedFilterScalarFieldEnum[]
  }

  /**
   * SavedFilter findMany
   */
  export type SavedFilterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * Filter, which SavedFilters to fetch.
     */
    where?: SavedFilterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedFilters to fetch.
     */
    orderBy?: SavedFilterOrderByWithRelationInput | SavedFilterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SavedFilters.
     */
    cursor?: SavedFilterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedFilters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedFilters.
     */
    skip?: number
    distinct?: SavedFilterScalarFieldEnum | SavedFilterScalarFieldEnum[]
  }

  /**
   * SavedFilter create
   */
  export type SavedFilterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * The data needed to create a SavedFilter.
     */
    data: XOR<SavedFilterCreateInput, SavedFilterUncheckedCreateInput>
  }

  /**
   * SavedFilter createMany
   */
  export type SavedFilterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SavedFilters.
     */
    data: SavedFilterCreateManyInput | SavedFilterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SavedFilter createManyAndReturn
   */
  export type SavedFilterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * The data used to create many SavedFilters.
     */
    data: SavedFilterCreateManyInput | SavedFilterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SavedFilter update
   */
  export type SavedFilterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * The data needed to update a SavedFilter.
     */
    data: XOR<SavedFilterUpdateInput, SavedFilterUncheckedUpdateInput>
    /**
     * Choose, which SavedFilter to update.
     */
    where: SavedFilterWhereUniqueInput
  }

  /**
   * SavedFilter updateMany
   */
  export type SavedFilterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SavedFilters.
     */
    data: XOR<SavedFilterUpdateManyMutationInput, SavedFilterUncheckedUpdateManyInput>
    /**
     * Filter which SavedFilters to update
     */
    where?: SavedFilterWhereInput
    /**
     * Limit how many SavedFilters to update.
     */
    limit?: number
  }

  /**
   * SavedFilter updateManyAndReturn
   */
  export type SavedFilterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * The data used to update SavedFilters.
     */
    data: XOR<SavedFilterUpdateManyMutationInput, SavedFilterUncheckedUpdateManyInput>
    /**
     * Filter which SavedFilters to update
     */
    where?: SavedFilterWhereInput
    /**
     * Limit how many SavedFilters to update.
     */
    limit?: number
  }

  /**
   * SavedFilter upsert
   */
  export type SavedFilterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * The filter to search for the SavedFilter to update in case it exists.
     */
    where: SavedFilterWhereUniqueInput
    /**
     * In case the SavedFilter found by the `where` argument doesn't exist, create a new SavedFilter with this data.
     */
    create: XOR<SavedFilterCreateInput, SavedFilterUncheckedCreateInput>
    /**
     * In case the SavedFilter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SavedFilterUpdateInput, SavedFilterUncheckedUpdateInput>
  }

  /**
   * SavedFilter delete
   */
  export type SavedFilterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
    /**
     * Filter which SavedFilter to delete.
     */
    where: SavedFilterWhereUniqueInput
  }

  /**
   * SavedFilter deleteMany
   */
  export type SavedFilterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedFilters to delete
     */
    where?: SavedFilterWhereInput
    /**
     * Limit how many SavedFilters to delete.
     */
    limit?: number
  }

  /**
   * SavedFilter without action
   */
  export type SavedFilterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedFilter
     */
    select?: SavedFilterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedFilter
     */
    omit?: SavedFilterOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    avatar: 'avatar',
    phone: 'phone',
    isActive: 'isActive',
    emailVerified: 'emailVerified',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    thumbnail: 'thumbnail',
    category: 'category',
    difficulty: 'difficulty',
    duration: 'duration',
    price: 'price',
    discountPrice: 'discountPrice',
    courseCode: 'courseCode',
    jobRoles: 'jobRoles',
    bannerUrl: 'bannerUrl',
    averageRating: 'averageRating',
    instructorId: 'instructorId',
    isPublished: 'isPublished',
    hasInterviewPrep: 'hasInterviewPrep',
    interviewPrice: 'interviewPrice',
    bundlePrice: 'bundlePrice',
    courseType: 'courseType',
    liveSchedule: 'liveSchedule',
    hybridConfig: 'hybridConfig',
    publishStatus: 'publishStatus',
    publishedAt: 'publishedAt',
    reviewNotes: 'reviewNotes',
    submittedForReviewAt: 'submittedForReviewAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const BatchScalarFieldEnum: {
    id: 'id',
    name: 'name',
    courseId: 'courseId',
    instructorId: 'instructorId',
    startDate: 'startDate',
    endDate: 'endDate',
    description: 'description',
    maxStudents: 'maxStudents',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BatchScalarFieldEnum = (typeof BatchScalarFieldEnum)[keyof typeof BatchScalarFieldEnum]


  export const AnnouncementScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    priority: 'priority',
    courseId: 'courseId',
    batchId: 'batchId',
    instructorId: 'instructorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnnouncementScalarFieldEnum = (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum]


  export const LessonCommentScalarFieldEnum: {
    id: 'id',
    lessonId: 'lessonId',
    userId: 'userId',
    content: 'content',
    parentId: 'parentId',
    isPinned: 'isPinned',
    isInstructorResponse: 'isInstructorResponse',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LessonCommentScalarFieldEnum = (typeof LessonCommentScalarFieldEnum)[keyof typeof LessonCommentScalarFieldEnum]


  export const ModuleScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    title: 'title',
    description: 'description',
    orderIndex: 'orderIndex',
    isPublished: 'isPublished',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModuleScalarFieldEnum = (typeof ModuleScalarFieldEnum)[keyof typeof ModuleScalarFieldEnum]


  export const LessonScalarFieldEnum: {
    id: 'id',
    moduleId: 'moduleId',
    title: 'title',
    content: 'content',
    videoUrl: 'videoUrl',
    duration: 'duration',
    order: 'order',
    type: 'type',
    isPublished: 'isPublished',
    isPreview: 'isPreview',
    settings: 'settings',
    resources: 'resources',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LessonScalarFieldEnum = (typeof LessonScalarFieldEnum)[keyof typeof LessonScalarFieldEnum]


  export const QuizScalarFieldEnum: {
    id: 'id',
    lessonId: 'lessonId',
    question: 'question',
    options: 'options',
    correctAnswer: 'correctAnswer',
    explanation: 'explanation',
    createdAt: 'createdAt'
  };

  export type QuizScalarFieldEnum = (typeof QuizScalarFieldEnum)[keyof typeof QuizScalarFieldEnum]


  export const AssignmentSubmissionScalarFieldEnum: {
    id: 'id',
    lessonId: 'lessonId',
    userId: 'userId',
    content: 'content',
    fileUrl: 'fileUrl',
    grade: 'grade',
    feedback: 'feedback',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssignmentSubmissionScalarFieldEnum = (typeof AssignmentSubmissionScalarFieldEnum)[keyof typeof AssignmentSubmissionScalarFieldEnum]


  export const EnrollmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    progress: 'progress',
    status: 'status',
    hasInterviewAccess: 'hasInterviewAccess',
    batchId: 'batchId',
    enrolledAt: 'enrolledAt',
    completedAt: 'completedAt'
  };

  export type EnrollmentScalarFieldEnum = (typeof EnrollmentScalarFieldEnum)[keyof typeof EnrollmentScalarFieldEnum]


  export const LessonProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    lessonId: 'lessonId',
    completed: 'completed',
    score: 'score',
    timeSpent: 'timeSpent',
    lastAccessedAt: 'lastAccessedAt'
  };

  export type LessonProgressScalarFieldEnum = (typeof LessonProgressScalarFieldEnum)[keyof typeof LessonProgressScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const InterviewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    domain: 'domain',
    company: 'company',
    role: 'role',
    technology: 'technology',
    jobDescription: 'jobDescription',
    resumeUrl: 'resumeUrl',
    difficulty: 'difficulty',
    panelCount: 'panelCount',
    linkedCourseId: 'linkedCourseId',
    duration: 'duration',
    selectedAvatars: 'selectedAvatars',
    status: 'status',
    scheduledAt: 'scheduledAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt'
  };

  export type InterviewScalarFieldEnum = (typeof InterviewScalarFieldEnum)[keyof typeof InterviewScalarFieldEnum]


  export const InterviewQuestionScalarFieldEnum: {
    id: 'id',
    interviewId: 'interviewId',
    avatarId: 'avatarId',
    question: 'question',
    type: 'type',
    order: 'order'
  };

  export type InterviewQuestionScalarFieldEnum = (typeof InterviewQuestionScalarFieldEnum)[keyof typeof InterviewQuestionScalarFieldEnum]


  export const InterviewResponseScalarFieldEnum: {
    id: 'id',
    interviewId: 'interviewId',
    questionId: 'questionId',
    transcript: 'transcript',
    code: 'code',
    videoUrl: 'videoUrl',
    audioUrl: 'audioUrl',
    duration: 'duration',
    respondedAt: 'respondedAt'
  };

  export type InterviewResponseScalarFieldEnum = (typeof InterviewResponseScalarFieldEnum)[keyof typeof InterviewResponseScalarFieldEnum]


  export const InterviewEvaluationScalarFieldEnum: {
    id: 'id',
    interviewId: 'interviewId',
    overallScore: 'overallScore',
    technicalScore: 'technicalScore',
    communicationScore: 'communicationScore',
    confidenceScore: 'confidenceScore',
    starMethodScore: 'starMethodScore',
    strengths: 'strengths',
    weaknesses: 'weaknesses',
    recommendations: 'recommendations',
    aiInsights: 'aiInsights',
    createdAt: 'createdAt'
  };

  export type InterviewEvaluationScalarFieldEnum = (typeof InterviewEvaluationScalarFieldEnum)[keyof typeof InterviewEvaluationScalarFieldEnum]


  export const AvatarScalarFieldEnum: {
    id: 'id',
    name: 'name',
    role: 'role',
    personality: 'personality',
    avatarUrl: 'avatarUrl',
    voiceId: 'voiceId',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type AvatarScalarFieldEnum = (typeof AvatarScalarFieldEnum)[keyof typeof AvatarScalarFieldEnum]


  export const KnowledgeBaseScalarFieldEnum: {
    id: 'id',
    domain: 'domain',
    topic: 'topic',
    content: 'content',
    answer: 'answer',
    difficulty: 'difficulty',
    type: 'type',
    codeSnippet: 'codeSnippet',
    tags: 'tags',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KnowledgeBaseScalarFieldEnum = (typeof KnowledgeBaseScalarFieldEnum)[keyof typeof KnowledgeBaseScalarFieldEnum]


  export const SystemPromptScalarFieldEnum: {
    id: 'id',
    role: 'role',
    prompt: 'prompt',
    isActive: 'isActive',
    updatedAt: 'updatedAt'
  };

  export type SystemPromptScalarFieldEnum = (typeof SystemPromptScalarFieldEnum)[keyof typeof SystemPromptScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    paymentId: 'paymentId',
    signature: 'signature',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    userId: 'userId',
    courseId: 'courseId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ForumCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    slug: 'slug',
    icon: 'icon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ForumCategoryScalarFieldEnum = (typeof ForumCategoryScalarFieldEnum)[keyof typeof ForumCategoryScalarFieldEnum]


  export const ForumPostScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    slug: 'slug',
    authorId: 'authorId',
    categoryId: 'categoryId',
    likes: 'likes',
    views: 'views',
    isPinned: 'isPinned',
    isSolved: 'isSolved',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ForumPostScalarFieldEnum = (typeof ForumPostScalarFieldEnum)[keyof typeof ForumPostScalarFieldEnum]


  export const ForumCommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    postId: 'postId',
    authorId: 'authorId',
    parentId: 'parentId',
    isSolution: 'isSolution',
    likes: 'likes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ForumCommentScalarFieldEnum = (typeof ForumCommentScalarFieldEnum)[keyof typeof ForumCommentScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isGroup: 'isGroup',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    senderId: 'senderId',
    content: 'content',
    readBy: 'readBy',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const CertificateScalarFieldEnum: {
    id: 'id',
    uniqueId: 'uniqueId',
    userId: 'userId',
    courseId: 'courseId',
    enrollmentId: 'enrollmentId',
    studentName: 'studentName',
    courseName: 'courseName',
    courseCategory: 'courseCategory',
    issueDate: 'issueDate',
    expiryDate: 'expiryDate',
    templateId: 'templateId',
    signatureUrl: 'signatureUrl',
    signatoryName: 'signatoryName',
    signatoryTitle: 'signatoryTitle',
    verificationUrl: 'verificationUrl',
    isValid: 'isValid',
    grade: 'grade',
    score: 'score',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CertificateScalarFieldEnum = (typeof CertificateScalarFieldEnum)[keyof typeof CertificateScalarFieldEnum]


  export const CertificateTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    designUrl: 'designUrl',
    previewUrl: 'previewUrl',
    isDefault: 'isDefault',
    isActive: 'isActive',
    layout: 'layout',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CertificateTemplateScalarFieldEnum = (typeof CertificateTemplateScalarFieldEnum)[keyof typeof CertificateTemplateScalarFieldEnum]


  export const CertificateSettingsScalarFieldEnum: {
    id: 'id',
    instituteId: 'instituteId',
    prefix: 'prefix',
    yearInId: 'yearInId',
    sequenceDigits: 'sequenceDigits',
    currentSequence: 'currentSequence',
    defaultSignatureUrl: 'defaultSignatureUrl',
    defaultSignatoryName: 'defaultSignatoryName',
    defaultSignatoryTitle: 'defaultSignatoryTitle',
    signaturePosition: 'signaturePosition',
    logoPosition: 'logoPosition',
    logoSize: 'logoSize',
    signatureSize: 'signatureSize',
    borderStyle: 'borderStyle',
    backgroundUrl: 'backgroundUrl',
    defaultValidityMonths: 'defaultValidityMonths',
    instituteName: 'instituteName',
    instituteLogoUrl: 'instituteLogoUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CertificateSettingsScalarFieldEnum = (typeof CertificateSettingsScalarFieldEnum)[keyof typeof CertificateSettingsScalarFieldEnum]


  export const AIProviderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    provider: 'provider',
    apiKey: 'apiKey',
    model: 'model',
    endpoint: 'endpoint',
    isActive: 'isActive',
    isDefault: 'isDefault',
    usageLimit: 'usageLimit',
    currentUsage: 'currentUsage',
    lastResetAt: 'lastResetAt',
    temperature: 'temperature',
    maxTokens: 'maxTokens',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AIProviderScalarFieldEnum = (typeof AIProviderScalarFieldEnum)[keyof typeof AIProviderScalarFieldEnum]


  export const AIUsageLogScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    userId: 'userId',
    feature: 'feature',
    tokensUsed: 'tokensUsed',
    promptHash: 'promptHash',
    createdAt: 'createdAt'
  };

  export type AIUsageLogScalarFieldEnum = (typeof AIUsageLogScalarFieldEnum)[keyof typeof AIUsageLogScalarFieldEnum]


  export const VideoIntegrationScalarFieldEnum: {
    id: 'id',
    platform: 'platform',
    name: 'name',
    clientId: 'clientId',
    clientSecret: 'clientSecret',
    apiKey: 'apiKey',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    tokenExpiry: 'tokenExpiry',
    isActive: 'isActive',
    webhookUrl: 'webhookUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VideoIntegrationScalarFieldEnum = (typeof VideoIntegrationScalarFieldEnum)[keyof typeof VideoIntegrationScalarFieldEnum]


  export const LiveClassScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    title: 'title',
    description: 'description',
    platform: 'platform',
    meetingLink: 'meetingLink',
    meetingId: 'meetingId',
    password: 'password',
    scheduledAt: 'scheduledAt',
    duration: 'duration',
    timezone: 'timezone',
    status: 'status',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    recordingUrl: 'recordingUrl',
    recordingPassword: 'recordingPassword',
    hostId: 'hostId',
    hostName: 'hostName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LiveClassScalarFieldEnum = (typeof LiveClassScalarFieldEnum)[keyof typeof LiveClassScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    college: 'college',
    qualification: 'qualification',
    dob: 'dob',
    location: 'location',
    gender: 'gender',
    source: 'source',
    status: 'status',
    notes: 'notes',
    assignedTo: 'assignedTo',
    platform: 'platform',
    campaignId: 'campaignId',
    adGroupId: 'adGroupId',
    adId: 'adId',
    formId: 'formId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const MarketingIntegrationScalarFieldEnum: {
    id: 'id',
    platform: 'platform',
    name: 'name',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    accountId: 'accountId',
    pageId: 'pageId',
    isActive: 'isActive',
    webhookSecret: 'webhookSecret',
    lastSyncAt: 'lastSyncAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MarketingIntegrationScalarFieldEnum = (typeof MarketingIntegrationScalarFieldEnum)[keyof typeof MarketingIntegrationScalarFieldEnum]


  export const EmailIntegrationScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    name: 'name',
    host: 'host',
    port: 'port',
    user: 'user',
    pass: 'pass',
    secure: 'secure',
    fromEmail: 'fromEmail',
    serviceId: 'serviceId',
    templateId: 'templateId',
    publicKey: 'publicKey',
    privateKey: 'privateKey',
    apiKey: 'apiKey',
    isActive: 'isActive',
    updatedAt: 'updatedAt'
  };

  export type EmailIntegrationScalarFieldEnum = (typeof EmailIntegrationScalarFieldEnum)[keyof typeof EmailIntegrationScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    dueDate: 'dueDate',
    assignedTo: 'assignedTo',
    createdBy: 'createdBy',
    leadId: 'leadId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const TaskCommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    taskId: 'taskId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type TaskCommentScalarFieldEnum = (typeof TaskCommentScalarFieldEnum)[keyof typeof TaskCommentScalarFieldEnum]


  export const BlogPostScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    content: 'content',
    summary: 'summary',
    coverImage: 'coverImage',
    status: 'status',
    tags: 'tags',
    authorId: 'authorId',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogPostScalarFieldEnum = (typeof BlogPostScalarFieldEnum)[keyof typeof BlogPostScalarFieldEnum]


  export const TicketScalarFieldEnum: {
    id: 'id',
    subject: 'subject',
    description: 'description',
    status: 'status',
    priority: 'priority',
    category: 'category',
    userId: 'userId',
    assignedTo: 'assignedTo',
    internalNotes: 'internalNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const TicketMessageScalarFieldEnum: {
    id: 'id',
    message: 'message',
    attachmentUrl: 'attachmentUrl',
    isStaffReply: 'isStaffReply',
    ticketId: 'ticketId',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type TicketMessageScalarFieldEnum = (typeof TicketMessageScalarFieldEnum)[keyof typeof TicketMessageScalarFieldEnum]


  export const PaymentConfigScalarFieldEnum: {
    id: 'id',
    razorpayKeyId: 'razorpayKeyId',
    razorpayKeySecret: 'razorpayKeySecret',
    stripePublishableKey: 'stripePublishableKey',
    stripeSecretKey: 'stripeSecretKey',
    activeGateway: 'activeGateway',
    currency: 'currency',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentConfigScalarFieldEnum = (typeof PaymentConfigScalarFieldEnum)[keyof typeof PaymentConfigScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    amount: 'amount',
    category: 'category',
    description: 'description',
    date: 'date',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const SystemSettingsScalarFieldEnum: {
    id: 'id',
    platformName: 'platformName',
    supportEmail: 'supportEmail',
    logoUrl: 'logoUrl',
    faviconUrl: 'faviconUrl',
    primaryColor: 'primaryColor',
    isMaintenanceMode: 'isMaintenanceMode',
    address: 'address',
    phone: 'phone',
    updatedAt: 'updatedAt'
  };

  export type SystemSettingsScalarFieldEnum = (typeof SystemSettingsScalarFieldEnum)[keyof typeof SystemSettingsScalarFieldEnum]


  export const EmployerProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyName: 'companyName',
    website: 'website',
    description: 'description',
    logo: 'logo',
    location: 'location',
    industry: 'industry',
    companySize: 'companySize',
    status: 'status',
    documentsVerified: 'documentsVerified',
    verificationNotes: 'verificationNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployerProfileScalarFieldEnum = (typeof EmployerProfileScalarFieldEnum)[keyof typeof EmployerProfileScalarFieldEnum]


  export const JobScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    requirements: 'requirements',
    location: 'location',
    type: 'type',
    experience: 'experience',
    salary: 'salary',
    skills: 'skills',
    clientName: 'clientName',
    shift: 'shift',
    domain: 'domain',
    qualification: 'qualification',
    employerId: 'employerId',
    status: 'status',
    publishedAt: 'publishedAt',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JobScalarFieldEnum = (typeof JobScalarFieldEnum)[keyof typeof JobScalarFieldEnum]


  export const JobApplicationScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    applicantId: 'applicantId',
    source: 'source',
    externalName: 'externalName',
    externalEmail: 'externalEmail',
    externalPhone: 'externalPhone',
    resumeUrl: 'resumeUrl',
    coverLetter: 'coverLetter',
    resumeParsedText: 'resumeParsedText',
    atsScore: 'atsScore',
    status: 'status',
    statusHistory: 'statusHistory',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JobApplicationScalarFieldEnum = (typeof JobApplicationScalarFieldEnum)[keyof typeof JobApplicationScalarFieldEnum]


  export const JobInterviewScalarFieldEnum: {
    id: 'id',
    applicationId: 'applicationId',
    roundName: 'roundName',
    roundType: 'roundType',
    scheduledAt: 'scheduledAt',
    duration: 'duration',
    meetingLink: 'meetingLink',
    location: 'location',
    interviewerId: 'interviewerId',
    status: 'status',
    feedback: 'feedback',
    score: 'score',
    result: 'result',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JobInterviewScalarFieldEnum = (typeof JobInterviewScalarFieldEnum)[keyof typeof JobInterviewScalarFieldEnum]


  export const EmailLogScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    applicationId: 'applicationId',
    recipientEmail: 'recipientEmail',
    recipientName: 'recipientName',
    templateName: 'templateName',
    subject: 'subject',
    body: 'body',
    status: 'status',
    sentAt: 'sentAt',
    error: 'error',
    triggeredBy: 'triggeredBy'
  };

  export type EmailLogScalarFieldEnum = (typeof EmailLogScalarFieldEnum)[keyof typeof EmailLogScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    action: 'action',
    method: 'method',
    path: 'path',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    oldValue: 'oldValue',
    newValue: 'newValue',
    applicationId: 'applicationId',
    performedBy: 'performedBy',
    details: 'details',
    timestamp: 'timestamp'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SavedFilterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    userId: 'userId',
    page: 'page',
    config: 'config',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SavedFilterScalarFieldEnum = (typeof SavedFilterScalarFieldEnum)[keyof typeof SavedFilterScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Difficulty'
   */
  export type EnumDifficultyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Difficulty'>
    


  /**
   * Reference to a field of type 'Difficulty[]'
   */
  export type ListEnumDifficultyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Difficulty[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'CourseType'
   */
  export type EnumCourseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseType'>
    


  /**
   * Reference to a field of type 'CourseType[]'
   */
  export type ListEnumCourseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseType[]'>
    


  /**
   * Reference to a field of type 'PublishStatus'
   */
  export type EnumPublishStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublishStatus'>
    


  /**
   * Reference to a field of type 'PublishStatus[]'
   */
  export type ListEnumPublishStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublishStatus[]'>
    


  /**
   * Reference to a field of type 'LessonType'
   */
  export type EnumLessonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LessonType'>
    


  /**
   * Reference to a field of type 'LessonType[]'
   */
  export type ListEnumLessonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LessonType[]'>
    


  /**
   * Reference to a field of type 'EnrollmentStatus'
   */
  export type EnumEnrollmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnrollmentStatus'>
    


  /**
   * Reference to a field of type 'EnrollmentStatus[]'
   */
  export type ListEnumEnrollmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnrollmentStatus[]'>
    


  /**
   * Reference to a field of type 'InterviewStatus'
   */
  export type EnumInterviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterviewStatus'>
    


  /**
   * Reference to a field of type 'InterviewStatus[]'
   */
  export type ListEnumInterviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterviewStatus[]'>
    


  /**
   * Reference to a field of type 'QuestionType'
   */
  export type EnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType'>
    


  /**
   * Reference to a field of type 'QuestionType[]'
   */
  export type ListEnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType[]'>
    


  /**
   * Reference to a field of type 'KnowledgeStatus'
   */
  export type EnumKnowledgeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KnowledgeStatus'>
    


  /**
   * Reference to a field of type 'KnowledgeStatus[]'
   */
  export type ListEnumKnowledgeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KnowledgeStatus[]'>
    


  /**
   * Reference to a field of type 'LiveClassStatus'
   */
  export type EnumLiveClassStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LiveClassStatus'>
    


  /**
   * Reference to a field of type 'LiveClassStatus[]'
   */
  export type ListEnumLiveClassStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LiveClassStatus[]'>
    


  /**
   * Reference to a field of type 'LeadStatus'
   */
  export type EnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus'>
    


  /**
   * Reference to a field of type 'LeadStatus[]'
   */
  export type ListEnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'BlogStatus'
   */
  export type EnumBlogStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BlogStatus'>
    


  /**
   * Reference to a field of type 'BlogStatus[]'
   */
  export type ListEnumBlogStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BlogStatus[]'>
    


  /**
   * Reference to a field of type 'TicketStatus'
   */
  export type EnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus'>
    


  /**
   * Reference to a field of type 'TicketStatus[]'
   */
  export type ListEnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus[]'>
    


  /**
   * Reference to a field of type 'TicketPriority'
   */
  export type EnumTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketPriority'>
    


  /**
   * Reference to a field of type 'TicketPriority[]'
   */
  export type ListEnumTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketPriority[]'>
    


  /**
   * Reference to a field of type 'TicketCategory'
   */
  export type EnumTicketCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketCategory'>
    


  /**
   * Reference to a field of type 'TicketCategory[]'
   */
  export type ListEnumTicketCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketCategory[]'>
    


  /**
   * Reference to a field of type 'Gateway'
   */
  export type EnumGatewayFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gateway'>
    


  /**
   * Reference to a field of type 'Gateway[]'
   */
  export type ListEnumGatewayFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gateway[]'>
    


  /**
   * Reference to a field of type 'EmployerStatus'
   */
  export type EnumEmployerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployerStatus'>
    


  /**
   * Reference to a field of type 'EmployerStatus[]'
   */
  export type ListEnumEmployerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployerStatus[]'>
    


  /**
   * Reference to a field of type 'JobType'
   */
  export type EnumJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobType'>
    


  /**
   * Reference to a field of type 'JobType[]'
   */
  export type ListEnumJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobType[]'>
    


  /**
   * Reference to a field of type 'JobStatus'
   */
  export type EnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus'>
    


  /**
   * Reference to a field of type 'JobStatus[]'
   */
  export type ListEnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus[]'>
    


  /**
   * Reference to a field of type 'CandidateSource'
   */
  export type EnumCandidateSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CandidateSource'>
    


  /**
   * Reference to a field of type 'CandidateSource[]'
   */
  export type ListEnumCandidateSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CandidateSource[]'>
    


  /**
   * Reference to a field of type 'ApplicationStatus'
   */
  export type EnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus'>
    


  /**
   * Reference to a field of type 'ApplicationStatus[]'
   */
  export type ListEnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus[]'>
    


  /**
   * Reference to a field of type 'InterviewRoundType'
   */
  export type EnumInterviewRoundTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterviewRoundType'>
    


  /**
   * Reference to a field of type 'InterviewRoundType[]'
   */
  export type ListEnumInterviewRoundTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterviewRoundType[]'>
    


  /**
   * Reference to a field of type 'InterviewResult'
   */
  export type EnumInterviewResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterviewResult'>
    


  /**
   * Reference to a field of type 'InterviewResult[]'
   */
  export type ListEnumInterviewResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterviewResult[]'>
    


  /**
   * Reference to a field of type 'EmailStatus'
   */
  export type EnumEmailStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailStatus'>
    


  /**
   * Reference to a field of type 'EmailStatus[]'
   */
  export type ListEnumEmailStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    avatar?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    emailVerified?: BoolFilter<"User"> | boolean
    permissions?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    enrollments?: EnrollmentListRelationFilter
    interviews?: InterviewListRelationFilter
    lessonProgress?: LessonProgressListRelationFilter
    posts?: ForumPostListRelationFilter
    comments?: ForumCommentListRelationFilter
    conversations?: ConversationListRelationFilter
    sentMessages?: MessageListRelationFilter
    payments?: PaymentListRelationFilter
    certificates?: CertificateListRelationFilter
    reviews?: ReviewListRelationFilter
    tickets?: TicketListRelationFilter
    sentTicketMessages?: TicketMessageListRelationFilter
    employerProfile?: XOR<EmployerProfileNullableScalarRelationFilter, EmployerProfileWhereInput> | null
    jobs?: JobListRelationFilter
    applications?: JobApplicationListRelationFilter
    assignedTasks?: TaskListRelationFilter
    createdTasks?: TaskListRelationFilter
    blogPosts?: BlogPostListRelationFilter
    taskComments?: TaskCommentListRelationFilter
    assignmentSubmissions?: AssignmentSubmissionListRelationFilter
    lessonComments?: LessonCommentListRelationFilter
    instructedBatches?: BatchListRelationFilter
    announcements?: AnnouncementListRelationFilter
    conductedJobInterviews?: JobInterviewListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    avatar?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    enrollments?: EnrollmentOrderByRelationAggregateInput
    interviews?: InterviewOrderByRelationAggregateInput
    lessonProgress?: LessonProgressOrderByRelationAggregateInput
    posts?: ForumPostOrderByRelationAggregateInput
    comments?: ForumCommentOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    certificates?: CertificateOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
    sentTicketMessages?: TicketMessageOrderByRelationAggregateInput
    employerProfile?: EmployerProfileOrderByWithRelationInput
    jobs?: JobOrderByRelationAggregateInput
    applications?: JobApplicationOrderByRelationAggregateInput
    assignedTasks?: TaskOrderByRelationAggregateInput
    createdTasks?: TaskOrderByRelationAggregateInput
    blogPosts?: BlogPostOrderByRelationAggregateInput
    taskComments?: TaskCommentOrderByRelationAggregateInput
    assignmentSubmissions?: AssignmentSubmissionOrderByRelationAggregateInput
    lessonComments?: LessonCommentOrderByRelationAggregateInput
    instructedBatches?: BatchOrderByRelationAggregateInput
    announcements?: AnnouncementOrderByRelationAggregateInput
    conductedJobInterviews?: JobInterviewOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    avatar?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    emailVerified?: BoolFilter<"User"> | boolean
    permissions?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    enrollments?: EnrollmentListRelationFilter
    interviews?: InterviewListRelationFilter
    lessonProgress?: LessonProgressListRelationFilter
    posts?: ForumPostListRelationFilter
    comments?: ForumCommentListRelationFilter
    conversations?: ConversationListRelationFilter
    sentMessages?: MessageListRelationFilter
    payments?: PaymentListRelationFilter
    certificates?: CertificateListRelationFilter
    reviews?: ReviewListRelationFilter
    tickets?: TicketListRelationFilter
    sentTicketMessages?: TicketMessageListRelationFilter
    employerProfile?: XOR<EmployerProfileNullableScalarRelationFilter, EmployerProfileWhereInput> | null
    jobs?: JobListRelationFilter
    applications?: JobApplicationListRelationFilter
    assignedTasks?: TaskListRelationFilter
    createdTasks?: TaskListRelationFilter
    blogPosts?: BlogPostListRelationFilter
    taskComments?: TaskCommentListRelationFilter
    assignmentSubmissions?: AssignmentSubmissionListRelationFilter
    lessonComments?: LessonCommentListRelationFilter
    instructedBatches?: BatchListRelationFilter
    announcements?: AnnouncementListRelationFilter
    conductedJobInterviews?: JobInterviewListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    avatar?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    permissions?: JsonNullableWithAggregatesFilter<"User">
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    thumbnail?: StringNullableFilter<"Course"> | string | null
    category?: StringFilter<"Course"> | string
    difficulty?: EnumDifficultyFilter<"Course"> | $Enums.Difficulty
    duration?: IntFilter<"Course"> | number
    price?: DecimalFilter<"Course"> | Decimal | DecimalJsLike | number | string
    discountPrice?: DecimalFilter<"Course"> | Decimal | DecimalJsLike | number | string
    courseCode?: StringNullableFilter<"Course"> | string | null
    jobRoles?: JsonNullableFilter<"Course">
    bannerUrl?: StringNullableFilter<"Course"> | string | null
    averageRating?: FloatFilter<"Course"> | number
    instructorId?: StringFilter<"Course"> | string
    isPublished?: BoolFilter<"Course"> | boolean
    hasInterviewPrep?: BoolFilter<"Course"> | boolean
    interviewPrice?: DecimalFilter<"Course"> | Decimal | DecimalJsLike | number | string
    bundlePrice?: DecimalFilter<"Course"> | Decimal | DecimalJsLike | number | string
    courseType?: EnumCourseTypeFilter<"Course"> | $Enums.CourseType
    liveSchedule?: JsonNullableFilter<"Course">
    hybridConfig?: JsonNullableFilter<"Course">
    publishStatus?: EnumPublishStatusFilter<"Course"> | $Enums.PublishStatus
    publishedAt?: DateTimeNullableFilter<"Course"> | Date | string | null
    reviewNotes?: StringNullableFilter<"Course"> | string | null
    submittedForReviewAt?: DateTimeNullableFilter<"Course"> | Date | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    modules?: ModuleListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    payments?: PaymentListRelationFilter
    reviews?: ReviewListRelationFilter
    liveClasses?: LiveClassListRelationFilter
    batches?: BatchListRelationFilter
    announcements?: AnnouncementListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    discountPrice?: SortOrder
    courseCode?: SortOrderInput | SortOrder
    jobRoles?: SortOrderInput | SortOrder
    bannerUrl?: SortOrderInput | SortOrder
    averageRating?: SortOrder
    instructorId?: SortOrder
    isPublished?: SortOrder
    hasInterviewPrep?: SortOrder
    interviewPrice?: SortOrder
    bundlePrice?: SortOrder
    courseType?: SortOrder
    liveSchedule?: SortOrderInput | SortOrder
    hybridConfig?: SortOrderInput | SortOrder
    publishStatus?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    submittedForReviewAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    modules?: ModuleOrderByRelationAggregateInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    liveClasses?: LiveClassOrderByRelationAggregateInput
    batches?: BatchOrderByRelationAggregateInput
    announcements?: AnnouncementOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    courseCode?: string
    title_instructorId?: CourseTitleInstructorIdCompoundUniqueInput
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    title?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    thumbnail?: StringNullableFilter<"Course"> | string | null
    category?: StringFilter<"Course"> | string
    difficulty?: EnumDifficultyFilter<"Course"> | $Enums.Difficulty
    duration?: IntFilter<"Course"> | number
    price?: DecimalFilter<"Course"> | Decimal | DecimalJsLike | number | string
    discountPrice?: DecimalFilter<"Course"> | Decimal | DecimalJsLike | number | string
    jobRoles?: JsonNullableFilter<"Course">
    bannerUrl?: StringNullableFilter<"Course"> | string | null
    averageRating?: FloatFilter<"Course"> | number
    instructorId?: StringFilter<"Course"> | string
    isPublished?: BoolFilter<"Course"> | boolean
    hasInterviewPrep?: BoolFilter<"Course"> | boolean
    interviewPrice?: DecimalFilter<"Course"> | Decimal | DecimalJsLike | number | string
    bundlePrice?: DecimalFilter<"Course"> | Decimal | DecimalJsLike | number | string
    courseType?: EnumCourseTypeFilter<"Course"> | $Enums.CourseType
    liveSchedule?: JsonNullableFilter<"Course">
    hybridConfig?: JsonNullableFilter<"Course">
    publishStatus?: EnumPublishStatusFilter<"Course"> | $Enums.PublishStatus
    publishedAt?: DateTimeNullableFilter<"Course"> | Date | string | null
    reviewNotes?: StringNullableFilter<"Course"> | string | null
    submittedForReviewAt?: DateTimeNullableFilter<"Course"> | Date | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    modules?: ModuleListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    payments?: PaymentListRelationFilter
    reviews?: ReviewListRelationFilter
    liveClasses?: LiveClassListRelationFilter
    batches?: BatchListRelationFilter
    announcements?: AnnouncementListRelationFilter
  }, "id" | "courseCode" | "title_instructorId">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    discountPrice?: SortOrder
    courseCode?: SortOrderInput | SortOrder
    jobRoles?: SortOrderInput | SortOrder
    bannerUrl?: SortOrderInput | SortOrder
    averageRating?: SortOrder
    instructorId?: SortOrder
    isPublished?: SortOrder
    hasInterviewPrep?: SortOrder
    interviewPrice?: SortOrder
    bundlePrice?: SortOrder
    courseType?: SortOrder
    liveSchedule?: SortOrderInput | SortOrder
    hybridConfig?: SortOrderInput | SortOrder
    publishStatus?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    submittedForReviewAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    title?: StringWithAggregatesFilter<"Course"> | string
    description?: StringWithAggregatesFilter<"Course"> | string
    thumbnail?: StringNullableWithAggregatesFilter<"Course"> | string | null
    category?: StringWithAggregatesFilter<"Course"> | string
    difficulty?: EnumDifficultyWithAggregatesFilter<"Course"> | $Enums.Difficulty
    duration?: IntWithAggregatesFilter<"Course"> | number
    price?: DecimalWithAggregatesFilter<"Course"> | Decimal | DecimalJsLike | number | string
    discountPrice?: DecimalWithAggregatesFilter<"Course"> | Decimal | DecimalJsLike | number | string
    courseCode?: StringNullableWithAggregatesFilter<"Course"> | string | null
    jobRoles?: JsonNullableWithAggregatesFilter<"Course">
    bannerUrl?: StringNullableWithAggregatesFilter<"Course"> | string | null
    averageRating?: FloatWithAggregatesFilter<"Course"> | number
    instructorId?: StringWithAggregatesFilter<"Course"> | string
    isPublished?: BoolWithAggregatesFilter<"Course"> | boolean
    hasInterviewPrep?: BoolWithAggregatesFilter<"Course"> | boolean
    interviewPrice?: DecimalWithAggregatesFilter<"Course"> | Decimal | DecimalJsLike | number | string
    bundlePrice?: DecimalWithAggregatesFilter<"Course"> | Decimal | DecimalJsLike | number | string
    courseType?: EnumCourseTypeWithAggregatesFilter<"Course"> | $Enums.CourseType
    liveSchedule?: JsonNullableWithAggregatesFilter<"Course">
    hybridConfig?: JsonNullableWithAggregatesFilter<"Course">
    publishStatus?: EnumPublishStatusWithAggregatesFilter<"Course"> | $Enums.PublishStatus
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Course"> | Date | string | null
    reviewNotes?: StringNullableWithAggregatesFilter<"Course"> | string | null
    submittedForReviewAt?: DateTimeNullableWithAggregatesFilter<"Course"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
  }

  export type BatchWhereInput = {
    AND?: BatchWhereInput | BatchWhereInput[]
    OR?: BatchWhereInput[]
    NOT?: BatchWhereInput | BatchWhereInput[]
    id?: StringFilter<"Batch"> | string
    name?: StringFilter<"Batch"> | string
    courseId?: StringFilter<"Batch"> | string
    instructorId?: StringFilter<"Batch"> | string
    startDate?: DateTimeNullableFilter<"Batch"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Batch"> | Date | string | null
    description?: StringNullableFilter<"Batch"> | string | null
    maxStudents?: IntNullableFilter<"Batch"> | number | null
    createdAt?: DateTimeFilter<"Batch"> | Date | string
    updatedAt?: DateTimeFilter<"Batch"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    instructor?: XOR<UserScalarRelationFilter, UserWhereInput>
    announcements?: AnnouncementListRelationFilter
    enrollments?: EnrollmentListRelationFilter
  }

  export type BatchOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    courseId?: SortOrder
    instructorId?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    maxStudents?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    course?: CourseOrderByWithRelationInput
    instructor?: UserOrderByWithRelationInput
    announcements?: AnnouncementOrderByRelationAggregateInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
  }

  export type BatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BatchWhereInput | BatchWhereInput[]
    OR?: BatchWhereInput[]
    NOT?: BatchWhereInput | BatchWhereInput[]
    name?: StringFilter<"Batch"> | string
    courseId?: StringFilter<"Batch"> | string
    instructorId?: StringFilter<"Batch"> | string
    startDate?: DateTimeNullableFilter<"Batch"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Batch"> | Date | string | null
    description?: StringNullableFilter<"Batch"> | string | null
    maxStudents?: IntNullableFilter<"Batch"> | number | null
    createdAt?: DateTimeFilter<"Batch"> | Date | string
    updatedAt?: DateTimeFilter<"Batch"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    instructor?: XOR<UserScalarRelationFilter, UserWhereInput>
    announcements?: AnnouncementListRelationFilter
    enrollments?: EnrollmentListRelationFilter
  }, "id">

  export type BatchOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    courseId?: SortOrder
    instructorId?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    maxStudents?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BatchCountOrderByAggregateInput
    _avg?: BatchAvgOrderByAggregateInput
    _max?: BatchMaxOrderByAggregateInput
    _min?: BatchMinOrderByAggregateInput
    _sum?: BatchSumOrderByAggregateInput
  }

  export type BatchScalarWhereWithAggregatesInput = {
    AND?: BatchScalarWhereWithAggregatesInput | BatchScalarWhereWithAggregatesInput[]
    OR?: BatchScalarWhereWithAggregatesInput[]
    NOT?: BatchScalarWhereWithAggregatesInput | BatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Batch"> | string
    name?: StringWithAggregatesFilter<"Batch"> | string
    courseId?: StringWithAggregatesFilter<"Batch"> | string
    instructorId?: StringWithAggregatesFilter<"Batch"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"Batch"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Batch"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"Batch"> | string | null
    maxStudents?: IntNullableWithAggregatesFilter<"Batch"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Batch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Batch"> | Date | string
  }

  export type AnnouncementWhereInput = {
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    id?: StringFilter<"Announcement"> | string
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    priority?: StringFilter<"Announcement"> | string
    courseId?: StringNullableFilter<"Announcement"> | string | null
    batchId?: StringNullableFilter<"Announcement"> | string | null
    instructorId?: StringFilter<"Announcement"> | string
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeFilter<"Announcement"> | Date | string
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    batch?: XOR<BatchNullableScalarRelationFilter, BatchWhereInput> | null
    instructor?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AnnouncementOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    priority?: SortOrder
    courseId?: SortOrderInput | SortOrder
    batchId?: SortOrderInput | SortOrder
    instructorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    course?: CourseOrderByWithRelationInput
    batch?: BatchOrderByWithRelationInput
    instructor?: UserOrderByWithRelationInput
  }

  export type AnnouncementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    priority?: StringFilter<"Announcement"> | string
    courseId?: StringNullableFilter<"Announcement"> | string | null
    batchId?: StringNullableFilter<"Announcement"> | string | null
    instructorId?: StringFilter<"Announcement"> | string
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeFilter<"Announcement"> | Date | string
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    batch?: XOR<BatchNullableScalarRelationFilter, BatchWhereInput> | null
    instructor?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AnnouncementOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    priority?: SortOrder
    courseId?: SortOrderInput | SortOrder
    batchId?: SortOrderInput | SortOrder
    instructorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnnouncementCountOrderByAggregateInput
    _max?: AnnouncementMaxOrderByAggregateInput
    _min?: AnnouncementMinOrderByAggregateInput
  }

  export type AnnouncementScalarWhereWithAggregatesInput = {
    AND?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    OR?: AnnouncementScalarWhereWithAggregatesInput[]
    NOT?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Announcement"> | string
    title?: StringWithAggregatesFilter<"Announcement"> | string
    content?: StringWithAggregatesFilter<"Announcement"> | string
    priority?: StringWithAggregatesFilter<"Announcement"> | string
    courseId?: StringNullableWithAggregatesFilter<"Announcement"> | string | null
    batchId?: StringNullableWithAggregatesFilter<"Announcement"> | string | null
    instructorId?: StringWithAggregatesFilter<"Announcement"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
  }

  export type LessonCommentWhereInput = {
    AND?: LessonCommentWhereInput | LessonCommentWhereInput[]
    OR?: LessonCommentWhereInput[]
    NOT?: LessonCommentWhereInput | LessonCommentWhereInput[]
    id?: StringFilter<"LessonComment"> | string
    lessonId?: StringFilter<"LessonComment"> | string
    userId?: StringFilter<"LessonComment"> | string
    content?: StringFilter<"LessonComment"> | string
    parentId?: StringNullableFilter<"LessonComment"> | string | null
    isPinned?: BoolFilter<"LessonComment"> | boolean
    isInstructorResponse?: BoolFilter<"LessonComment"> | boolean
    createdAt?: DateTimeFilter<"LessonComment"> | Date | string
    updatedAt?: DateTimeFilter<"LessonComment"> | Date | string
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<LessonCommentNullableScalarRelationFilter, LessonCommentWhereInput> | null
    replies?: LessonCommentListRelationFilter
  }

  export type LessonCommentOrderByWithRelationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    parentId?: SortOrderInput | SortOrder
    isPinned?: SortOrder
    isInstructorResponse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lesson?: LessonOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    parent?: LessonCommentOrderByWithRelationInput
    replies?: LessonCommentOrderByRelationAggregateInput
  }

  export type LessonCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LessonCommentWhereInput | LessonCommentWhereInput[]
    OR?: LessonCommentWhereInput[]
    NOT?: LessonCommentWhereInput | LessonCommentWhereInput[]
    lessonId?: StringFilter<"LessonComment"> | string
    userId?: StringFilter<"LessonComment"> | string
    content?: StringFilter<"LessonComment"> | string
    parentId?: StringNullableFilter<"LessonComment"> | string | null
    isPinned?: BoolFilter<"LessonComment"> | boolean
    isInstructorResponse?: BoolFilter<"LessonComment"> | boolean
    createdAt?: DateTimeFilter<"LessonComment"> | Date | string
    updatedAt?: DateTimeFilter<"LessonComment"> | Date | string
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<LessonCommentNullableScalarRelationFilter, LessonCommentWhereInput> | null
    replies?: LessonCommentListRelationFilter
  }, "id">

  export type LessonCommentOrderByWithAggregationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    parentId?: SortOrderInput | SortOrder
    isPinned?: SortOrder
    isInstructorResponse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LessonCommentCountOrderByAggregateInput
    _max?: LessonCommentMaxOrderByAggregateInput
    _min?: LessonCommentMinOrderByAggregateInput
  }

  export type LessonCommentScalarWhereWithAggregatesInput = {
    AND?: LessonCommentScalarWhereWithAggregatesInput | LessonCommentScalarWhereWithAggregatesInput[]
    OR?: LessonCommentScalarWhereWithAggregatesInput[]
    NOT?: LessonCommentScalarWhereWithAggregatesInput | LessonCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LessonComment"> | string
    lessonId?: StringWithAggregatesFilter<"LessonComment"> | string
    userId?: StringWithAggregatesFilter<"LessonComment"> | string
    content?: StringWithAggregatesFilter<"LessonComment"> | string
    parentId?: StringNullableWithAggregatesFilter<"LessonComment"> | string | null
    isPinned?: BoolWithAggregatesFilter<"LessonComment"> | boolean
    isInstructorResponse?: BoolWithAggregatesFilter<"LessonComment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LessonComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LessonComment"> | Date | string
  }

  export type ModuleWhereInput = {
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    id?: StringFilter<"Module"> | string
    courseId?: StringFilter<"Module"> | string
    title?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    orderIndex?: IntFilter<"Module"> | number
    isPublished?: BoolFilter<"Module"> | boolean
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    lessons?: LessonListRelationFilter
  }

  export type ModuleOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    orderIndex?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    course?: CourseOrderByWithRelationInput
    lessons?: LessonOrderByRelationAggregateInput
  }

  export type ModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    courseId_orderIndex?: ModuleCourseIdOrderIndexCompoundUniqueInput
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    courseId?: StringFilter<"Module"> | string
    title?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    orderIndex?: IntFilter<"Module"> | number
    isPublished?: BoolFilter<"Module"> | boolean
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    lessons?: LessonListRelationFilter
  }, "id" | "courseId_orderIndex">

  export type ModuleOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    orderIndex?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModuleCountOrderByAggregateInput
    _avg?: ModuleAvgOrderByAggregateInput
    _max?: ModuleMaxOrderByAggregateInput
    _min?: ModuleMinOrderByAggregateInput
    _sum?: ModuleSumOrderByAggregateInput
  }

  export type ModuleScalarWhereWithAggregatesInput = {
    AND?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    OR?: ModuleScalarWhereWithAggregatesInput[]
    NOT?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Module"> | string
    courseId?: StringWithAggregatesFilter<"Module"> | string
    title?: StringWithAggregatesFilter<"Module"> | string
    description?: StringNullableWithAggregatesFilter<"Module"> | string | null
    orderIndex?: IntWithAggregatesFilter<"Module"> | number
    isPublished?: BoolWithAggregatesFilter<"Module"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
  }

  export type LessonWhereInput = {
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    id?: StringFilter<"Lesson"> | string
    moduleId?: StringFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    content?: StringNullableFilter<"Lesson"> | string | null
    videoUrl?: StringNullableFilter<"Lesson"> | string | null
    duration?: IntNullableFilter<"Lesson"> | number | null
    order?: IntFilter<"Lesson"> | number
    type?: EnumLessonTypeFilter<"Lesson"> | $Enums.LessonType
    isPublished?: BoolFilter<"Lesson"> | boolean
    isPreview?: BoolFilter<"Lesson"> | boolean
    settings?: JsonNullableFilter<"Lesson">
    resources?: JsonNullableFilter<"Lesson">
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    quizzes?: QuizListRelationFilter
    progress?: LessonProgressListRelationFilter
    comments?: LessonCommentListRelationFilter
    assignmentSubmissions?: AssignmentSubmissionListRelationFilter
  }

  export type LessonOrderByWithRelationInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    order?: SortOrder
    type?: SortOrder
    isPublished?: SortOrder
    isPreview?: SortOrder
    settings?: SortOrderInput | SortOrder
    resources?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    module?: ModuleOrderByWithRelationInput
    quizzes?: QuizOrderByRelationAggregateInput
    progress?: LessonProgressOrderByRelationAggregateInput
    comments?: LessonCommentOrderByRelationAggregateInput
    assignmentSubmissions?: AssignmentSubmissionOrderByRelationAggregateInput
  }

  export type LessonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    moduleId?: StringFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    content?: StringNullableFilter<"Lesson"> | string | null
    videoUrl?: StringNullableFilter<"Lesson"> | string | null
    duration?: IntNullableFilter<"Lesson"> | number | null
    order?: IntFilter<"Lesson"> | number
    type?: EnumLessonTypeFilter<"Lesson"> | $Enums.LessonType
    isPublished?: BoolFilter<"Lesson"> | boolean
    isPreview?: BoolFilter<"Lesson"> | boolean
    settings?: JsonNullableFilter<"Lesson">
    resources?: JsonNullableFilter<"Lesson">
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    quizzes?: QuizListRelationFilter
    progress?: LessonProgressListRelationFilter
    comments?: LessonCommentListRelationFilter
    assignmentSubmissions?: AssignmentSubmissionListRelationFilter
  }, "id">

  export type LessonOrderByWithAggregationInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    order?: SortOrder
    type?: SortOrder
    isPublished?: SortOrder
    isPreview?: SortOrder
    settings?: SortOrderInput | SortOrder
    resources?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LessonCountOrderByAggregateInput
    _avg?: LessonAvgOrderByAggregateInput
    _max?: LessonMaxOrderByAggregateInput
    _min?: LessonMinOrderByAggregateInput
    _sum?: LessonSumOrderByAggregateInput
  }

  export type LessonScalarWhereWithAggregatesInput = {
    AND?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    OR?: LessonScalarWhereWithAggregatesInput[]
    NOT?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lesson"> | string
    moduleId?: StringWithAggregatesFilter<"Lesson"> | string
    title?: StringWithAggregatesFilter<"Lesson"> | string
    content?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    videoUrl?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    duration?: IntNullableWithAggregatesFilter<"Lesson"> | number | null
    order?: IntWithAggregatesFilter<"Lesson"> | number
    type?: EnumLessonTypeWithAggregatesFilter<"Lesson"> | $Enums.LessonType
    isPublished?: BoolWithAggregatesFilter<"Lesson"> | boolean
    isPreview?: BoolWithAggregatesFilter<"Lesson"> | boolean
    settings?: JsonNullableWithAggregatesFilter<"Lesson">
    resources?: JsonNullableWithAggregatesFilter<"Lesson">
    createdAt?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
  }

  export type QuizWhereInput = {
    AND?: QuizWhereInput | QuizWhereInput[]
    OR?: QuizWhereInput[]
    NOT?: QuizWhereInput | QuizWhereInput[]
    id?: StringFilter<"Quiz"> | string
    lessonId?: StringFilter<"Quiz"> | string
    question?: StringFilter<"Quiz"> | string
    options?: JsonFilter<"Quiz">
    correctAnswer?: StringFilter<"Quiz"> | string
    explanation?: StringNullableFilter<"Quiz"> | string | null
    createdAt?: DateTimeFilter<"Quiz"> | Date | string
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
  }

  export type QuizOrderByWithRelationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    question?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    explanation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lesson?: LessonOrderByWithRelationInput
  }

  export type QuizWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizWhereInput | QuizWhereInput[]
    OR?: QuizWhereInput[]
    NOT?: QuizWhereInput | QuizWhereInput[]
    lessonId?: StringFilter<"Quiz"> | string
    question?: StringFilter<"Quiz"> | string
    options?: JsonFilter<"Quiz">
    correctAnswer?: StringFilter<"Quiz"> | string
    explanation?: StringNullableFilter<"Quiz"> | string | null
    createdAt?: DateTimeFilter<"Quiz"> | Date | string
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
  }, "id">

  export type QuizOrderByWithAggregationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    question?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    explanation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: QuizCountOrderByAggregateInput
    _max?: QuizMaxOrderByAggregateInput
    _min?: QuizMinOrderByAggregateInput
  }

  export type QuizScalarWhereWithAggregatesInput = {
    AND?: QuizScalarWhereWithAggregatesInput | QuizScalarWhereWithAggregatesInput[]
    OR?: QuizScalarWhereWithAggregatesInput[]
    NOT?: QuizScalarWhereWithAggregatesInput | QuizScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quiz"> | string
    lessonId?: StringWithAggregatesFilter<"Quiz"> | string
    question?: StringWithAggregatesFilter<"Quiz"> | string
    options?: JsonWithAggregatesFilter<"Quiz">
    correctAnswer?: StringWithAggregatesFilter<"Quiz"> | string
    explanation?: StringNullableWithAggregatesFilter<"Quiz"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Quiz"> | Date | string
  }

  export type AssignmentSubmissionWhereInput = {
    AND?: AssignmentSubmissionWhereInput | AssignmentSubmissionWhereInput[]
    OR?: AssignmentSubmissionWhereInput[]
    NOT?: AssignmentSubmissionWhereInput | AssignmentSubmissionWhereInput[]
    id?: StringFilter<"AssignmentSubmission"> | string
    lessonId?: StringFilter<"AssignmentSubmission"> | string
    userId?: StringFilter<"AssignmentSubmission"> | string
    content?: StringNullableFilter<"AssignmentSubmission"> | string | null
    fileUrl?: StringNullableFilter<"AssignmentSubmission"> | string | null
    grade?: IntNullableFilter<"AssignmentSubmission"> | number | null
    feedback?: StringNullableFilter<"AssignmentSubmission"> | string | null
    status?: StringFilter<"AssignmentSubmission"> | string
    createdAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AssignmentSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    content?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lesson?: LessonOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AssignmentSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssignmentSubmissionWhereInput | AssignmentSubmissionWhereInput[]
    OR?: AssignmentSubmissionWhereInput[]
    NOT?: AssignmentSubmissionWhereInput | AssignmentSubmissionWhereInput[]
    lessonId?: StringFilter<"AssignmentSubmission"> | string
    userId?: StringFilter<"AssignmentSubmission"> | string
    content?: StringNullableFilter<"AssignmentSubmission"> | string | null
    fileUrl?: StringNullableFilter<"AssignmentSubmission"> | string | null
    grade?: IntNullableFilter<"AssignmentSubmission"> | number | null
    feedback?: StringNullableFilter<"AssignmentSubmission"> | string | null
    status?: StringFilter<"AssignmentSubmission"> | string
    createdAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AssignmentSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    content?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssignmentSubmissionCountOrderByAggregateInput
    _avg?: AssignmentSubmissionAvgOrderByAggregateInput
    _max?: AssignmentSubmissionMaxOrderByAggregateInput
    _min?: AssignmentSubmissionMinOrderByAggregateInput
    _sum?: AssignmentSubmissionSumOrderByAggregateInput
  }

  export type AssignmentSubmissionScalarWhereWithAggregatesInput = {
    AND?: AssignmentSubmissionScalarWhereWithAggregatesInput | AssignmentSubmissionScalarWhereWithAggregatesInput[]
    OR?: AssignmentSubmissionScalarWhereWithAggregatesInput[]
    NOT?: AssignmentSubmissionScalarWhereWithAggregatesInput | AssignmentSubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AssignmentSubmission"> | string
    lessonId?: StringWithAggregatesFilter<"AssignmentSubmission"> | string
    userId?: StringWithAggregatesFilter<"AssignmentSubmission"> | string
    content?: StringNullableWithAggregatesFilter<"AssignmentSubmission"> | string | null
    fileUrl?: StringNullableWithAggregatesFilter<"AssignmentSubmission"> | string | null
    grade?: IntNullableWithAggregatesFilter<"AssignmentSubmission"> | number | null
    feedback?: StringNullableWithAggregatesFilter<"AssignmentSubmission"> | string | null
    status?: StringWithAggregatesFilter<"AssignmentSubmission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AssignmentSubmission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AssignmentSubmission"> | Date | string
  }

  export type EnrollmentWhereInput = {
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    id?: StringFilter<"Enrollment"> | string
    userId?: StringFilter<"Enrollment"> | string
    courseId?: StringFilter<"Enrollment"> | string
    progress?: IntFilter<"Enrollment"> | number
    status?: EnumEnrollmentStatusFilter<"Enrollment"> | $Enums.EnrollmentStatus
    hasInterviewAccess?: BoolFilter<"Enrollment"> | boolean
    batchId?: StringNullableFilter<"Enrollment"> | string | null
    enrolledAt?: DateTimeFilter<"Enrollment"> | Date | string
    completedAt?: DateTimeNullableFilter<"Enrollment"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    batch?: XOR<BatchNullableScalarRelationFilter, BatchWhereInput> | null
  }

  export type EnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
    status?: SortOrder
    hasInterviewAccess?: SortOrder
    batchId?: SortOrderInput | SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    batch?: BatchOrderByWithRelationInput
  }

  export type EnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_courseId?: EnrollmentUserIdCourseIdCompoundUniqueInput
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    userId?: StringFilter<"Enrollment"> | string
    courseId?: StringFilter<"Enrollment"> | string
    progress?: IntFilter<"Enrollment"> | number
    status?: EnumEnrollmentStatusFilter<"Enrollment"> | $Enums.EnrollmentStatus
    hasInterviewAccess?: BoolFilter<"Enrollment"> | boolean
    batchId?: StringNullableFilter<"Enrollment"> | string | null
    enrolledAt?: DateTimeFilter<"Enrollment"> | Date | string
    completedAt?: DateTimeNullableFilter<"Enrollment"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    batch?: XOR<BatchNullableScalarRelationFilter, BatchWhereInput> | null
  }, "id" | "userId_courseId">

  export type EnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
    status?: SortOrder
    hasInterviewAccess?: SortOrder
    batchId?: SortOrderInput | SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: EnrollmentCountOrderByAggregateInput
    _avg?: EnrollmentAvgOrderByAggregateInput
    _max?: EnrollmentMaxOrderByAggregateInput
    _min?: EnrollmentMinOrderByAggregateInput
    _sum?: EnrollmentSumOrderByAggregateInput
  }

  export type EnrollmentScalarWhereWithAggregatesInput = {
    AND?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    OR?: EnrollmentScalarWhereWithAggregatesInput[]
    NOT?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Enrollment"> | string
    userId?: StringWithAggregatesFilter<"Enrollment"> | string
    courseId?: StringWithAggregatesFilter<"Enrollment"> | string
    progress?: IntWithAggregatesFilter<"Enrollment"> | number
    status?: EnumEnrollmentStatusWithAggregatesFilter<"Enrollment"> | $Enums.EnrollmentStatus
    hasInterviewAccess?: BoolWithAggregatesFilter<"Enrollment"> | boolean
    batchId?: StringNullableWithAggregatesFilter<"Enrollment"> | string | null
    enrolledAt?: DateTimeWithAggregatesFilter<"Enrollment"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Enrollment"> | Date | string | null
  }

  export type LessonProgressWhereInput = {
    AND?: LessonProgressWhereInput | LessonProgressWhereInput[]
    OR?: LessonProgressWhereInput[]
    NOT?: LessonProgressWhereInput | LessonProgressWhereInput[]
    id?: StringFilter<"LessonProgress"> | string
    userId?: StringFilter<"LessonProgress"> | string
    lessonId?: StringFilter<"LessonProgress"> | string
    completed?: BoolFilter<"LessonProgress"> | boolean
    score?: IntNullableFilter<"LessonProgress"> | number | null
    timeSpent?: IntFilter<"LessonProgress"> | number
    lastAccessedAt?: DateTimeFilter<"LessonProgress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
  }

  export type LessonProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    completed?: SortOrder
    score?: SortOrderInput | SortOrder
    timeSpent?: SortOrder
    lastAccessedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    lesson?: LessonOrderByWithRelationInput
  }

  export type LessonProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_lessonId?: LessonProgressUserIdLessonIdCompoundUniqueInput
    AND?: LessonProgressWhereInput | LessonProgressWhereInput[]
    OR?: LessonProgressWhereInput[]
    NOT?: LessonProgressWhereInput | LessonProgressWhereInput[]
    userId?: StringFilter<"LessonProgress"> | string
    lessonId?: StringFilter<"LessonProgress"> | string
    completed?: BoolFilter<"LessonProgress"> | boolean
    score?: IntNullableFilter<"LessonProgress"> | number | null
    timeSpent?: IntFilter<"LessonProgress"> | number
    lastAccessedAt?: DateTimeFilter<"LessonProgress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
  }, "id" | "userId_lessonId">

  export type LessonProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    completed?: SortOrder
    score?: SortOrderInput | SortOrder
    timeSpent?: SortOrder
    lastAccessedAt?: SortOrder
    _count?: LessonProgressCountOrderByAggregateInput
    _avg?: LessonProgressAvgOrderByAggregateInput
    _max?: LessonProgressMaxOrderByAggregateInput
    _min?: LessonProgressMinOrderByAggregateInput
    _sum?: LessonProgressSumOrderByAggregateInput
  }

  export type LessonProgressScalarWhereWithAggregatesInput = {
    AND?: LessonProgressScalarWhereWithAggregatesInput | LessonProgressScalarWhereWithAggregatesInput[]
    OR?: LessonProgressScalarWhereWithAggregatesInput[]
    NOT?: LessonProgressScalarWhereWithAggregatesInput | LessonProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LessonProgress"> | string
    userId?: StringWithAggregatesFilter<"LessonProgress"> | string
    lessonId?: StringWithAggregatesFilter<"LessonProgress"> | string
    completed?: BoolWithAggregatesFilter<"LessonProgress"> | boolean
    score?: IntNullableWithAggregatesFilter<"LessonProgress"> | number | null
    timeSpent?: IntWithAggregatesFilter<"LessonProgress"> | number
    lastAccessedAt?: DateTimeWithAggregatesFilter<"LessonProgress"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    courseId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    userId?: StringFilter<"Review"> | string
    courseId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    userId?: StringWithAggregatesFilter<"Review"> | string
    courseId?: StringWithAggregatesFilter<"Review"> | string
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type InterviewWhereInput = {
    AND?: InterviewWhereInput | InterviewWhereInput[]
    OR?: InterviewWhereInput[]
    NOT?: InterviewWhereInput | InterviewWhereInput[]
    id?: StringFilter<"Interview"> | string
    userId?: StringFilter<"Interview"> | string
    domain?: StringFilter<"Interview"> | string
    company?: StringNullableFilter<"Interview"> | string | null
    role?: StringFilter<"Interview"> | string
    technology?: StringNullableFilter<"Interview"> | string | null
    jobDescription?: StringNullableFilter<"Interview"> | string | null
    resumeUrl?: StringNullableFilter<"Interview"> | string | null
    difficulty?: EnumDifficultyFilter<"Interview"> | $Enums.Difficulty
    panelCount?: IntFilter<"Interview"> | number
    linkedCourseId?: StringNullableFilter<"Interview"> | string | null
    duration?: IntFilter<"Interview"> | number
    selectedAvatars?: StringNullableListFilter<"Interview">
    status?: EnumInterviewStatusFilter<"Interview"> | $Enums.InterviewStatus
    scheduledAt?: DateTimeNullableFilter<"Interview"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Interview"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Interview"> | Date | string | null
    createdAt?: DateTimeFilter<"Interview"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    questions?: InterviewQuestionListRelationFilter
    responses?: InterviewResponseListRelationFilter
    evaluation?: XOR<InterviewEvaluationNullableScalarRelationFilter, InterviewEvaluationWhereInput> | null
  }

  export type InterviewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    domain?: SortOrder
    company?: SortOrderInput | SortOrder
    role?: SortOrder
    technology?: SortOrderInput | SortOrder
    jobDescription?: SortOrderInput | SortOrder
    resumeUrl?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    panelCount?: SortOrder
    linkedCourseId?: SortOrderInput | SortOrder
    duration?: SortOrder
    selectedAvatars?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    questions?: InterviewQuestionOrderByRelationAggregateInput
    responses?: InterviewResponseOrderByRelationAggregateInput
    evaluation?: InterviewEvaluationOrderByWithRelationInput
  }

  export type InterviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InterviewWhereInput | InterviewWhereInput[]
    OR?: InterviewWhereInput[]
    NOT?: InterviewWhereInput | InterviewWhereInput[]
    userId?: StringFilter<"Interview"> | string
    domain?: StringFilter<"Interview"> | string
    company?: StringNullableFilter<"Interview"> | string | null
    role?: StringFilter<"Interview"> | string
    technology?: StringNullableFilter<"Interview"> | string | null
    jobDescription?: StringNullableFilter<"Interview"> | string | null
    resumeUrl?: StringNullableFilter<"Interview"> | string | null
    difficulty?: EnumDifficultyFilter<"Interview"> | $Enums.Difficulty
    panelCount?: IntFilter<"Interview"> | number
    linkedCourseId?: StringNullableFilter<"Interview"> | string | null
    duration?: IntFilter<"Interview"> | number
    selectedAvatars?: StringNullableListFilter<"Interview">
    status?: EnumInterviewStatusFilter<"Interview"> | $Enums.InterviewStatus
    scheduledAt?: DateTimeNullableFilter<"Interview"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Interview"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Interview"> | Date | string | null
    createdAt?: DateTimeFilter<"Interview"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    questions?: InterviewQuestionListRelationFilter
    responses?: InterviewResponseListRelationFilter
    evaluation?: XOR<InterviewEvaluationNullableScalarRelationFilter, InterviewEvaluationWhereInput> | null
  }, "id">

  export type InterviewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    domain?: SortOrder
    company?: SortOrderInput | SortOrder
    role?: SortOrder
    technology?: SortOrderInput | SortOrder
    jobDescription?: SortOrderInput | SortOrder
    resumeUrl?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    panelCount?: SortOrder
    linkedCourseId?: SortOrderInput | SortOrder
    duration?: SortOrder
    selectedAvatars?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InterviewCountOrderByAggregateInput
    _avg?: InterviewAvgOrderByAggregateInput
    _max?: InterviewMaxOrderByAggregateInput
    _min?: InterviewMinOrderByAggregateInput
    _sum?: InterviewSumOrderByAggregateInput
  }

  export type InterviewScalarWhereWithAggregatesInput = {
    AND?: InterviewScalarWhereWithAggregatesInput | InterviewScalarWhereWithAggregatesInput[]
    OR?: InterviewScalarWhereWithAggregatesInput[]
    NOT?: InterviewScalarWhereWithAggregatesInput | InterviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Interview"> | string
    userId?: StringWithAggregatesFilter<"Interview"> | string
    domain?: StringWithAggregatesFilter<"Interview"> | string
    company?: StringNullableWithAggregatesFilter<"Interview"> | string | null
    role?: StringWithAggregatesFilter<"Interview"> | string
    technology?: StringNullableWithAggregatesFilter<"Interview"> | string | null
    jobDescription?: StringNullableWithAggregatesFilter<"Interview"> | string | null
    resumeUrl?: StringNullableWithAggregatesFilter<"Interview"> | string | null
    difficulty?: EnumDifficultyWithAggregatesFilter<"Interview"> | $Enums.Difficulty
    panelCount?: IntWithAggregatesFilter<"Interview"> | number
    linkedCourseId?: StringNullableWithAggregatesFilter<"Interview"> | string | null
    duration?: IntWithAggregatesFilter<"Interview"> | number
    selectedAvatars?: StringNullableListFilter<"Interview">
    status?: EnumInterviewStatusWithAggregatesFilter<"Interview"> | $Enums.InterviewStatus
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"Interview"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"Interview"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Interview"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Interview"> | Date | string
  }

  export type InterviewQuestionWhereInput = {
    AND?: InterviewQuestionWhereInput | InterviewQuestionWhereInput[]
    OR?: InterviewQuestionWhereInput[]
    NOT?: InterviewQuestionWhereInput | InterviewQuestionWhereInput[]
    id?: StringFilter<"InterviewQuestion"> | string
    interviewId?: StringFilter<"InterviewQuestion"> | string
    avatarId?: StringNullableFilter<"InterviewQuestion"> | string | null
    question?: StringFilter<"InterviewQuestion"> | string
    type?: EnumQuestionTypeFilter<"InterviewQuestion"> | $Enums.QuestionType
    order?: IntFilter<"InterviewQuestion"> | number
    interview?: XOR<InterviewScalarRelationFilter, InterviewWhereInput>
    response?: XOR<InterviewResponseNullableScalarRelationFilter, InterviewResponseWhereInput> | null
  }

  export type InterviewQuestionOrderByWithRelationInput = {
    id?: SortOrder
    interviewId?: SortOrder
    avatarId?: SortOrderInput | SortOrder
    question?: SortOrder
    type?: SortOrder
    order?: SortOrder
    interview?: InterviewOrderByWithRelationInput
    response?: InterviewResponseOrderByWithRelationInput
  }

  export type InterviewQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InterviewQuestionWhereInput | InterviewQuestionWhereInput[]
    OR?: InterviewQuestionWhereInput[]
    NOT?: InterviewQuestionWhereInput | InterviewQuestionWhereInput[]
    interviewId?: StringFilter<"InterviewQuestion"> | string
    avatarId?: StringNullableFilter<"InterviewQuestion"> | string | null
    question?: StringFilter<"InterviewQuestion"> | string
    type?: EnumQuestionTypeFilter<"InterviewQuestion"> | $Enums.QuestionType
    order?: IntFilter<"InterviewQuestion"> | number
    interview?: XOR<InterviewScalarRelationFilter, InterviewWhereInput>
    response?: XOR<InterviewResponseNullableScalarRelationFilter, InterviewResponseWhereInput> | null
  }, "id">

  export type InterviewQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    interviewId?: SortOrder
    avatarId?: SortOrderInput | SortOrder
    question?: SortOrder
    type?: SortOrder
    order?: SortOrder
    _count?: InterviewQuestionCountOrderByAggregateInput
    _avg?: InterviewQuestionAvgOrderByAggregateInput
    _max?: InterviewQuestionMaxOrderByAggregateInput
    _min?: InterviewQuestionMinOrderByAggregateInput
    _sum?: InterviewQuestionSumOrderByAggregateInput
  }

  export type InterviewQuestionScalarWhereWithAggregatesInput = {
    AND?: InterviewQuestionScalarWhereWithAggregatesInput | InterviewQuestionScalarWhereWithAggregatesInput[]
    OR?: InterviewQuestionScalarWhereWithAggregatesInput[]
    NOT?: InterviewQuestionScalarWhereWithAggregatesInput | InterviewQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InterviewQuestion"> | string
    interviewId?: StringWithAggregatesFilter<"InterviewQuestion"> | string
    avatarId?: StringNullableWithAggregatesFilter<"InterviewQuestion"> | string | null
    question?: StringWithAggregatesFilter<"InterviewQuestion"> | string
    type?: EnumQuestionTypeWithAggregatesFilter<"InterviewQuestion"> | $Enums.QuestionType
    order?: IntWithAggregatesFilter<"InterviewQuestion"> | number
  }

  export type InterviewResponseWhereInput = {
    AND?: InterviewResponseWhereInput | InterviewResponseWhereInput[]
    OR?: InterviewResponseWhereInput[]
    NOT?: InterviewResponseWhereInput | InterviewResponseWhereInput[]
    id?: StringFilter<"InterviewResponse"> | string
    interviewId?: StringFilter<"InterviewResponse"> | string
    questionId?: StringFilter<"InterviewResponse"> | string
    transcript?: StringNullableFilter<"InterviewResponse"> | string | null
    code?: StringNullableFilter<"InterviewResponse"> | string | null
    videoUrl?: StringNullableFilter<"InterviewResponse"> | string | null
    audioUrl?: StringNullableFilter<"InterviewResponse"> | string | null
    duration?: IntNullableFilter<"InterviewResponse"> | number | null
    respondedAt?: DateTimeFilter<"InterviewResponse"> | Date | string
    interview?: XOR<InterviewScalarRelationFilter, InterviewWhereInput>
    question?: XOR<InterviewQuestionScalarRelationFilter, InterviewQuestionWhereInput>
  }

  export type InterviewResponseOrderByWithRelationInput = {
    id?: SortOrder
    interviewId?: SortOrder
    questionId?: SortOrder
    transcript?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    respondedAt?: SortOrder
    interview?: InterviewOrderByWithRelationInput
    question?: InterviewQuestionOrderByWithRelationInput
  }

  export type InterviewResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    questionId?: string
    AND?: InterviewResponseWhereInput | InterviewResponseWhereInput[]
    OR?: InterviewResponseWhereInput[]
    NOT?: InterviewResponseWhereInput | InterviewResponseWhereInput[]
    interviewId?: StringFilter<"InterviewResponse"> | string
    transcript?: StringNullableFilter<"InterviewResponse"> | string | null
    code?: StringNullableFilter<"InterviewResponse"> | string | null
    videoUrl?: StringNullableFilter<"InterviewResponse"> | string | null
    audioUrl?: StringNullableFilter<"InterviewResponse"> | string | null
    duration?: IntNullableFilter<"InterviewResponse"> | number | null
    respondedAt?: DateTimeFilter<"InterviewResponse"> | Date | string
    interview?: XOR<InterviewScalarRelationFilter, InterviewWhereInput>
    question?: XOR<InterviewQuestionScalarRelationFilter, InterviewQuestionWhereInput>
  }, "id" | "questionId">

  export type InterviewResponseOrderByWithAggregationInput = {
    id?: SortOrder
    interviewId?: SortOrder
    questionId?: SortOrder
    transcript?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    respondedAt?: SortOrder
    _count?: InterviewResponseCountOrderByAggregateInput
    _avg?: InterviewResponseAvgOrderByAggregateInput
    _max?: InterviewResponseMaxOrderByAggregateInput
    _min?: InterviewResponseMinOrderByAggregateInput
    _sum?: InterviewResponseSumOrderByAggregateInput
  }

  export type InterviewResponseScalarWhereWithAggregatesInput = {
    AND?: InterviewResponseScalarWhereWithAggregatesInput | InterviewResponseScalarWhereWithAggregatesInput[]
    OR?: InterviewResponseScalarWhereWithAggregatesInput[]
    NOT?: InterviewResponseScalarWhereWithAggregatesInput | InterviewResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InterviewResponse"> | string
    interviewId?: StringWithAggregatesFilter<"InterviewResponse"> | string
    questionId?: StringWithAggregatesFilter<"InterviewResponse"> | string
    transcript?: StringNullableWithAggregatesFilter<"InterviewResponse"> | string | null
    code?: StringNullableWithAggregatesFilter<"InterviewResponse"> | string | null
    videoUrl?: StringNullableWithAggregatesFilter<"InterviewResponse"> | string | null
    audioUrl?: StringNullableWithAggregatesFilter<"InterviewResponse"> | string | null
    duration?: IntNullableWithAggregatesFilter<"InterviewResponse"> | number | null
    respondedAt?: DateTimeWithAggregatesFilter<"InterviewResponse"> | Date | string
  }

  export type InterviewEvaluationWhereInput = {
    AND?: InterviewEvaluationWhereInput | InterviewEvaluationWhereInput[]
    OR?: InterviewEvaluationWhereInput[]
    NOT?: InterviewEvaluationWhereInput | InterviewEvaluationWhereInput[]
    id?: StringFilter<"InterviewEvaluation"> | string
    interviewId?: StringFilter<"InterviewEvaluation"> | string
    overallScore?: IntFilter<"InterviewEvaluation"> | number
    technicalScore?: IntFilter<"InterviewEvaluation"> | number
    communicationScore?: IntFilter<"InterviewEvaluation"> | number
    confidenceScore?: IntFilter<"InterviewEvaluation"> | number
    starMethodScore?: IntFilter<"InterviewEvaluation"> | number
    strengths?: JsonFilter<"InterviewEvaluation">
    weaknesses?: JsonFilter<"InterviewEvaluation">
    recommendations?: JsonFilter<"InterviewEvaluation">
    aiInsights?: StringNullableFilter<"InterviewEvaluation"> | string | null
    createdAt?: DateTimeFilter<"InterviewEvaluation"> | Date | string
    interview?: XOR<InterviewScalarRelationFilter, InterviewWhereInput>
  }

  export type InterviewEvaluationOrderByWithRelationInput = {
    id?: SortOrder
    interviewId?: SortOrder
    overallScore?: SortOrder
    technicalScore?: SortOrder
    communicationScore?: SortOrder
    confidenceScore?: SortOrder
    starMethodScore?: SortOrder
    strengths?: SortOrder
    weaknesses?: SortOrder
    recommendations?: SortOrder
    aiInsights?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    interview?: InterviewOrderByWithRelationInput
  }

  export type InterviewEvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    interviewId?: string
    AND?: InterviewEvaluationWhereInput | InterviewEvaluationWhereInput[]
    OR?: InterviewEvaluationWhereInput[]
    NOT?: InterviewEvaluationWhereInput | InterviewEvaluationWhereInput[]
    overallScore?: IntFilter<"InterviewEvaluation"> | number
    technicalScore?: IntFilter<"InterviewEvaluation"> | number
    communicationScore?: IntFilter<"InterviewEvaluation"> | number
    confidenceScore?: IntFilter<"InterviewEvaluation"> | number
    starMethodScore?: IntFilter<"InterviewEvaluation"> | number
    strengths?: JsonFilter<"InterviewEvaluation">
    weaknesses?: JsonFilter<"InterviewEvaluation">
    recommendations?: JsonFilter<"InterviewEvaluation">
    aiInsights?: StringNullableFilter<"InterviewEvaluation"> | string | null
    createdAt?: DateTimeFilter<"InterviewEvaluation"> | Date | string
    interview?: XOR<InterviewScalarRelationFilter, InterviewWhereInput>
  }, "id" | "interviewId">

  export type InterviewEvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    interviewId?: SortOrder
    overallScore?: SortOrder
    technicalScore?: SortOrder
    communicationScore?: SortOrder
    confidenceScore?: SortOrder
    starMethodScore?: SortOrder
    strengths?: SortOrder
    weaknesses?: SortOrder
    recommendations?: SortOrder
    aiInsights?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InterviewEvaluationCountOrderByAggregateInput
    _avg?: InterviewEvaluationAvgOrderByAggregateInput
    _max?: InterviewEvaluationMaxOrderByAggregateInput
    _min?: InterviewEvaluationMinOrderByAggregateInput
    _sum?: InterviewEvaluationSumOrderByAggregateInput
  }

  export type InterviewEvaluationScalarWhereWithAggregatesInput = {
    AND?: InterviewEvaluationScalarWhereWithAggregatesInput | InterviewEvaluationScalarWhereWithAggregatesInput[]
    OR?: InterviewEvaluationScalarWhereWithAggregatesInput[]
    NOT?: InterviewEvaluationScalarWhereWithAggregatesInput | InterviewEvaluationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InterviewEvaluation"> | string
    interviewId?: StringWithAggregatesFilter<"InterviewEvaluation"> | string
    overallScore?: IntWithAggregatesFilter<"InterviewEvaluation"> | number
    technicalScore?: IntWithAggregatesFilter<"InterviewEvaluation"> | number
    communicationScore?: IntWithAggregatesFilter<"InterviewEvaluation"> | number
    confidenceScore?: IntWithAggregatesFilter<"InterviewEvaluation"> | number
    starMethodScore?: IntWithAggregatesFilter<"InterviewEvaluation"> | number
    strengths?: JsonWithAggregatesFilter<"InterviewEvaluation">
    weaknesses?: JsonWithAggregatesFilter<"InterviewEvaluation">
    recommendations?: JsonWithAggregatesFilter<"InterviewEvaluation">
    aiInsights?: StringNullableWithAggregatesFilter<"InterviewEvaluation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InterviewEvaluation"> | Date | string
  }

  export type AvatarWhereInput = {
    AND?: AvatarWhereInput | AvatarWhereInput[]
    OR?: AvatarWhereInput[]
    NOT?: AvatarWhereInput | AvatarWhereInput[]
    id?: StringFilter<"Avatar"> | string
    name?: StringFilter<"Avatar"> | string
    role?: StringFilter<"Avatar"> | string
    personality?: StringFilter<"Avatar"> | string
    avatarUrl?: StringFilter<"Avatar"> | string
    voiceId?: StringNullableFilter<"Avatar"> | string | null
    isActive?: BoolFilter<"Avatar"> | boolean
    createdAt?: DateTimeFilter<"Avatar"> | Date | string
  }

  export type AvatarOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    personality?: SortOrder
    avatarUrl?: SortOrder
    voiceId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AvatarWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AvatarWhereInput | AvatarWhereInput[]
    OR?: AvatarWhereInput[]
    NOT?: AvatarWhereInput | AvatarWhereInput[]
    name?: StringFilter<"Avatar"> | string
    role?: StringFilter<"Avatar"> | string
    personality?: StringFilter<"Avatar"> | string
    avatarUrl?: StringFilter<"Avatar"> | string
    voiceId?: StringNullableFilter<"Avatar"> | string | null
    isActive?: BoolFilter<"Avatar"> | boolean
    createdAt?: DateTimeFilter<"Avatar"> | Date | string
  }, "id">

  export type AvatarOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    personality?: SortOrder
    avatarUrl?: SortOrder
    voiceId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: AvatarCountOrderByAggregateInput
    _max?: AvatarMaxOrderByAggregateInput
    _min?: AvatarMinOrderByAggregateInput
  }

  export type AvatarScalarWhereWithAggregatesInput = {
    AND?: AvatarScalarWhereWithAggregatesInput | AvatarScalarWhereWithAggregatesInput[]
    OR?: AvatarScalarWhereWithAggregatesInput[]
    NOT?: AvatarScalarWhereWithAggregatesInput | AvatarScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Avatar"> | string
    name?: StringWithAggregatesFilter<"Avatar"> | string
    role?: StringWithAggregatesFilter<"Avatar"> | string
    personality?: StringWithAggregatesFilter<"Avatar"> | string
    avatarUrl?: StringWithAggregatesFilter<"Avatar"> | string
    voiceId?: StringNullableWithAggregatesFilter<"Avatar"> | string | null
    isActive?: BoolWithAggregatesFilter<"Avatar"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Avatar"> | Date | string
  }

  export type KnowledgeBaseWhereInput = {
    AND?: KnowledgeBaseWhereInput | KnowledgeBaseWhereInput[]
    OR?: KnowledgeBaseWhereInput[]
    NOT?: KnowledgeBaseWhereInput | KnowledgeBaseWhereInput[]
    id?: StringFilter<"KnowledgeBase"> | string
    domain?: StringFilter<"KnowledgeBase"> | string
    topic?: StringFilter<"KnowledgeBase"> | string
    content?: StringFilter<"KnowledgeBase"> | string
    answer?: StringNullableFilter<"KnowledgeBase"> | string | null
    difficulty?: EnumDifficultyFilter<"KnowledgeBase"> | $Enums.Difficulty
    type?: EnumQuestionTypeFilter<"KnowledgeBase"> | $Enums.QuestionType
    codeSnippet?: StringNullableFilter<"KnowledgeBase"> | string | null
    tags?: JsonNullableFilter<"KnowledgeBase">
    status?: EnumKnowledgeStatusFilter<"KnowledgeBase"> | $Enums.KnowledgeStatus
    createdAt?: DateTimeFilter<"KnowledgeBase"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeBase"> | Date | string
  }

  export type KnowledgeBaseOrderByWithRelationInput = {
    id?: SortOrder
    domain?: SortOrder
    topic?: SortOrder
    content?: SortOrder
    answer?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    type?: SortOrder
    codeSnippet?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeBaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KnowledgeBaseWhereInput | KnowledgeBaseWhereInput[]
    OR?: KnowledgeBaseWhereInput[]
    NOT?: KnowledgeBaseWhereInput | KnowledgeBaseWhereInput[]
    domain?: StringFilter<"KnowledgeBase"> | string
    topic?: StringFilter<"KnowledgeBase"> | string
    content?: StringFilter<"KnowledgeBase"> | string
    answer?: StringNullableFilter<"KnowledgeBase"> | string | null
    difficulty?: EnumDifficultyFilter<"KnowledgeBase"> | $Enums.Difficulty
    type?: EnumQuestionTypeFilter<"KnowledgeBase"> | $Enums.QuestionType
    codeSnippet?: StringNullableFilter<"KnowledgeBase"> | string | null
    tags?: JsonNullableFilter<"KnowledgeBase">
    status?: EnumKnowledgeStatusFilter<"KnowledgeBase"> | $Enums.KnowledgeStatus
    createdAt?: DateTimeFilter<"KnowledgeBase"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeBase"> | Date | string
  }, "id">

  export type KnowledgeBaseOrderByWithAggregationInput = {
    id?: SortOrder
    domain?: SortOrder
    topic?: SortOrder
    content?: SortOrder
    answer?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    type?: SortOrder
    codeSnippet?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KnowledgeBaseCountOrderByAggregateInput
    _max?: KnowledgeBaseMaxOrderByAggregateInput
    _min?: KnowledgeBaseMinOrderByAggregateInput
  }

  export type KnowledgeBaseScalarWhereWithAggregatesInput = {
    AND?: KnowledgeBaseScalarWhereWithAggregatesInput | KnowledgeBaseScalarWhereWithAggregatesInput[]
    OR?: KnowledgeBaseScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeBaseScalarWhereWithAggregatesInput | KnowledgeBaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KnowledgeBase"> | string
    domain?: StringWithAggregatesFilter<"KnowledgeBase"> | string
    topic?: StringWithAggregatesFilter<"KnowledgeBase"> | string
    content?: StringWithAggregatesFilter<"KnowledgeBase"> | string
    answer?: StringNullableWithAggregatesFilter<"KnowledgeBase"> | string | null
    difficulty?: EnumDifficultyWithAggregatesFilter<"KnowledgeBase"> | $Enums.Difficulty
    type?: EnumQuestionTypeWithAggregatesFilter<"KnowledgeBase"> | $Enums.QuestionType
    codeSnippet?: StringNullableWithAggregatesFilter<"KnowledgeBase"> | string | null
    tags?: JsonNullableWithAggregatesFilter<"KnowledgeBase">
    status?: EnumKnowledgeStatusWithAggregatesFilter<"KnowledgeBase"> | $Enums.KnowledgeStatus
    createdAt?: DateTimeWithAggregatesFilter<"KnowledgeBase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KnowledgeBase"> | Date | string
  }

  export type SystemPromptWhereInput = {
    AND?: SystemPromptWhereInput | SystemPromptWhereInput[]
    OR?: SystemPromptWhereInput[]
    NOT?: SystemPromptWhereInput | SystemPromptWhereInput[]
    id?: StringFilter<"SystemPrompt"> | string
    role?: StringFilter<"SystemPrompt"> | string
    prompt?: StringFilter<"SystemPrompt"> | string
    isActive?: BoolFilter<"SystemPrompt"> | boolean
    updatedAt?: DateTimeFilter<"SystemPrompt"> | Date | string
  }

  export type SystemPromptOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    prompt?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemPromptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    role?: string
    AND?: SystemPromptWhereInput | SystemPromptWhereInput[]
    OR?: SystemPromptWhereInput[]
    NOT?: SystemPromptWhereInput | SystemPromptWhereInput[]
    prompt?: StringFilter<"SystemPrompt"> | string
    isActive?: BoolFilter<"SystemPrompt"> | boolean
    updatedAt?: DateTimeFilter<"SystemPrompt"> | Date | string
  }, "id" | "role">

  export type SystemPromptOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    prompt?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemPromptCountOrderByAggregateInput
    _max?: SystemPromptMaxOrderByAggregateInput
    _min?: SystemPromptMinOrderByAggregateInput
  }

  export type SystemPromptScalarWhereWithAggregatesInput = {
    AND?: SystemPromptScalarWhereWithAggregatesInput | SystemPromptScalarWhereWithAggregatesInput[]
    OR?: SystemPromptScalarWhereWithAggregatesInput[]
    NOT?: SystemPromptScalarWhereWithAggregatesInput | SystemPromptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemPrompt"> | string
    role?: StringWithAggregatesFilter<"SystemPrompt"> | string
    prompt?: StringWithAggregatesFilter<"SystemPrompt"> | string
    isActive?: BoolWithAggregatesFilter<"SystemPrompt"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"SystemPrompt"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    orderId?: StringFilter<"Payment"> | string
    paymentId?: StringNullableFilter<"Payment"> | string | null
    signature?: StringNullableFilter<"Payment"> | string | null
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    courseId?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    signature?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    paymentId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    signature?: StringNullableFilter<"Payment"> | string | null
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    courseId?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id" | "orderId" | "paymentId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    signature?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    orderId?: StringWithAggregatesFilter<"Payment"> | string
    paymentId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    signature?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: StringWithAggregatesFilter<"Payment"> | string
    userId?: StringWithAggregatesFilter<"Payment"> | string
    courseId?: StringWithAggregatesFilter<"Payment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type ForumCategoryWhereInput = {
    AND?: ForumCategoryWhereInput | ForumCategoryWhereInput[]
    OR?: ForumCategoryWhereInput[]
    NOT?: ForumCategoryWhereInput | ForumCategoryWhereInput[]
    id?: StringFilter<"ForumCategory"> | string
    name?: StringFilter<"ForumCategory"> | string
    description?: StringNullableFilter<"ForumCategory"> | string | null
    slug?: StringFilter<"ForumCategory"> | string
    icon?: StringNullableFilter<"ForumCategory"> | string | null
    createdAt?: DateTimeFilter<"ForumCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ForumCategory"> | Date | string
    posts?: ForumPostListRelationFilter
  }

  export type ForumCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posts?: ForumPostOrderByRelationAggregateInput
  }

  export type ForumCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: ForumCategoryWhereInput | ForumCategoryWhereInput[]
    OR?: ForumCategoryWhereInput[]
    NOT?: ForumCategoryWhereInput | ForumCategoryWhereInput[]
    description?: StringNullableFilter<"ForumCategory"> | string | null
    icon?: StringNullableFilter<"ForumCategory"> | string | null
    createdAt?: DateTimeFilter<"ForumCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ForumCategory"> | Date | string
    posts?: ForumPostListRelationFilter
  }, "id" | "name" | "slug">

  export type ForumCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    icon?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ForumCategoryCountOrderByAggregateInput
    _max?: ForumCategoryMaxOrderByAggregateInput
    _min?: ForumCategoryMinOrderByAggregateInput
  }

  export type ForumCategoryScalarWhereWithAggregatesInput = {
    AND?: ForumCategoryScalarWhereWithAggregatesInput | ForumCategoryScalarWhereWithAggregatesInput[]
    OR?: ForumCategoryScalarWhereWithAggregatesInput[]
    NOT?: ForumCategoryScalarWhereWithAggregatesInput | ForumCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ForumCategory"> | string
    name?: StringWithAggregatesFilter<"ForumCategory"> | string
    description?: StringNullableWithAggregatesFilter<"ForumCategory"> | string | null
    slug?: StringWithAggregatesFilter<"ForumCategory"> | string
    icon?: StringNullableWithAggregatesFilter<"ForumCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ForumCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ForumCategory"> | Date | string
  }

  export type ForumPostWhereInput = {
    AND?: ForumPostWhereInput | ForumPostWhereInput[]
    OR?: ForumPostWhereInput[]
    NOT?: ForumPostWhereInput | ForumPostWhereInput[]
    id?: StringFilter<"ForumPost"> | string
    title?: StringFilter<"ForumPost"> | string
    content?: StringFilter<"ForumPost"> | string
    slug?: StringFilter<"ForumPost"> | string
    authorId?: StringFilter<"ForumPost"> | string
    categoryId?: StringFilter<"ForumPost"> | string
    likes?: IntFilter<"ForumPost"> | number
    views?: IntFilter<"ForumPost"> | number
    isPinned?: BoolFilter<"ForumPost"> | boolean
    isSolved?: BoolFilter<"ForumPost"> | boolean
    createdAt?: DateTimeFilter<"ForumPost"> | Date | string
    updatedAt?: DateTimeFilter<"ForumPost"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    category?: XOR<ForumCategoryScalarRelationFilter, ForumCategoryWhereInput>
    comments?: ForumCommentListRelationFilter
  }

  export type ForumPostOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    slug?: SortOrder
    authorId?: SortOrder
    categoryId?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    isSolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    category?: ForumCategoryOrderByWithRelationInput
    comments?: ForumCommentOrderByRelationAggregateInput
  }

  export type ForumPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ForumPostWhereInput | ForumPostWhereInput[]
    OR?: ForumPostWhereInput[]
    NOT?: ForumPostWhereInput | ForumPostWhereInput[]
    title?: StringFilter<"ForumPost"> | string
    content?: StringFilter<"ForumPost"> | string
    authorId?: StringFilter<"ForumPost"> | string
    categoryId?: StringFilter<"ForumPost"> | string
    likes?: IntFilter<"ForumPost"> | number
    views?: IntFilter<"ForumPost"> | number
    isPinned?: BoolFilter<"ForumPost"> | boolean
    isSolved?: BoolFilter<"ForumPost"> | boolean
    createdAt?: DateTimeFilter<"ForumPost"> | Date | string
    updatedAt?: DateTimeFilter<"ForumPost"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    category?: XOR<ForumCategoryScalarRelationFilter, ForumCategoryWhereInput>
    comments?: ForumCommentListRelationFilter
  }, "id" | "slug">

  export type ForumPostOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    slug?: SortOrder
    authorId?: SortOrder
    categoryId?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    isSolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ForumPostCountOrderByAggregateInput
    _avg?: ForumPostAvgOrderByAggregateInput
    _max?: ForumPostMaxOrderByAggregateInput
    _min?: ForumPostMinOrderByAggregateInput
    _sum?: ForumPostSumOrderByAggregateInput
  }

  export type ForumPostScalarWhereWithAggregatesInput = {
    AND?: ForumPostScalarWhereWithAggregatesInput | ForumPostScalarWhereWithAggregatesInput[]
    OR?: ForumPostScalarWhereWithAggregatesInput[]
    NOT?: ForumPostScalarWhereWithAggregatesInput | ForumPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ForumPost"> | string
    title?: StringWithAggregatesFilter<"ForumPost"> | string
    content?: StringWithAggregatesFilter<"ForumPost"> | string
    slug?: StringWithAggregatesFilter<"ForumPost"> | string
    authorId?: StringWithAggregatesFilter<"ForumPost"> | string
    categoryId?: StringWithAggregatesFilter<"ForumPost"> | string
    likes?: IntWithAggregatesFilter<"ForumPost"> | number
    views?: IntWithAggregatesFilter<"ForumPost"> | number
    isPinned?: BoolWithAggregatesFilter<"ForumPost"> | boolean
    isSolved?: BoolWithAggregatesFilter<"ForumPost"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ForumPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ForumPost"> | Date | string
  }

  export type ForumCommentWhereInput = {
    AND?: ForumCommentWhereInput | ForumCommentWhereInput[]
    OR?: ForumCommentWhereInput[]
    NOT?: ForumCommentWhereInput | ForumCommentWhereInput[]
    id?: StringFilter<"ForumComment"> | string
    content?: StringFilter<"ForumComment"> | string
    postId?: StringFilter<"ForumComment"> | string
    authorId?: StringFilter<"ForumComment"> | string
    parentId?: StringNullableFilter<"ForumComment"> | string | null
    isSolution?: BoolFilter<"ForumComment"> | boolean
    likes?: IntFilter<"ForumComment"> | number
    createdAt?: DateTimeFilter<"ForumComment"> | Date | string
    updatedAt?: DateTimeFilter<"ForumComment"> | Date | string
    post?: XOR<ForumPostScalarRelationFilter, ForumPostWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ForumCommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    isSolution?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post?: ForumPostOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type ForumCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ForumCommentWhereInput | ForumCommentWhereInput[]
    OR?: ForumCommentWhereInput[]
    NOT?: ForumCommentWhereInput | ForumCommentWhereInput[]
    content?: StringFilter<"ForumComment"> | string
    postId?: StringFilter<"ForumComment"> | string
    authorId?: StringFilter<"ForumComment"> | string
    parentId?: StringNullableFilter<"ForumComment"> | string | null
    isSolution?: BoolFilter<"ForumComment"> | boolean
    likes?: IntFilter<"ForumComment"> | number
    createdAt?: DateTimeFilter<"ForumComment"> | Date | string
    updatedAt?: DateTimeFilter<"ForumComment"> | Date | string
    post?: XOR<ForumPostScalarRelationFilter, ForumPostWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ForumCommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    isSolution?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ForumCommentCountOrderByAggregateInput
    _avg?: ForumCommentAvgOrderByAggregateInput
    _max?: ForumCommentMaxOrderByAggregateInput
    _min?: ForumCommentMinOrderByAggregateInput
    _sum?: ForumCommentSumOrderByAggregateInput
  }

  export type ForumCommentScalarWhereWithAggregatesInput = {
    AND?: ForumCommentScalarWhereWithAggregatesInput | ForumCommentScalarWhereWithAggregatesInput[]
    OR?: ForumCommentScalarWhereWithAggregatesInput[]
    NOT?: ForumCommentScalarWhereWithAggregatesInput | ForumCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ForumComment"> | string
    content?: StringWithAggregatesFilter<"ForumComment"> | string
    postId?: StringWithAggregatesFilter<"ForumComment"> | string
    authorId?: StringWithAggregatesFilter<"ForumComment"> | string
    parentId?: StringNullableWithAggregatesFilter<"ForumComment"> | string | null
    isSolution?: BoolWithAggregatesFilter<"ForumComment"> | boolean
    likes?: IntWithAggregatesFilter<"ForumComment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ForumComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ForumComment"> | Date | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    name?: StringNullableFilter<"Conversation"> | string | null
    isGroup?: BoolFilter<"Conversation"> | boolean
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    participants?: UserListRelationFilter
    messages?: MessageListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    isGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    participants?: UserOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    name?: StringNullableFilter<"Conversation"> | string | null
    isGroup?: BoolFilter<"Conversation"> | boolean
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    participants?: UserListRelationFilter
    messages?: MessageListRelationFilter
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    isGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    name?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    isGroup?: BoolWithAggregatesFilter<"Conversation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    readBy?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    readBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    readBy?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    readBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    conversationId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    readBy?: JsonNullableWithAggregatesFilter<"Message">
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type CertificateWhereInput = {
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    id?: StringFilter<"Certificate"> | string
    uniqueId?: StringFilter<"Certificate"> | string
    userId?: StringFilter<"Certificate"> | string
    courseId?: StringFilter<"Certificate"> | string
    enrollmentId?: StringFilter<"Certificate"> | string
    studentName?: StringFilter<"Certificate"> | string
    courseName?: StringFilter<"Certificate"> | string
    courseCategory?: StringNullableFilter<"Certificate"> | string | null
    issueDate?: DateTimeFilter<"Certificate"> | Date | string
    expiryDate?: DateTimeNullableFilter<"Certificate"> | Date | string | null
    templateId?: StringNullableFilter<"Certificate"> | string | null
    signatureUrl?: StringNullableFilter<"Certificate"> | string | null
    signatoryName?: StringNullableFilter<"Certificate"> | string | null
    signatoryTitle?: StringNullableFilter<"Certificate"> | string | null
    verificationUrl?: StringNullableFilter<"Certificate"> | string | null
    isValid?: BoolFilter<"Certificate"> | boolean
    grade?: StringNullableFilter<"Certificate"> | string | null
    score?: FloatNullableFilter<"Certificate"> | number | null
    createdAt?: DateTimeFilter<"Certificate"> | Date | string
    updatedAt?: DateTimeFilter<"Certificate"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    template?: XOR<CertificateTemplateNullableScalarRelationFilter, CertificateTemplateWhereInput> | null
  }

  export type CertificateOrderByWithRelationInput = {
    id?: SortOrder
    uniqueId?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrollmentId?: SortOrder
    studentName?: SortOrder
    courseName?: SortOrder
    courseCategory?: SortOrderInput | SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    templateId?: SortOrderInput | SortOrder
    signatureUrl?: SortOrderInput | SortOrder
    signatoryName?: SortOrderInput | SortOrder
    signatoryTitle?: SortOrderInput | SortOrder
    verificationUrl?: SortOrderInput | SortOrder
    isValid?: SortOrder
    grade?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    template?: CertificateTemplateOrderByWithRelationInput
  }

  export type CertificateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uniqueId?: string
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    userId?: StringFilter<"Certificate"> | string
    courseId?: StringFilter<"Certificate"> | string
    enrollmentId?: StringFilter<"Certificate"> | string
    studentName?: StringFilter<"Certificate"> | string
    courseName?: StringFilter<"Certificate"> | string
    courseCategory?: StringNullableFilter<"Certificate"> | string | null
    issueDate?: DateTimeFilter<"Certificate"> | Date | string
    expiryDate?: DateTimeNullableFilter<"Certificate"> | Date | string | null
    templateId?: StringNullableFilter<"Certificate"> | string | null
    signatureUrl?: StringNullableFilter<"Certificate"> | string | null
    signatoryName?: StringNullableFilter<"Certificate"> | string | null
    signatoryTitle?: StringNullableFilter<"Certificate"> | string | null
    verificationUrl?: StringNullableFilter<"Certificate"> | string | null
    isValid?: BoolFilter<"Certificate"> | boolean
    grade?: StringNullableFilter<"Certificate"> | string | null
    score?: FloatNullableFilter<"Certificate"> | number | null
    createdAt?: DateTimeFilter<"Certificate"> | Date | string
    updatedAt?: DateTimeFilter<"Certificate"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    template?: XOR<CertificateTemplateNullableScalarRelationFilter, CertificateTemplateWhereInput> | null
  }, "id" | "uniqueId">

  export type CertificateOrderByWithAggregationInput = {
    id?: SortOrder
    uniqueId?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrollmentId?: SortOrder
    studentName?: SortOrder
    courseName?: SortOrder
    courseCategory?: SortOrderInput | SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    templateId?: SortOrderInput | SortOrder
    signatureUrl?: SortOrderInput | SortOrder
    signatoryName?: SortOrderInput | SortOrder
    signatoryTitle?: SortOrderInput | SortOrder
    verificationUrl?: SortOrderInput | SortOrder
    isValid?: SortOrder
    grade?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CertificateCountOrderByAggregateInput
    _avg?: CertificateAvgOrderByAggregateInput
    _max?: CertificateMaxOrderByAggregateInput
    _min?: CertificateMinOrderByAggregateInput
    _sum?: CertificateSumOrderByAggregateInput
  }

  export type CertificateScalarWhereWithAggregatesInput = {
    AND?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    OR?: CertificateScalarWhereWithAggregatesInput[]
    NOT?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Certificate"> | string
    uniqueId?: StringWithAggregatesFilter<"Certificate"> | string
    userId?: StringWithAggregatesFilter<"Certificate"> | string
    courseId?: StringWithAggregatesFilter<"Certificate"> | string
    enrollmentId?: StringWithAggregatesFilter<"Certificate"> | string
    studentName?: StringWithAggregatesFilter<"Certificate"> | string
    courseName?: StringWithAggregatesFilter<"Certificate"> | string
    courseCategory?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    issueDate?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
    expiryDate?: DateTimeNullableWithAggregatesFilter<"Certificate"> | Date | string | null
    templateId?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    signatureUrl?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    signatoryName?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    signatoryTitle?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    verificationUrl?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    isValid?: BoolWithAggregatesFilter<"Certificate"> | boolean
    grade?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    score?: FloatNullableWithAggregatesFilter<"Certificate"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
  }

  export type CertificateTemplateWhereInput = {
    AND?: CertificateTemplateWhereInput | CertificateTemplateWhereInput[]
    OR?: CertificateTemplateWhereInput[]
    NOT?: CertificateTemplateWhereInput | CertificateTemplateWhereInput[]
    id?: StringFilter<"CertificateTemplate"> | string
    name?: StringFilter<"CertificateTemplate"> | string
    description?: StringNullableFilter<"CertificateTemplate"> | string | null
    designUrl?: StringFilter<"CertificateTemplate"> | string
    previewUrl?: StringNullableFilter<"CertificateTemplate"> | string | null
    isDefault?: BoolFilter<"CertificateTemplate"> | boolean
    isActive?: BoolFilter<"CertificateTemplate"> | boolean
    layout?: JsonNullableFilter<"CertificateTemplate">
    createdAt?: DateTimeFilter<"CertificateTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"CertificateTemplate"> | Date | string
    certificates?: CertificateListRelationFilter
  }

  export type CertificateTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    designUrl?: SortOrder
    previewUrl?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    layout?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    certificates?: CertificateOrderByRelationAggregateInput
  }

  export type CertificateTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CertificateTemplateWhereInput | CertificateTemplateWhereInput[]
    OR?: CertificateTemplateWhereInput[]
    NOT?: CertificateTemplateWhereInput | CertificateTemplateWhereInput[]
    name?: StringFilter<"CertificateTemplate"> | string
    description?: StringNullableFilter<"CertificateTemplate"> | string | null
    designUrl?: StringFilter<"CertificateTemplate"> | string
    previewUrl?: StringNullableFilter<"CertificateTemplate"> | string | null
    isDefault?: BoolFilter<"CertificateTemplate"> | boolean
    isActive?: BoolFilter<"CertificateTemplate"> | boolean
    layout?: JsonNullableFilter<"CertificateTemplate">
    createdAt?: DateTimeFilter<"CertificateTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"CertificateTemplate"> | Date | string
    certificates?: CertificateListRelationFilter
  }, "id">

  export type CertificateTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    designUrl?: SortOrder
    previewUrl?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    layout?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CertificateTemplateCountOrderByAggregateInput
    _max?: CertificateTemplateMaxOrderByAggregateInput
    _min?: CertificateTemplateMinOrderByAggregateInput
  }

  export type CertificateTemplateScalarWhereWithAggregatesInput = {
    AND?: CertificateTemplateScalarWhereWithAggregatesInput | CertificateTemplateScalarWhereWithAggregatesInput[]
    OR?: CertificateTemplateScalarWhereWithAggregatesInput[]
    NOT?: CertificateTemplateScalarWhereWithAggregatesInput | CertificateTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CertificateTemplate"> | string
    name?: StringWithAggregatesFilter<"CertificateTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"CertificateTemplate"> | string | null
    designUrl?: StringWithAggregatesFilter<"CertificateTemplate"> | string
    previewUrl?: StringNullableWithAggregatesFilter<"CertificateTemplate"> | string | null
    isDefault?: BoolWithAggregatesFilter<"CertificateTemplate"> | boolean
    isActive?: BoolWithAggregatesFilter<"CertificateTemplate"> | boolean
    layout?: JsonNullableWithAggregatesFilter<"CertificateTemplate">
    createdAt?: DateTimeWithAggregatesFilter<"CertificateTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CertificateTemplate"> | Date | string
  }

  export type CertificateSettingsWhereInput = {
    AND?: CertificateSettingsWhereInput | CertificateSettingsWhereInput[]
    OR?: CertificateSettingsWhereInput[]
    NOT?: CertificateSettingsWhereInput | CertificateSettingsWhereInput[]
    id?: StringFilter<"CertificateSettings"> | string
    instituteId?: StringFilter<"CertificateSettings"> | string
    prefix?: StringFilter<"CertificateSettings"> | string
    yearInId?: BoolFilter<"CertificateSettings"> | boolean
    sequenceDigits?: IntFilter<"CertificateSettings"> | number
    currentSequence?: IntFilter<"CertificateSettings"> | number
    defaultSignatureUrl?: StringNullableFilter<"CertificateSettings"> | string | null
    defaultSignatoryName?: StringFilter<"CertificateSettings"> | string
    defaultSignatoryTitle?: StringFilter<"CertificateSettings"> | string
    signaturePosition?: StringFilter<"CertificateSettings"> | string
    logoPosition?: StringFilter<"CertificateSettings"> | string
    logoSize?: StringFilter<"CertificateSettings"> | string
    signatureSize?: StringFilter<"CertificateSettings"> | string
    borderStyle?: StringFilter<"CertificateSettings"> | string
    backgroundUrl?: StringNullableFilter<"CertificateSettings"> | string | null
    defaultValidityMonths?: IntNullableFilter<"CertificateSettings"> | number | null
    instituteName?: StringFilter<"CertificateSettings"> | string
    instituteLogoUrl?: StringNullableFilter<"CertificateSettings"> | string | null
    createdAt?: DateTimeFilter<"CertificateSettings"> | Date | string
    updatedAt?: DateTimeFilter<"CertificateSettings"> | Date | string
  }

  export type CertificateSettingsOrderByWithRelationInput = {
    id?: SortOrder
    instituteId?: SortOrder
    prefix?: SortOrder
    yearInId?: SortOrder
    sequenceDigits?: SortOrder
    currentSequence?: SortOrder
    defaultSignatureUrl?: SortOrderInput | SortOrder
    defaultSignatoryName?: SortOrder
    defaultSignatoryTitle?: SortOrder
    signaturePosition?: SortOrder
    logoPosition?: SortOrder
    logoSize?: SortOrder
    signatureSize?: SortOrder
    borderStyle?: SortOrder
    backgroundUrl?: SortOrderInput | SortOrder
    defaultValidityMonths?: SortOrderInput | SortOrder
    instituteName?: SortOrder
    instituteLogoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificateSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instituteId?: string
    AND?: CertificateSettingsWhereInput | CertificateSettingsWhereInput[]
    OR?: CertificateSettingsWhereInput[]
    NOT?: CertificateSettingsWhereInput | CertificateSettingsWhereInput[]
    prefix?: StringFilter<"CertificateSettings"> | string
    yearInId?: BoolFilter<"CertificateSettings"> | boolean
    sequenceDigits?: IntFilter<"CertificateSettings"> | number
    currentSequence?: IntFilter<"CertificateSettings"> | number
    defaultSignatureUrl?: StringNullableFilter<"CertificateSettings"> | string | null
    defaultSignatoryName?: StringFilter<"CertificateSettings"> | string
    defaultSignatoryTitle?: StringFilter<"CertificateSettings"> | string
    signaturePosition?: StringFilter<"CertificateSettings"> | string
    logoPosition?: StringFilter<"CertificateSettings"> | string
    logoSize?: StringFilter<"CertificateSettings"> | string
    signatureSize?: StringFilter<"CertificateSettings"> | string
    borderStyle?: StringFilter<"CertificateSettings"> | string
    backgroundUrl?: StringNullableFilter<"CertificateSettings"> | string | null
    defaultValidityMonths?: IntNullableFilter<"CertificateSettings"> | number | null
    instituteName?: StringFilter<"CertificateSettings"> | string
    instituteLogoUrl?: StringNullableFilter<"CertificateSettings"> | string | null
    createdAt?: DateTimeFilter<"CertificateSettings"> | Date | string
    updatedAt?: DateTimeFilter<"CertificateSettings"> | Date | string
  }, "id" | "instituteId">

  export type CertificateSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    instituteId?: SortOrder
    prefix?: SortOrder
    yearInId?: SortOrder
    sequenceDigits?: SortOrder
    currentSequence?: SortOrder
    defaultSignatureUrl?: SortOrderInput | SortOrder
    defaultSignatoryName?: SortOrder
    defaultSignatoryTitle?: SortOrder
    signaturePosition?: SortOrder
    logoPosition?: SortOrder
    logoSize?: SortOrder
    signatureSize?: SortOrder
    borderStyle?: SortOrder
    backgroundUrl?: SortOrderInput | SortOrder
    defaultValidityMonths?: SortOrderInput | SortOrder
    instituteName?: SortOrder
    instituteLogoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CertificateSettingsCountOrderByAggregateInput
    _avg?: CertificateSettingsAvgOrderByAggregateInput
    _max?: CertificateSettingsMaxOrderByAggregateInput
    _min?: CertificateSettingsMinOrderByAggregateInput
    _sum?: CertificateSettingsSumOrderByAggregateInput
  }

  export type CertificateSettingsScalarWhereWithAggregatesInput = {
    AND?: CertificateSettingsScalarWhereWithAggregatesInput | CertificateSettingsScalarWhereWithAggregatesInput[]
    OR?: CertificateSettingsScalarWhereWithAggregatesInput[]
    NOT?: CertificateSettingsScalarWhereWithAggregatesInput | CertificateSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CertificateSettings"> | string
    instituteId?: StringWithAggregatesFilter<"CertificateSettings"> | string
    prefix?: StringWithAggregatesFilter<"CertificateSettings"> | string
    yearInId?: BoolWithAggregatesFilter<"CertificateSettings"> | boolean
    sequenceDigits?: IntWithAggregatesFilter<"CertificateSettings"> | number
    currentSequence?: IntWithAggregatesFilter<"CertificateSettings"> | number
    defaultSignatureUrl?: StringNullableWithAggregatesFilter<"CertificateSettings"> | string | null
    defaultSignatoryName?: StringWithAggregatesFilter<"CertificateSettings"> | string
    defaultSignatoryTitle?: StringWithAggregatesFilter<"CertificateSettings"> | string
    signaturePosition?: StringWithAggregatesFilter<"CertificateSettings"> | string
    logoPosition?: StringWithAggregatesFilter<"CertificateSettings"> | string
    logoSize?: StringWithAggregatesFilter<"CertificateSettings"> | string
    signatureSize?: StringWithAggregatesFilter<"CertificateSettings"> | string
    borderStyle?: StringWithAggregatesFilter<"CertificateSettings"> | string
    backgroundUrl?: StringNullableWithAggregatesFilter<"CertificateSettings"> | string | null
    defaultValidityMonths?: IntNullableWithAggregatesFilter<"CertificateSettings"> | number | null
    instituteName?: StringWithAggregatesFilter<"CertificateSettings"> | string
    instituteLogoUrl?: StringNullableWithAggregatesFilter<"CertificateSettings"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CertificateSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CertificateSettings"> | Date | string
  }

  export type AIProviderWhereInput = {
    AND?: AIProviderWhereInput | AIProviderWhereInput[]
    OR?: AIProviderWhereInput[]
    NOT?: AIProviderWhereInput | AIProviderWhereInput[]
    id?: StringFilter<"AIProvider"> | string
    name?: StringFilter<"AIProvider"> | string
    provider?: StringFilter<"AIProvider"> | string
    apiKey?: StringFilter<"AIProvider"> | string
    model?: StringFilter<"AIProvider"> | string
    endpoint?: StringNullableFilter<"AIProvider"> | string | null
    isActive?: BoolFilter<"AIProvider"> | boolean
    isDefault?: BoolFilter<"AIProvider"> | boolean
    usageLimit?: IntNullableFilter<"AIProvider"> | number | null
    currentUsage?: IntFilter<"AIProvider"> | number
    lastResetAt?: DateTimeFilter<"AIProvider"> | Date | string
    temperature?: FloatFilter<"AIProvider"> | number
    maxTokens?: IntFilter<"AIProvider"> | number
    createdAt?: DateTimeFilter<"AIProvider"> | Date | string
    updatedAt?: DateTimeFilter<"AIProvider"> | Date | string
  }

  export type AIProviderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    provider?: SortOrder
    apiKey?: SortOrder
    model?: SortOrder
    endpoint?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isDefault?: SortOrder
    usageLimit?: SortOrderInput | SortOrder
    currentUsage?: SortOrder
    lastResetAt?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIProviderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIProviderWhereInput | AIProviderWhereInput[]
    OR?: AIProviderWhereInput[]
    NOT?: AIProviderWhereInput | AIProviderWhereInput[]
    name?: StringFilter<"AIProvider"> | string
    provider?: StringFilter<"AIProvider"> | string
    apiKey?: StringFilter<"AIProvider"> | string
    model?: StringFilter<"AIProvider"> | string
    endpoint?: StringNullableFilter<"AIProvider"> | string | null
    isActive?: BoolFilter<"AIProvider"> | boolean
    isDefault?: BoolFilter<"AIProvider"> | boolean
    usageLimit?: IntNullableFilter<"AIProvider"> | number | null
    currentUsage?: IntFilter<"AIProvider"> | number
    lastResetAt?: DateTimeFilter<"AIProvider"> | Date | string
    temperature?: FloatFilter<"AIProvider"> | number
    maxTokens?: IntFilter<"AIProvider"> | number
    createdAt?: DateTimeFilter<"AIProvider"> | Date | string
    updatedAt?: DateTimeFilter<"AIProvider"> | Date | string
  }, "id">

  export type AIProviderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    provider?: SortOrder
    apiKey?: SortOrder
    model?: SortOrder
    endpoint?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isDefault?: SortOrder
    usageLimit?: SortOrderInput | SortOrder
    currentUsage?: SortOrder
    lastResetAt?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AIProviderCountOrderByAggregateInput
    _avg?: AIProviderAvgOrderByAggregateInput
    _max?: AIProviderMaxOrderByAggregateInput
    _min?: AIProviderMinOrderByAggregateInput
    _sum?: AIProviderSumOrderByAggregateInput
  }

  export type AIProviderScalarWhereWithAggregatesInput = {
    AND?: AIProviderScalarWhereWithAggregatesInput | AIProviderScalarWhereWithAggregatesInput[]
    OR?: AIProviderScalarWhereWithAggregatesInput[]
    NOT?: AIProviderScalarWhereWithAggregatesInput | AIProviderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIProvider"> | string
    name?: StringWithAggregatesFilter<"AIProvider"> | string
    provider?: StringWithAggregatesFilter<"AIProvider"> | string
    apiKey?: StringWithAggregatesFilter<"AIProvider"> | string
    model?: StringWithAggregatesFilter<"AIProvider"> | string
    endpoint?: StringNullableWithAggregatesFilter<"AIProvider"> | string | null
    isActive?: BoolWithAggregatesFilter<"AIProvider"> | boolean
    isDefault?: BoolWithAggregatesFilter<"AIProvider"> | boolean
    usageLimit?: IntNullableWithAggregatesFilter<"AIProvider"> | number | null
    currentUsage?: IntWithAggregatesFilter<"AIProvider"> | number
    lastResetAt?: DateTimeWithAggregatesFilter<"AIProvider"> | Date | string
    temperature?: FloatWithAggregatesFilter<"AIProvider"> | number
    maxTokens?: IntWithAggregatesFilter<"AIProvider"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AIProvider"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIProvider"> | Date | string
  }

  export type AIUsageLogWhereInput = {
    AND?: AIUsageLogWhereInput | AIUsageLogWhereInput[]
    OR?: AIUsageLogWhereInput[]
    NOT?: AIUsageLogWhereInput | AIUsageLogWhereInput[]
    id?: StringFilter<"AIUsageLog"> | string
    providerId?: StringFilter<"AIUsageLog"> | string
    userId?: StringNullableFilter<"AIUsageLog"> | string | null
    feature?: StringFilter<"AIUsageLog"> | string
    tokensUsed?: IntFilter<"AIUsageLog"> | number
    promptHash?: StringNullableFilter<"AIUsageLog"> | string | null
    createdAt?: DateTimeFilter<"AIUsageLog"> | Date | string
  }

  export type AIUsageLogOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    userId?: SortOrderInput | SortOrder
    feature?: SortOrder
    tokensUsed?: SortOrder
    promptHash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AIUsageLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIUsageLogWhereInput | AIUsageLogWhereInput[]
    OR?: AIUsageLogWhereInput[]
    NOT?: AIUsageLogWhereInput | AIUsageLogWhereInput[]
    providerId?: StringFilter<"AIUsageLog"> | string
    userId?: StringNullableFilter<"AIUsageLog"> | string | null
    feature?: StringFilter<"AIUsageLog"> | string
    tokensUsed?: IntFilter<"AIUsageLog"> | number
    promptHash?: StringNullableFilter<"AIUsageLog"> | string | null
    createdAt?: DateTimeFilter<"AIUsageLog"> | Date | string
  }, "id">

  export type AIUsageLogOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    userId?: SortOrderInput | SortOrder
    feature?: SortOrder
    tokensUsed?: SortOrder
    promptHash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AIUsageLogCountOrderByAggregateInput
    _avg?: AIUsageLogAvgOrderByAggregateInput
    _max?: AIUsageLogMaxOrderByAggregateInput
    _min?: AIUsageLogMinOrderByAggregateInput
    _sum?: AIUsageLogSumOrderByAggregateInput
  }

  export type AIUsageLogScalarWhereWithAggregatesInput = {
    AND?: AIUsageLogScalarWhereWithAggregatesInput | AIUsageLogScalarWhereWithAggregatesInput[]
    OR?: AIUsageLogScalarWhereWithAggregatesInput[]
    NOT?: AIUsageLogScalarWhereWithAggregatesInput | AIUsageLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIUsageLog"> | string
    providerId?: StringWithAggregatesFilter<"AIUsageLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AIUsageLog"> | string | null
    feature?: StringWithAggregatesFilter<"AIUsageLog"> | string
    tokensUsed?: IntWithAggregatesFilter<"AIUsageLog"> | number
    promptHash?: StringNullableWithAggregatesFilter<"AIUsageLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIUsageLog"> | Date | string
  }

  export type VideoIntegrationWhereInput = {
    AND?: VideoIntegrationWhereInput | VideoIntegrationWhereInput[]
    OR?: VideoIntegrationWhereInput[]
    NOT?: VideoIntegrationWhereInput | VideoIntegrationWhereInput[]
    id?: StringFilter<"VideoIntegration"> | string
    platform?: StringFilter<"VideoIntegration"> | string
    name?: StringFilter<"VideoIntegration"> | string
    clientId?: StringNullableFilter<"VideoIntegration"> | string | null
    clientSecret?: StringNullableFilter<"VideoIntegration"> | string | null
    apiKey?: StringNullableFilter<"VideoIntegration"> | string | null
    accessToken?: StringNullableFilter<"VideoIntegration"> | string | null
    refreshToken?: StringNullableFilter<"VideoIntegration"> | string | null
    tokenExpiry?: DateTimeNullableFilter<"VideoIntegration"> | Date | string | null
    isActive?: BoolFilter<"VideoIntegration"> | boolean
    webhookUrl?: StringNullableFilter<"VideoIntegration"> | string | null
    createdAt?: DateTimeFilter<"VideoIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"VideoIntegration"> | Date | string
  }

  export type VideoIntegrationOrderByWithRelationInput = {
    id?: SortOrder
    platform?: SortOrder
    name?: SortOrder
    clientId?: SortOrderInput | SortOrder
    clientSecret?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    tokenExpiry?: SortOrderInput | SortOrder
    isActive?: SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoIntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VideoIntegrationWhereInput | VideoIntegrationWhereInput[]
    OR?: VideoIntegrationWhereInput[]
    NOT?: VideoIntegrationWhereInput | VideoIntegrationWhereInput[]
    platform?: StringFilter<"VideoIntegration"> | string
    name?: StringFilter<"VideoIntegration"> | string
    clientId?: StringNullableFilter<"VideoIntegration"> | string | null
    clientSecret?: StringNullableFilter<"VideoIntegration"> | string | null
    apiKey?: StringNullableFilter<"VideoIntegration"> | string | null
    accessToken?: StringNullableFilter<"VideoIntegration"> | string | null
    refreshToken?: StringNullableFilter<"VideoIntegration"> | string | null
    tokenExpiry?: DateTimeNullableFilter<"VideoIntegration"> | Date | string | null
    isActive?: BoolFilter<"VideoIntegration"> | boolean
    webhookUrl?: StringNullableFilter<"VideoIntegration"> | string | null
    createdAt?: DateTimeFilter<"VideoIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"VideoIntegration"> | Date | string
  }, "id">

  export type VideoIntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    platform?: SortOrder
    name?: SortOrder
    clientId?: SortOrderInput | SortOrder
    clientSecret?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    tokenExpiry?: SortOrderInput | SortOrder
    isActive?: SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VideoIntegrationCountOrderByAggregateInput
    _max?: VideoIntegrationMaxOrderByAggregateInput
    _min?: VideoIntegrationMinOrderByAggregateInput
  }

  export type VideoIntegrationScalarWhereWithAggregatesInput = {
    AND?: VideoIntegrationScalarWhereWithAggregatesInput | VideoIntegrationScalarWhereWithAggregatesInput[]
    OR?: VideoIntegrationScalarWhereWithAggregatesInput[]
    NOT?: VideoIntegrationScalarWhereWithAggregatesInput | VideoIntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoIntegration"> | string
    platform?: StringWithAggregatesFilter<"VideoIntegration"> | string
    name?: StringWithAggregatesFilter<"VideoIntegration"> | string
    clientId?: StringNullableWithAggregatesFilter<"VideoIntegration"> | string | null
    clientSecret?: StringNullableWithAggregatesFilter<"VideoIntegration"> | string | null
    apiKey?: StringNullableWithAggregatesFilter<"VideoIntegration"> | string | null
    accessToken?: StringNullableWithAggregatesFilter<"VideoIntegration"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"VideoIntegration"> | string | null
    tokenExpiry?: DateTimeNullableWithAggregatesFilter<"VideoIntegration"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"VideoIntegration"> | boolean
    webhookUrl?: StringNullableWithAggregatesFilter<"VideoIntegration"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VideoIntegration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VideoIntegration"> | Date | string
  }

  export type LiveClassWhereInput = {
    AND?: LiveClassWhereInput | LiveClassWhereInput[]
    OR?: LiveClassWhereInput[]
    NOT?: LiveClassWhereInput | LiveClassWhereInput[]
    id?: StringFilter<"LiveClass"> | string
    courseId?: StringFilter<"LiveClass"> | string
    title?: StringFilter<"LiveClass"> | string
    description?: StringNullableFilter<"LiveClass"> | string | null
    platform?: StringFilter<"LiveClass"> | string
    meetingLink?: StringNullableFilter<"LiveClass"> | string | null
    meetingId?: StringNullableFilter<"LiveClass"> | string | null
    password?: StringNullableFilter<"LiveClass"> | string | null
    scheduledAt?: DateTimeFilter<"LiveClass"> | Date | string
    duration?: IntFilter<"LiveClass"> | number
    timezone?: StringFilter<"LiveClass"> | string
    status?: EnumLiveClassStatusFilter<"LiveClass"> | $Enums.LiveClassStatus
    startedAt?: DateTimeNullableFilter<"LiveClass"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"LiveClass"> | Date | string | null
    recordingUrl?: StringNullableFilter<"LiveClass"> | string | null
    recordingPassword?: StringNullableFilter<"LiveClass"> | string | null
    hostId?: StringNullableFilter<"LiveClass"> | string | null
    hostName?: StringNullableFilter<"LiveClass"> | string | null
    createdAt?: DateTimeFilter<"LiveClass"> | Date | string
    updatedAt?: DateTimeFilter<"LiveClass"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type LiveClassOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    platform?: SortOrder
    meetingLink?: SortOrderInput | SortOrder
    meetingId?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    recordingPassword?: SortOrderInput | SortOrder
    hostId?: SortOrderInput | SortOrder
    hostName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    course?: CourseOrderByWithRelationInput
  }

  export type LiveClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LiveClassWhereInput | LiveClassWhereInput[]
    OR?: LiveClassWhereInput[]
    NOT?: LiveClassWhereInput | LiveClassWhereInput[]
    courseId?: StringFilter<"LiveClass"> | string
    title?: StringFilter<"LiveClass"> | string
    description?: StringNullableFilter<"LiveClass"> | string | null
    platform?: StringFilter<"LiveClass"> | string
    meetingLink?: StringNullableFilter<"LiveClass"> | string | null
    meetingId?: StringNullableFilter<"LiveClass"> | string | null
    password?: StringNullableFilter<"LiveClass"> | string | null
    scheduledAt?: DateTimeFilter<"LiveClass"> | Date | string
    duration?: IntFilter<"LiveClass"> | number
    timezone?: StringFilter<"LiveClass"> | string
    status?: EnumLiveClassStatusFilter<"LiveClass"> | $Enums.LiveClassStatus
    startedAt?: DateTimeNullableFilter<"LiveClass"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"LiveClass"> | Date | string | null
    recordingUrl?: StringNullableFilter<"LiveClass"> | string | null
    recordingPassword?: StringNullableFilter<"LiveClass"> | string | null
    hostId?: StringNullableFilter<"LiveClass"> | string | null
    hostName?: StringNullableFilter<"LiveClass"> | string | null
    createdAt?: DateTimeFilter<"LiveClass"> | Date | string
    updatedAt?: DateTimeFilter<"LiveClass"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id">

  export type LiveClassOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    platform?: SortOrder
    meetingLink?: SortOrderInput | SortOrder
    meetingId?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    recordingPassword?: SortOrderInput | SortOrder
    hostId?: SortOrderInput | SortOrder
    hostName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LiveClassCountOrderByAggregateInput
    _avg?: LiveClassAvgOrderByAggregateInput
    _max?: LiveClassMaxOrderByAggregateInput
    _min?: LiveClassMinOrderByAggregateInput
    _sum?: LiveClassSumOrderByAggregateInput
  }

  export type LiveClassScalarWhereWithAggregatesInput = {
    AND?: LiveClassScalarWhereWithAggregatesInput | LiveClassScalarWhereWithAggregatesInput[]
    OR?: LiveClassScalarWhereWithAggregatesInput[]
    NOT?: LiveClassScalarWhereWithAggregatesInput | LiveClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LiveClass"> | string
    courseId?: StringWithAggregatesFilter<"LiveClass"> | string
    title?: StringWithAggregatesFilter<"LiveClass"> | string
    description?: StringNullableWithAggregatesFilter<"LiveClass"> | string | null
    platform?: StringWithAggregatesFilter<"LiveClass"> | string
    meetingLink?: StringNullableWithAggregatesFilter<"LiveClass"> | string | null
    meetingId?: StringNullableWithAggregatesFilter<"LiveClass"> | string | null
    password?: StringNullableWithAggregatesFilter<"LiveClass"> | string | null
    scheduledAt?: DateTimeWithAggregatesFilter<"LiveClass"> | Date | string
    duration?: IntWithAggregatesFilter<"LiveClass"> | number
    timezone?: StringWithAggregatesFilter<"LiveClass"> | string
    status?: EnumLiveClassStatusWithAggregatesFilter<"LiveClass"> | $Enums.LiveClassStatus
    startedAt?: DateTimeNullableWithAggregatesFilter<"LiveClass"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"LiveClass"> | Date | string | null
    recordingUrl?: StringNullableWithAggregatesFilter<"LiveClass"> | string | null
    recordingPassword?: StringNullableWithAggregatesFilter<"LiveClass"> | string | null
    hostId?: StringNullableWithAggregatesFilter<"LiveClass"> | string | null
    hostName?: StringNullableWithAggregatesFilter<"LiveClass"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LiveClass"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LiveClass"> | Date | string
  }

  export type LeadWhereInput = {
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    id?: StringFilter<"Lead"> | string
    name?: StringFilter<"Lead"> | string
    email?: StringNullableFilter<"Lead"> | string | null
    phone?: StringNullableFilter<"Lead"> | string | null
    college?: StringNullableFilter<"Lead"> | string | null
    qualification?: StringNullableFilter<"Lead"> | string | null
    dob?: DateTimeNullableFilter<"Lead"> | Date | string | null
    location?: StringNullableFilter<"Lead"> | string | null
    gender?: StringNullableFilter<"Lead"> | string | null
    source?: StringFilter<"Lead"> | string
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    notes?: StringNullableFilter<"Lead"> | string | null
    assignedTo?: StringNullableFilter<"Lead"> | string | null
    platform?: StringNullableFilter<"Lead"> | string | null
    campaignId?: StringNullableFilter<"Lead"> | string | null
    adGroupId?: StringNullableFilter<"Lead"> | string | null
    adId?: StringNullableFilter<"Lead"> | string | null
    formId?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    tasks?: TaskListRelationFilter
  }

  export type LeadOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    college?: SortOrderInput | SortOrder
    qualification?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    source?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    campaignId?: SortOrderInput | SortOrder
    adGroupId?: SortOrderInput | SortOrder
    adId?: SortOrderInput | SortOrder
    formId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type LeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    name?: StringFilter<"Lead"> | string
    email?: StringNullableFilter<"Lead"> | string | null
    phone?: StringNullableFilter<"Lead"> | string | null
    college?: StringNullableFilter<"Lead"> | string | null
    qualification?: StringNullableFilter<"Lead"> | string | null
    dob?: DateTimeNullableFilter<"Lead"> | Date | string | null
    location?: StringNullableFilter<"Lead"> | string | null
    gender?: StringNullableFilter<"Lead"> | string | null
    source?: StringFilter<"Lead"> | string
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    notes?: StringNullableFilter<"Lead"> | string | null
    assignedTo?: StringNullableFilter<"Lead"> | string | null
    platform?: StringNullableFilter<"Lead"> | string | null
    campaignId?: StringNullableFilter<"Lead"> | string | null
    adGroupId?: StringNullableFilter<"Lead"> | string | null
    adId?: StringNullableFilter<"Lead"> | string | null
    formId?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    tasks?: TaskListRelationFilter
  }, "id">

  export type LeadOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    college?: SortOrderInput | SortOrder
    qualification?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    source?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    campaignId?: SortOrderInput | SortOrder
    adGroupId?: SortOrderInput | SortOrder
    adId?: SortOrderInput | SortOrder
    formId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeadCountOrderByAggregateInput
    _max?: LeadMaxOrderByAggregateInput
    _min?: LeadMinOrderByAggregateInput
  }

  export type LeadScalarWhereWithAggregatesInput = {
    AND?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    OR?: LeadScalarWhereWithAggregatesInput[]
    NOT?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lead"> | string
    name?: StringWithAggregatesFilter<"Lead"> | string
    email?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    college?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    qualification?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    dob?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    location?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    gender?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    source?: StringWithAggregatesFilter<"Lead"> | string
    status?: EnumLeadStatusWithAggregatesFilter<"Lead"> | $Enums.LeadStatus
    notes?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    assignedTo?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    platform?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    campaignId?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    adGroupId?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    adId?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    formId?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
  }

  export type MarketingIntegrationWhereInput = {
    AND?: MarketingIntegrationWhereInput | MarketingIntegrationWhereInput[]
    OR?: MarketingIntegrationWhereInput[]
    NOT?: MarketingIntegrationWhereInput | MarketingIntegrationWhereInput[]
    id?: StringFilter<"MarketingIntegration"> | string
    platform?: StringFilter<"MarketingIntegration"> | string
    name?: StringFilter<"MarketingIntegration"> | string
    accessToken?: StringNullableFilter<"MarketingIntegration"> | string | null
    refreshToken?: StringNullableFilter<"MarketingIntegration"> | string | null
    accountId?: StringNullableFilter<"MarketingIntegration"> | string | null
    pageId?: StringNullableFilter<"MarketingIntegration"> | string | null
    isActive?: BoolFilter<"MarketingIntegration"> | boolean
    webhookSecret?: StringNullableFilter<"MarketingIntegration"> | string | null
    lastSyncAt?: DateTimeNullableFilter<"MarketingIntegration"> | Date | string | null
    createdAt?: DateTimeFilter<"MarketingIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingIntegration"> | Date | string
  }

  export type MarketingIntegrationOrderByWithRelationInput = {
    id?: SortOrder
    platform?: SortOrder
    name?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    pageId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    webhookSecret?: SortOrderInput | SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingIntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketingIntegrationWhereInput | MarketingIntegrationWhereInput[]
    OR?: MarketingIntegrationWhereInput[]
    NOT?: MarketingIntegrationWhereInput | MarketingIntegrationWhereInput[]
    platform?: StringFilter<"MarketingIntegration"> | string
    name?: StringFilter<"MarketingIntegration"> | string
    accessToken?: StringNullableFilter<"MarketingIntegration"> | string | null
    refreshToken?: StringNullableFilter<"MarketingIntegration"> | string | null
    accountId?: StringNullableFilter<"MarketingIntegration"> | string | null
    pageId?: StringNullableFilter<"MarketingIntegration"> | string | null
    isActive?: BoolFilter<"MarketingIntegration"> | boolean
    webhookSecret?: StringNullableFilter<"MarketingIntegration"> | string | null
    lastSyncAt?: DateTimeNullableFilter<"MarketingIntegration"> | Date | string | null
    createdAt?: DateTimeFilter<"MarketingIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingIntegration"> | Date | string
  }, "id">

  export type MarketingIntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    platform?: SortOrder
    name?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    pageId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    webhookSecret?: SortOrderInput | SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MarketingIntegrationCountOrderByAggregateInput
    _max?: MarketingIntegrationMaxOrderByAggregateInput
    _min?: MarketingIntegrationMinOrderByAggregateInput
  }

  export type MarketingIntegrationScalarWhereWithAggregatesInput = {
    AND?: MarketingIntegrationScalarWhereWithAggregatesInput | MarketingIntegrationScalarWhereWithAggregatesInput[]
    OR?: MarketingIntegrationScalarWhereWithAggregatesInput[]
    NOT?: MarketingIntegrationScalarWhereWithAggregatesInput | MarketingIntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketingIntegration"> | string
    platform?: StringWithAggregatesFilter<"MarketingIntegration"> | string
    name?: StringWithAggregatesFilter<"MarketingIntegration"> | string
    accessToken?: StringNullableWithAggregatesFilter<"MarketingIntegration"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"MarketingIntegration"> | string | null
    accountId?: StringNullableWithAggregatesFilter<"MarketingIntegration"> | string | null
    pageId?: StringNullableWithAggregatesFilter<"MarketingIntegration"> | string | null
    isActive?: BoolWithAggregatesFilter<"MarketingIntegration"> | boolean
    webhookSecret?: StringNullableWithAggregatesFilter<"MarketingIntegration"> | string | null
    lastSyncAt?: DateTimeNullableWithAggregatesFilter<"MarketingIntegration"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MarketingIntegration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MarketingIntegration"> | Date | string
  }

  export type EmailIntegrationWhereInput = {
    AND?: EmailIntegrationWhereInput | EmailIntegrationWhereInput[]
    OR?: EmailIntegrationWhereInput[]
    NOT?: EmailIntegrationWhereInput | EmailIntegrationWhereInput[]
    id?: StringFilter<"EmailIntegration"> | string
    provider?: StringFilter<"EmailIntegration"> | string
    name?: StringNullableFilter<"EmailIntegration"> | string | null
    host?: StringNullableFilter<"EmailIntegration"> | string | null
    port?: IntNullableFilter<"EmailIntegration"> | number | null
    user?: StringNullableFilter<"EmailIntegration"> | string | null
    pass?: StringNullableFilter<"EmailIntegration"> | string | null
    secure?: BoolFilter<"EmailIntegration"> | boolean
    fromEmail?: StringNullableFilter<"EmailIntegration"> | string | null
    serviceId?: StringNullableFilter<"EmailIntegration"> | string | null
    templateId?: StringNullableFilter<"EmailIntegration"> | string | null
    publicKey?: StringNullableFilter<"EmailIntegration"> | string | null
    privateKey?: StringNullableFilter<"EmailIntegration"> | string | null
    apiKey?: StringNullableFilter<"EmailIntegration"> | string | null
    isActive?: BoolFilter<"EmailIntegration"> | boolean
    updatedAt?: DateTimeFilter<"EmailIntegration"> | Date | string
  }

  export type EmailIntegrationOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    name?: SortOrderInput | SortOrder
    host?: SortOrderInput | SortOrder
    port?: SortOrderInput | SortOrder
    user?: SortOrderInput | SortOrder
    pass?: SortOrderInput | SortOrder
    secure?: SortOrder
    fromEmail?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    templateId?: SortOrderInput | SortOrder
    publicKey?: SortOrderInput | SortOrder
    privateKey?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailIntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailIntegrationWhereInput | EmailIntegrationWhereInput[]
    OR?: EmailIntegrationWhereInput[]
    NOT?: EmailIntegrationWhereInput | EmailIntegrationWhereInput[]
    provider?: StringFilter<"EmailIntegration"> | string
    name?: StringNullableFilter<"EmailIntegration"> | string | null
    host?: StringNullableFilter<"EmailIntegration"> | string | null
    port?: IntNullableFilter<"EmailIntegration"> | number | null
    user?: StringNullableFilter<"EmailIntegration"> | string | null
    pass?: StringNullableFilter<"EmailIntegration"> | string | null
    secure?: BoolFilter<"EmailIntegration"> | boolean
    fromEmail?: StringNullableFilter<"EmailIntegration"> | string | null
    serviceId?: StringNullableFilter<"EmailIntegration"> | string | null
    templateId?: StringNullableFilter<"EmailIntegration"> | string | null
    publicKey?: StringNullableFilter<"EmailIntegration"> | string | null
    privateKey?: StringNullableFilter<"EmailIntegration"> | string | null
    apiKey?: StringNullableFilter<"EmailIntegration"> | string | null
    isActive?: BoolFilter<"EmailIntegration"> | boolean
    updatedAt?: DateTimeFilter<"EmailIntegration"> | Date | string
  }, "id">

  export type EmailIntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    name?: SortOrderInput | SortOrder
    host?: SortOrderInput | SortOrder
    port?: SortOrderInput | SortOrder
    user?: SortOrderInput | SortOrder
    pass?: SortOrderInput | SortOrder
    secure?: SortOrder
    fromEmail?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    templateId?: SortOrderInput | SortOrder
    publicKey?: SortOrderInput | SortOrder
    privateKey?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailIntegrationCountOrderByAggregateInput
    _avg?: EmailIntegrationAvgOrderByAggregateInput
    _max?: EmailIntegrationMaxOrderByAggregateInput
    _min?: EmailIntegrationMinOrderByAggregateInput
    _sum?: EmailIntegrationSumOrderByAggregateInput
  }

  export type EmailIntegrationScalarWhereWithAggregatesInput = {
    AND?: EmailIntegrationScalarWhereWithAggregatesInput | EmailIntegrationScalarWhereWithAggregatesInput[]
    OR?: EmailIntegrationScalarWhereWithAggregatesInput[]
    NOT?: EmailIntegrationScalarWhereWithAggregatesInput | EmailIntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailIntegration"> | string
    provider?: StringWithAggregatesFilter<"EmailIntegration"> | string
    name?: StringNullableWithAggregatesFilter<"EmailIntegration"> | string | null
    host?: StringNullableWithAggregatesFilter<"EmailIntegration"> | string | null
    port?: IntNullableWithAggregatesFilter<"EmailIntegration"> | number | null
    user?: StringNullableWithAggregatesFilter<"EmailIntegration"> | string | null
    pass?: StringNullableWithAggregatesFilter<"EmailIntegration"> | string | null
    secure?: BoolWithAggregatesFilter<"EmailIntegration"> | boolean
    fromEmail?: StringNullableWithAggregatesFilter<"EmailIntegration"> | string | null
    serviceId?: StringNullableWithAggregatesFilter<"EmailIntegration"> | string | null
    templateId?: StringNullableWithAggregatesFilter<"EmailIntegration"> | string | null
    publicKey?: StringNullableWithAggregatesFilter<"EmailIntegration"> | string | null
    privateKey?: StringNullableWithAggregatesFilter<"EmailIntegration"> | string | null
    apiKey?: StringNullableWithAggregatesFilter<"EmailIntegration"> | string | null
    isActive?: BoolWithAggregatesFilter<"EmailIntegration"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"EmailIntegration"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumPriorityFilter<"Task"> | $Enums.Priority
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    assignedTo?: StringNullableFilter<"Task"> | string | null
    createdBy?: StringNullableFilter<"Task"> | string | null
    leadId?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    assignee?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    lead?: XOR<LeadNullableScalarRelationFilter, LeadWhereInput> | null
    comments?: TaskCommentListRelationFilter
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    leadId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignee?: UserOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    lead?: LeadOrderByWithRelationInput
    comments?: TaskCommentOrderByRelationAggregateInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumPriorityFilter<"Task"> | $Enums.Priority
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    assignedTo?: StringNullableFilter<"Task"> | string | null
    createdBy?: StringNullableFilter<"Task"> | string | null
    leadId?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    assignee?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    lead?: XOR<LeadNullableScalarRelationFilter, LeadWhereInput> | null
    comments?: TaskCommentListRelationFilter
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    leadId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    status?: EnumTaskStatusWithAggregatesFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumPriorityWithAggregatesFilter<"Task"> | $Enums.Priority
    dueDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    assignedTo?: StringNullableWithAggregatesFilter<"Task"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Task"> | string | null
    leadId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type TaskCommentWhereInput = {
    AND?: TaskCommentWhereInput | TaskCommentWhereInput[]
    OR?: TaskCommentWhereInput[]
    NOT?: TaskCommentWhereInput | TaskCommentWhereInput[]
    id?: StringFilter<"TaskComment"> | string
    content?: StringFilter<"TaskComment"> | string
    taskId?: StringFilter<"TaskComment"> | string
    userId?: StringFilter<"TaskComment"> | string
    createdAt?: DateTimeFilter<"TaskComment"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TaskCommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    task?: TaskOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TaskCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskCommentWhereInput | TaskCommentWhereInput[]
    OR?: TaskCommentWhereInput[]
    NOT?: TaskCommentWhereInput | TaskCommentWhereInput[]
    content?: StringFilter<"TaskComment"> | string
    taskId?: StringFilter<"TaskComment"> | string
    userId?: StringFilter<"TaskComment"> | string
    createdAt?: DateTimeFilter<"TaskComment"> | Date | string
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TaskCommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: TaskCommentCountOrderByAggregateInput
    _max?: TaskCommentMaxOrderByAggregateInput
    _min?: TaskCommentMinOrderByAggregateInput
  }

  export type TaskCommentScalarWhereWithAggregatesInput = {
    AND?: TaskCommentScalarWhereWithAggregatesInput | TaskCommentScalarWhereWithAggregatesInput[]
    OR?: TaskCommentScalarWhereWithAggregatesInput[]
    NOT?: TaskCommentScalarWhereWithAggregatesInput | TaskCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskComment"> | string
    content?: StringWithAggregatesFilter<"TaskComment"> | string
    taskId?: StringWithAggregatesFilter<"TaskComment"> | string
    userId?: StringWithAggregatesFilter<"TaskComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TaskComment"> | Date | string
  }

  export type BlogPostWhereInput = {
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    slug?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    summary?: StringNullableFilter<"BlogPost"> | string | null
    coverImage?: StringNullableFilter<"BlogPost"> | string | null
    status?: EnumBlogStatusFilter<"BlogPost"> | $Enums.BlogStatus
    tags?: JsonNullableFilter<"BlogPost">
    authorId?: StringFilter<"BlogPost"> | string
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BlogPostOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    summary?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    status?: SortOrder
    tags?: SortOrderInput | SortOrder
    authorId?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
  }

  export type BlogPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    title?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    summary?: StringNullableFilter<"BlogPost"> | string | null
    coverImage?: StringNullableFilter<"BlogPost"> | string | null
    status?: EnumBlogStatusFilter<"BlogPost"> | $Enums.BlogStatus
    tags?: JsonNullableFilter<"BlogPost">
    authorId?: StringFilter<"BlogPost"> | string
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "slug">

  export type BlogPostOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    summary?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    status?: SortOrder
    tags?: SortOrderInput | SortOrder
    authorId?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlogPostCountOrderByAggregateInput
    _max?: BlogPostMaxOrderByAggregateInput
    _min?: BlogPostMinOrderByAggregateInput
  }

  export type BlogPostScalarWhereWithAggregatesInput = {
    AND?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    OR?: BlogPostScalarWhereWithAggregatesInput[]
    NOT?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogPost"> | string
    title?: StringWithAggregatesFilter<"BlogPost"> | string
    slug?: StringWithAggregatesFilter<"BlogPost"> | string
    content?: StringWithAggregatesFilter<"BlogPost"> | string
    summary?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    coverImage?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    status?: EnumBlogStatusWithAggregatesFilter<"BlogPost"> | $Enums.BlogStatus
    tags?: JsonNullableWithAggregatesFilter<"BlogPost">
    authorId?: StringWithAggregatesFilter<"BlogPost"> | string
    publishedAt?: DateTimeNullableWithAggregatesFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
  }

  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: StringFilter<"Ticket"> | string
    subject?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityFilter<"Ticket"> | $Enums.TicketPriority
    category?: EnumTicketCategoryFilter<"Ticket"> | $Enums.TicketCategory
    userId?: StringFilter<"Ticket"> | string
    assignedTo?: StringNullableFilter<"Ticket"> | string | null
    internalNotes?: StringNullableFilter<"Ticket"> | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: TicketMessageListRelationFilter
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    userId?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    internalNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    messages?: TicketMessageOrderByRelationAggregateInput
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    subject?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityFilter<"Ticket"> | $Enums.TicketPriority
    category?: EnumTicketCategoryFilter<"Ticket"> | $Enums.TicketCategory
    userId?: StringFilter<"Ticket"> | string
    assignedTo?: StringNullableFilter<"Ticket"> | string | null
    internalNotes?: StringNullableFilter<"Ticket"> | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: TicketMessageListRelationFilter
  }, "id">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    userId?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    internalNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TicketCountOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ticket"> | string
    subject?: StringWithAggregatesFilter<"Ticket"> | string
    description?: StringWithAggregatesFilter<"Ticket"> | string
    status?: EnumTicketStatusWithAggregatesFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityWithAggregatesFilter<"Ticket"> | $Enums.TicketPriority
    category?: EnumTicketCategoryWithAggregatesFilter<"Ticket"> | $Enums.TicketCategory
    userId?: StringWithAggregatesFilter<"Ticket"> | string
    assignedTo?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    internalNotes?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
  }

  export type TicketMessageWhereInput = {
    AND?: TicketMessageWhereInput | TicketMessageWhereInput[]
    OR?: TicketMessageWhereInput[]
    NOT?: TicketMessageWhereInput | TicketMessageWhereInput[]
    id?: StringFilter<"TicketMessage"> | string
    message?: StringFilter<"TicketMessage"> | string
    attachmentUrl?: StringNullableFilter<"TicketMessage"> | string | null
    isStaffReply?: BoolFilter<"TicketMessage"> | boolean
    ticketId?: StringFilter<"TicketMessage"> | string
    createdAt?: DateTimeFilter<"TicketMessage"> | Date | string
    userId?: StringNullableFilter<"TicketMessage"> | string | null
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type TicketMessageOrderByWithRelationInput = {
    id?: SortOrder
    message?: SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    isStaffReply?: SortOrder
    ticketId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    ticket?: TicketOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TicketMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketMessageWhereInput | TicketMessageWhereInput[]
    OR?: TicketMessageWhereInput[]
    NOT?: TicketMessageWhereInput | TicketMessageWhereInput[]
    message?: StringFilter<"TicketMessage"> | string
    attachmentUrl?: StringNullableFilter<"TicketMessage"> | string | null
    isStaffReply?: BoolFilter<"TicketMessage"> | boolean
    ticketId?: StringFilter<"TicketMessage"> | string
    createdAt?: DateTimeFilter<"TicketMessage"> | Date | string
    userId?: StringNullableFilter<"TicketMessage"> | string | null
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type TicketMessageOrderByWithAggregationInput = {
    id?: SortOrder
    message?: SortOrder
    attachmentUrl?: SortOrderInput | SortOrder
    isStaffReply?: SortOrder
    ticketId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: TicketMessageCountOrderByAggregateInput
    _max?: TicketMessageMaxOrderByAggregateInput
    _min?: TicketMessageMinOrderByAggregateInput
  }

  export type TicketMessageScalarWhereWithAggregatesInput = {
    AND?: TicketMessageScalarWhereWithAggregatesInput | TicketMessageScalarWhereWithAggregatesInput[]
    OR?: TicketMessageScalarWhereWithAggregatesInput[]
    NOT?: TicketMessageScalarWhereWithAggregatesInput | TicketMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketMessage"> | string
    message?: StringWithAggregatesFilter<"TicketMessage"> | string
    attachmentUrl?: StringNullableWithAggregatesFilter<"TicketMessage"> | string | null
    isStaffReply?: BoolWithAggregatesFilter<"TicketMessage"> | boolean
    ticketId?: StringWithAggregatesFilter<"TicketMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TicketMessage"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"TicketMessage"> | string | null
  }

  export type PaymentConfigWhereInput = {
    AND?: PaymentConfigWhereInput | PaymentConfigWhereInput[]
    OR?: PaymentConfigWhereInput[]
    NOT?: PaymentConfigWhereInput | PaymentConfigWhereInput[]
    id?: StringFilter<"PaymentConfig"> | string
    razorpayKeyId?: StringNullableFilter<"PaymentConfig"> | string | null
    razorpayKeySecret?: StringNullableFilter<"PaymentConfig"> | string | null
    stripePublishableKey?: StringNullableFilter<"PaymentConfig"> | string | null
    stripeSecretKey?: StringNullableFilter<"PaymentConfig"> | string | null
    activeGateway?: EnumGatewayFilter<"PaymentConfig"> | $Enums.Gateway
    currency?: StringFilter<"PaymentConfig"> | string
    createdAt?: DateTimeFilter<"PaymentConfig"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentConfig"> | Date | string
  }

  export type PaymentConfigOrderByWithRelationInput = {
    id?: SortOrder
    razorpayKeyId?: SortOrderInput | SortOrder
    razorpayKeySecret?: SortOrderInput | SortOrder
    stripePublishableKey?: SortOrderInput | SortOrder
    stripeSecretKey?: SortOrderInput | SortOrder
    activeGateway?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentConfigWhereInput | PaymentConfigWhereInput[]
    OR?: PaymentConfigWhereInput[]
    NOT?: PaymentConfigWhereInput | PaymentConfigWhereInput[]
    razorpayKeyId?: StringNullableFilter<"PaymentConfig"> | string | null
    razorpayKeySecret?: StringNullableFilter<"PaymentConfig"> | string | null
    stripePublishableKey?: StringNullableFilter<"PaymentConfig"> | string | null
    stripeSecretKey?: StringNullableFilter<"PaymentConfig"> | string | null
    activeGateway?: EnumGatewayFilter<"PaymentConfig"> | $Enums.Gateway
    currency?: StringFilter<"PaymentConfig"> | string
    createdAt?: DateTimeFilter<"PaymentConfig"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentConfig"> | Date | string
  }, "id">

  export type PaymentConfigOrderByWithAggregationInput = {
    id?: SortOrder
    razorpayKeyId?: SortOrderInput | SortOrder
    razorpayKeySecret?: SortOrderInput | SortOrder
    stripePublishableKey?: SortOrderInput | SortOrder
    stripeSecretKey?: SortOrderInput | SortOrder
    activeGateway?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentConfigCountOrderByAggregateInput
    _max?: PaymentConfigMaxOrderByAggregateInput
    _min?: PaymentConfigMinOrderByAggregateInput
  }

  export type PaymentConfigScalarWhereWithAggregatesInput = {
    AND?: PaymentConfigScalarWhereWithAggregatesInput | PaymentConfigScalarWhereWithAggregatesInput[]
    OR?: PaymentConfigScalarWhereWithAggregatesInput[]
    NOT?: PaymentConfigScalarWhereWithAggregatesInput | PaymentConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentConfig"> | string
    razorpayKeyId?: StringNullableWithAggregatesFilter<"PaymentConfig"> | string | null
    razorpayKeySecret?: StringNullableWithAggregatesFilter<"PaymentConfig"> | string | null
    stripePublishableKey?: StringNullableWithAggregatesFilter<"PaymentConfig"> | string | null
    stripeSecretKey?: StringNullableWithAggregatesFilter<"PaymentConfig"> | string | null
    activeGateway?: EnumGatewayWithAggregatesFilter<"PaymentConfig"> | $Enums.Gateway
    currency?: StringWithAggregatesFilter<"PaymentConfig"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PaymentConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentConfig"> | Date | string
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: StringFilter<"Expense"> | string
    title?: StringFilter<"Expense"> | string
    amount?: FloatFilter<"Expense"> | number
    category?: StringFilter<"Expense"> | string
    description?: StringNullableFilter<"Expense"> | string | null
    date?: DateTimeFilter<"Expense"> | Date | string
    createdBy?: StringFilter<"Expense"> | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    title?: StringFilter<"Expense"> | string
    amount?: FloatFilter<"Expense"> | number
    category?: StringFilter<"Expense"> | string
    description?: StringNullableFilter<"Expense"> | string | null
    date?: DateTimeFilter<"Expense"> | Date | string
    createdBy?: StringFilter<"Expense"> | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
  }, "id">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Expense"> | string
    title?: StringWithAggregatesFilter<"Expense"> | string
    amount?: FloatWithAggregatesFilter<"Expense"> | number
    category?: StringWithAggregatesFilter<"Expense"> | string
    description?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    date?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Expense"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
  }

  export type SystemSettingsWhereInput = {
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    id?: StringFilter<"SystemSettings"> | string
    platformName?: StringFilter<"SystemSettings"> | string
    supportEmail?: StringFilter<"SystemSettings"> | string
    logoUrl?: StringNullableFilter<"SystemSettings"> | string | null
    faviconUrl?: StringNullableFilter<"SystemSettings"> | string | null
    primaryColor?: StringFilter<"SystemSettings"> | string
    isMaintenanceMode?: BoolFilter<"SystemSettings"> | boolean
    address?: StringNullableFilter<"SystemSettings"> | string | null
    phone?: StringNullableFilter<"SystemSettings"> | string | null
    updatedAt?: DateTimeFilter<"SystemSettings"> | Date | string
  }

  export type SystemSettingsOrderByWithRelationInput = {
    id?: SortOrder
    platformName?: SortOrder
    supportEmail?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    faviconUrl?: SortOrderInput | SortOrder
    primaryColor?: SortOrder
    isMaintenanceMode?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    platformName?: StringFilter<"SystemSettings"> | string
    supportEmail?: StringFilter<"SystemSettings"> | string
    logoUrl?: StringNullableFilter<"SystemSettings"> | string | null
    faviconUrl?: StringNullableFilter<"SystemSettings"> | string | null
    primaryColor?: StringFilter<"SystemSettings"> | string
    isMaintenanceMode?: BoolFilter<"SystemSettings"> | boolean
    address?: StringNullableFilter<"SystemSettings"> | string | null
    phone?: StringNullableFilter<"SystemSettings"> | string | null
    updatedAt?: DateTimeFilter<"SystemSettings"> | Date | string
  }, "id">

  export type SystemSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    platformName?: SortOrder
    supportEmail?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    faviconUrl?: SortOrderInput | SortOrder
    primaryColor?: SortOrder
    isMaintenanceMode?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: SystemSettingsCountOrderByAggregateInput
    _max?: SystemSettingsMaxOrderByAggregateInput
    _min?: SystemSettingsMinOrderByAggregateInput
  }

  export type SystemSettingsScalarWhereWithAggregatesInput = {
    AND?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    OR?: SystemSettingsScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemSettings"> | string
    platformName?: StringWithAggregatesFilter<"SystemSettings"> | string
    supportEmail?: StringWithAggregatesFilter<"SystemSettings"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    faviconUrl?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    primaryColor?: StringWithAggregatesFilter<"SystemSettings"> | string
    isMaintenanceMode?: BoolWithAggregatesFilter<"SystemSettings"> | boolean
    address?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    phone?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSettings"> | Date | string
  }

  export type EmployerProfileWhereInput = {
    AND?: EmployerProfileWhereInput | EmployerProfileWhereInput[]
    OR?: EmployerProfileWhereInput[]
    NOT?: EmployerProfileWhereInput | EmployerProfileWhereInput[]
    id?: StringFilter<"EmployerProfile"> | string
    userId?: StringFilter<"EmployerProfile"> | string
    companyName?: StringFilter<"EmployerProfile"> | string
    website?: StringNullableFilter<"EmployerProfile"> | string | null
    description?: StringNullableFilter<"EmployerProfile"> | string | null
    logo?: StringNullableFilter<"EmployerProfile"> | string | null
    location?: StringNullableFilter<"EmployerProfile"> | string | null
    industry?: StringNullableFilter<"EmployerProfile"> | string | null
    companySize?: StringNullableFilter<"EmployerProfile"> | string | null
    status?: EnumEmployerStatusFilter<"EmployerProfile"> | $Enums.EmployerStatus
    documentsVerified?: BoolFilter<"EmployerProfile"> | boolean
    verificationNotes?: StringNullableFilter<"EmployerProfile"> | string | null
    createdAt?: DateTimeFilter<"EmployerProfile"> | Date | string
    updatedAt?: DateTimeFilter<"EmployerProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EmployerProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    website?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    companySize?: SortOrderInput | SortOrder
    status?: SortOrder
    documentsVerified?: SortOrder
    verificationNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EmployerProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: EmployerProfileWhereInput | EmployerProfileWhereInput[]
    OR?: EmployerProfileWhereInput[]
    NOT?: EmployerProfileWhereInput | EmployerProfileWhereInput[]
    companyName?: StringFilter<"EmployerProfile"> | string
    website?: StringNullableFilter<"EmployerProfile"> | string | null
    description?: StringNullableFilter<"EmployerProfile"> | string | null
    logo?: StringNullableFilter<"EmployerProfile"> | string | null
    location?: StringNullableFilter<"EmployerProfile"> | string | null
    industry?: StringNullableFilter<"EmployerProfile"> | string | null
    companySize?: StringNullableFilter<"EmployerProfile"> | string | null
    status?: EnumEmployerStatusFilter<"EmployerProfile"> | $Enums.EmployerStatus
    documentsVerified?: BoolFilter<"EmployerProfile"> | boolean
    verificationNotes?: StringNullableFilter<"EmployerProfile"> | string | null
    createdAt?: DateTimeFilter<"EmployerProfile"> | Date | string
    updatedAt?: DateTimeFilter<"EmployerProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type EmployerProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    website?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    companySize?: SortOrderInput | SortOrder
    status?: SortOrder
    documentsVerified?: SortOrder
    verificationNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployerProfileCountOrderByAggregateInput
    _max?: EmployerProfileMaxOrderByAggregateInput
    _min?: EmployerProfileMinOrderByAggregateInput
  }

  export type EmployerProfileScalarWhereWithAggregatesInput = {
    AND?: EmployerProfileScalarWhereWithAggregatesInput | EmployerProfileScalarWhereWithAggregatesInput[]
    OR?: EmployerProfileScalarWhereWithAggregatesInput[]
    NOT?: EmployerProfileScalarWhereWithAggregatesInput | EmployerProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmployerProfile"> | string
    userId?: StringWithAggregatesFilter<"EmployerProfile"> | string
    companyName?: StringWithAggregatesFilter<"EmployerProfile"> | string
    website?: StringNullableWithAggregatesFilter<"EmployerProfile"> | string | null
    description?: StringNullableWithAggregatesFilter<"EmployerProfile"> | string | null
    logo?: StringNullableWithAggregatesFilter<"EmployerProfile"> | string | null
    location?: StringNullableWithAggregatesFilter<"EmployerProfile"> | string | null
    industry?: StringNullableWithAggregatesFilter<"EmployerProfile"> | string | null
    companySize?: StringNullableWithAggregatesFilter<"EmployerProfile"> | string | null
    status?: EnumEmployerStatusWithAggregatesFilter<"EmployerProfile"> | $Enums.EmployerStatus
    documentsVerified?: BoolWithAggregatesFilter<"EmployerProfile"> | boolean
    verificationNotes?: StringNullableWithAggregatesFilter<"EmployerProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmployerProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployerProfile"> | Date | string
  }

  export type JobWhereInput = {
    AND?: JobWhereInput | JobWhereInput[]
    OR?: JobWhereInput[]
    NOT?: JobWhereInput | JobWhereInput[]
    id?: StringFilter<"Job"> | string
    title?: StringFilter<"Job"> | string
    description?: StringFilter<"Job"> | string
    requirements?: StringNullableFilter<"Job"> | string | null
    location?: StringFilter<"Job"> | string
    type?: EnumJobTypeFilter<"Job"> | $Enums.JobType
    experience?: StringNullableFilter<"Job"> | string | null
    salary?: StringNullableFilter<"Job"> | string | null
    skills?: StringNullableFilter<"Job"> | string | null
    clientName?: StringNullableFilter<"Job"> | string | null
    shift?: StringNullableFilter<"Job"> | string | null
    domain?: StringNullableFilter<"Job"> | string | null
    qualification?: StringNullableFilter<"Job"> | string | null
    employerId?: StringFilter<"Job"> | string
    status?: EnumJobStatusFilter<"Job"> | $Enums.JobStatus
    publishedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    employer?: XOR<UserScalarRelationFilter, UserWhereInput>
    applications?: JobApplicationListRelationFilter
  }

  export type JobOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirements?: SortOrderInput | SortOrder
    location?: SortOrder
    type?: SortOrder
    experience?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    skills?: SortOrderInput | SortOrder
    clientName?: SortOrderInput | SortOrder
    shift?: SortOrderInput | SortOrder
    domain?: SortOrderInput | SortOrder
    qualification?: SortOrderInput | SortOrder
    employerId?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employer?: UserOrderByWithRelationInput
    applications?: JobApplicationOrderByRelationAggregateInput
  }

  export type JobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobWhereInput | JobWhereInput[]
    OR?: JobWhereInput[]
    NOT?: JobWhereInput | JobWhereInput[]
    title?: StringFilter<"Job"> | string
    description?: StringFilter<"Job"> | string
    requirements?: StringNullableFilter<"Job"> | string | null
    location?: StringFilter<"Job"> | string
    type?: EnumJobTypeFilter<"Job"> | $Enums.JobType
    experience?: StringNullableFilter<"Job"> | string | null
    salary?: StringNullableFilter<"Job"> | string | null
    skills?: StringNullableFilter<"Job"> | string | null
    clientName?: StringNullableFilter<"Job"> | string | null
    shift?: StringNullableFilter<"Job"> | string | null
    domain?: StringNullableFilter<"Job"> | string | null
    qualification?: StringNullableFilter<"Job"> | string | null
    employerId?: StringFilter<"Job"> | string
    status?: EnumJobStatusFilter<"Job"> | $Enums.JobStatus
    publishedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    employer?: XOR<UserScalarRelationFilter, UserWhereInput>
    applications?: JobApplicationListRelationFilter
  }, "id">

  export type JobOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirements?: SortOrderInput | SortOrder
    location?: SortOrder
    type?: SortOrder
    experience?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    skills?: SortOrderInput | SortOrder
    clientName?: SortOrderInput | SortOrder
    shift?: SortOrderInput | SortOrder
    domain?: SortOrderInput | SortOrder
    qualification?: SortOrderInput | SortOrder
    employerId?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JobCountOrderByAggregateInput
    _max?: JobMaxOrderByAggregateInput
    _min?: JobMinOrderByAggregateInput
  }

  export type JobScalarWhereWithAggregatesInput = {
    AND?: JobScalarWhereWithAggregatesInput | JobScalarWhereWithAggregatesInput[]
    OR?: JobScalarWhereWithAggregatesInput[]
    NOT?: JobScalarWhereWithAggregatesInput | JobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Job"> | string
    title?: StringWithAggregatesFilter<"Job"> | string
    description?: StringWithAggregatesFilter<"Job"> | string
    requirements?: StringNullableWithAggregatesFilter<"Job"> | string | null
    location?: StringWithAggregatesFilter<"Job"> | string
    type?: EnumJobTypeWithAggregatesFilter<"Job"> | $Enums.JobType
    experience?: StringNullableWithAggregatesFilter<"Job"> | string | null
    salary?: StringNullableWithAggregatesFilter<"Job"> | string | null
    skills?: StringNullableWithAggregatesFilter<"Job"> | string | null
    clientName?: StringNullableWithAggregatesFilter<"Job"> | string | null
    shift?: StringNullableWithAggregatesFilter<"Job"> | string | null
    domain?: StringNullableWithAggregatesFilter<"Job"> | string | null
    qualification?: StringNullableWithAggregatesFilter<"Job"> | string | null
    employerId?: StringWithAggregatesFilter<"Job"> | string
    status?: EnumJobStatusWithAggregatesFilter<"Job"> | $Enums.JobStatus
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Job"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Job"> | Date | string
  }

  export type JobApplicationWhereInput = {
    AND?: JobApplicationWhereInput | JobApplicationWhereInput[]
    OR?: JobApplicationWhereInput[]
    NOT?: JobApplicationWhereInput | JobApplicationWhereInput[]
    id?: StringFilter<"JobApplication"> | string
    jobId?: StringFilter<"JobApplication"> | string
    applicantId?: StringNullableFilter<"JobApplication"> | string | null
    source?: EnumCandidateSourceFilter<"JobApplication"> | $Enums.CandidateSource
    externalName?: StringNullableFilter<"JobApplication"> | string | null
    externalEmail?: StringNullableFilter<"JobApplication"> | string | null
    externalPhone?: StringNullableFilter<"JobApplication"> | string | null
    resumeUrl?: StringNullableFilter<"JobApplication"> | string | null
    coverLetter?: StringNullableFilter<"JobApplication"> | string | null
    resumeParsedText?: StringNullableFilter<"JobApplication"> | string | null
    atsScore?: FloatFilter<"JobApplication"> | number
    status?: EnumApplicationStatusFilter<"JobApplication"> | $Enums.ApplicationStatus
    statusHistory?: JsonNullableFilter<"JobApplication">
    createdAt?: DateTimeFilter<"JobApplication"> | Date | string
    updatedAt?: DateTimeFilter<"JobApplication"> | Date | string
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
    applicant?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    interviews?: JobInterviewListRelationFilter
    emailLogs?: EmailLogListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type JobApplicationOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrder
    applicantId?: SortOrderInput | SortOrder
    source?: SortOrder
    externalName?: SortOrderInput | SortOrder
    externalEmail?: SortOrderInput | SortOrder
    externalPhone?: SortOrderInput | SortOrder
    resumeUrl?: SortOrderInput | SortOrder
    coverLetter?: SortOrderInput | SortOrder
    resumeParsedText?: SortOrderInput | SortOrder
    atsScore?: SortOrder
    status?: SortOrder
    statusHistory?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    job?: JobOrderByWithRelationInput
    applicant?: UserOrderByWithRelationInput
    interviews?: JobInterviewOrderByRelationAggregateInput
    emailLogs?: EmailLogOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type JobApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jobId_applicantId?: JobApplicationJobIdApplicantIdCompoundUniqueInput
    AND?: JobApplicationWhereInput | JobApplicationWhereInput[]
    OR?: JobApplicationWhereInput[]
    NOT?: JobApplicationWhereInput | JobApplicationWhereInput[]
    jobId?: StringFilter<"JobApplication"> | string
    applicantId?: StringNullableFilter<"JobApplication"> | string | null
    source?: EnumCandidateSourceFilter<"JobApplication"> | $Enums.CandidateSource
    externalName?: StringNullableFilter<"JobApplication"> | string | null
    externalEmail?: StringNullableFilter<"JobApplication"> | string | null
    externalPhone?: StringNullableFilter<"JobApplication"> | string | null
    resumeUrl?: StringNullableFilter<"JobApplication"> | string | null
    coverLetter?: StringNullableFilter<"JobApplication"> | string | null
    resumeParsedText?: StringNullableFilter<"JobApplication"> | string | null
    atsScore?: FloatFilter<"JobApplication"> | number
    status?: EnumApplicationStatusFilter<"JobApplication"> | $Enums.ApplicationStatus
    statusHistory?: JsonNullableFilter<"JobApplication">
    createdAt?: DateTimeFilter<"JobApplication"> | Date | string
    updatedAt?: DateTimeFilter<"JobApplication"> | Date | string
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
    applicant?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    interviews?: JobInterviewListRelationFilter
    emailLogs?: EmailLogListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "jobId_applicantId">

  export type JobApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrder
    applicantId?: SortOrderInput | SortOrder
    source?: SortOrder
    externalName?: SortOrderInput | SortOrder
    externalEmail?: SortOrderInput | SortOrder
    externalPhone?: SortOrderInput | SortOrder
    resumeUrl?: SortOrderInput | SortOrder
    coverLetter?: SortOrderInput | SortOrder
    resumeParsedText?: SortOrderInput | SortOrder
    atsScore?: SortOrder
    status?: SortOrder
    statusHistory?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JobApplicationCountOrderByAggregateInput
    _avg?: JobApplicationAvgOrderByAggregateInput
    _max?: JobApplicationMaxOrderByAggregateInput
    _min?: JobApplicationMinOrderByAggregateInput
    _sum?: JobApplicationSumOrderByAggregateInput
  }

  export type JobApplicationScalarWhereWithAggregatesInput = {
    AND?: JobApplicationScalarWhereWithAggregatesInput | JobApplicationScalarWhereWithAggregatesInput[]
    OR?: JobApplicationScalarWhereWithAggregatesInput[]
    NOT?: JobApplicationScalarWhereWithAggregatesInput | JobApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobApplication"> | string
    jobId?: StringWithAggregatesFilter<"JobApplication"> | string
    applicantId?: StringNullableWithAggregatesFilter<"JobApplication"> | string | null
    source?: EnumCandidateSourceWithAggregatesFilter<"JobApplication"> | $Enums.CandidateSource
    externalName?: StringNullableWithAggregatesFilter<"JobApplication"> | string | null
    externalEmail?: StringNullableWithAggregatesFilter<"JobApplication"> | string | null
    externalPhone?: StringNullableWithAggregatesFilter<"JobApplication"> | string | null
    resumeUrl?: StringNullableWithAggregatesFilter<"JobApplication"> | string | null
    coverLetter?: StringNullableWithAggregatesFilter<"JobApplication"> | string | null
    resumeParsedText?: StringNullableWithAggregatesFilter<"JobApplication"> | string | null
    atsScore?: FloatWithAggregatesFilter<"JobApplication"> | number
    status?: EnumApplicationStatusWithAggregatesFilter<"JobApplication"> | $Enums.ApplicationStatus
    statusHistory?: JsonNullableWithAggregatesFilter<"JobApplication">
    createdAt?: DateTimeWithAggregatesFilter<"JobApplication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JobApplication"> | Date | string
  }

  export type JobInterviewWhereInput = {
    AND?: JobInterviewWhereInput | JobInterviewWhereInput[]
    OR?: JobInterviewWhereInput[]
    NOT?: JobInterviewWhereInput | JobInterviewWhereInput[]
    id?: StringFilter<"JobInterview"> | string
    applicationId?: StringFilter<"JobInterview"> | string
    roundName?: StringFilter<"JobInterview"> | string
    roundType?: EnumInterviewRoundTypeFilter<"JobInterview"> | $Enums.InterviewRoundType
    scheduledAt?: DateTimeFilter<"JobInterview"> | Date | string
    duration?: IntFilter<"JobInterview"> | number
    meetingLink?: StringNullableFilter<"JobInterview"> | string | null
    location?: StringNullableFilter<"JobInterview"> | string | null
    interviewerId?: StringFilter<"JobInterview"> | string
    status?: EnumInterviewStatusFilter<"JobInterview"> | $Enums.InterviewStatus
    feedback?: StringNullableFilter<"JobInterview"> | string | null
    score?: IntNullableFilter<"JobInterview"> | number | null
    result?: EnumInterviewResultNullableFilter<"JobInterview"> | $Enums.InterviewResult | null
    createdAt?: DateTimeFilter<"JobInterview"> | Date | string
    updatedAt?: DateTimeFilter<"JobInterview"> | Date | string
    application?: XOR<JobApplicationScalarRelationFilter, JobApplicationWhereInput>
    interviewer?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type JobInterviewOrderByWithRelationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    roundName?: SortOrder
    roundType?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    meetingLink?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    interviewerId?: SortOrder
    status?: SortOrder
    feedback?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    application?: JobApplicationOrderByWithRelationInput
    interviewer?: UserOrderByWithRelationInput
  }

  export type JobInterviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobInterviewWhereInput | JobInterviewWhereInput[]
    OR?: JobInterviewWhereInput[]
    NOT?: JobInterviewWhereInput | JobInterviewWhereInput[]
    applicationId?: StringFilter<"JobInterview"> | string
    roundName?: StringFilter<"JobInterview"> | string
    roundType?: EnumInterviewRoundTypeFilter<"JobInterview"> | $Enums.InterviewRoundType
    scheduledAt?: DateTimeFilter<"JobInterview"> | Date | string
    duration?: IntFilter<"JobInterview"> | number
    meetingLink?: StringNullableFilter<"JobInterview"> | string | null
    location?: StringNullableFilter<"JobInterview"> | string | null
    interviewerId?: StringFilter<"JobInterview"> | string
    status?: EnumInterviewStatusFilter<"JobInterview"> | $Enums.InterviewStatus
    feedback?: StringNullableFilter<"JobInterview"> | string | null
    score?: IntNullableFilter<"JobInterview"> | number | null
    result?: EnumInterviewResultNullableFilter<"JobInterview"> | $Enums.InterviewResult | null
    createdAt?: DateTimeFilter<"JobInterview"> | Date | string
    updatedAt?: DateTimeFilter<"JobInterview"> | Date | string
    application?: XOR<JobApplicationScalarRelationFilter, JobApplicationWhereInput>
    interviewer?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type JobInterviewOrderByWithAggregationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    roundName?: SortOrder
    roundType?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    meetingLink?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    interviewerId?: SortOrder
    status?: SortOrder
    feedback?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JobInterviewCountOrderByAggregateInput
    _avg?: JobInterviewAvgOrderByAggregateInput
    _max?: JobInterviewMaxOrderByAggregateInput
    _min?: JobInterviewMinOrderByAggregateInput
    _sum?: JobInterviewSumOrderByAggregateInput
  }

  export type JobInterviewScalarWhereWithAggregatesInput = {
    AND?: JobInterviewScalarWhereWithAggregatesInput | JobInterviewScalarWhereWithAggregatesInput[]
    OR?: JobInterviewScalarWhereWithAggregatesInput[]
    NOT?: JobInterviewScalarWhereWithAggregatesInput | JobInterviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobInterview"> | string
    applicationId?: StringWithAggregatesFilter<"JobInterview"> | string
    roundName?: StringWithAggregatesFilter<"JobInterview"> | string
    roundType?: EnumInterviewRoundTypeWithAggregatesFilter<"JobInterview"> | $Enums.InterviewRoundType
    scheduledAt?: DateTimeWithAggregatesFilter<"JobInterview"> | Date | string
    duration?: IntWithAggregatesFilter<"JobInterview"> | number
    meetingLink?: StringNullableWithAggregatesFilter<"JobInterview"> | string | null
    location?: StringNullableWithAggregatesFilter<"JobInterview"> | string | null
    interviewerId?: StringWithAggregatesFilter<"JobInterview"> | string
    status?: EnumInterviewStatusWithAggregatesFilter<"JobInterview"> | $Enums.InterviewStatus
    feedback?: StringNullableWithAggregatesFilter<"JobInterview"> | string | null
    score?: IntNullableWithAggregatesFilter<"JobInterview"> | number | null
    result?: EnumInterviewResultNullableWithAggregatesFilter<"JobInterview"> | $Enums.InterviewResult | null
    createdAt?: DateTimeWithAggregatesFilter<"JobInterview"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JobInterview"> | Date | string
  }

  export type EmailLogWhereInput = {
    AND?: EmailLogWhereInput | EmailLogWhereInput[]
    OR?: EmailLogWhereInput[]
    NOT?: EmailLogWhereInput | EmailLogWhereInput[]
    id?: StringFilter<"EmailLog"> | string
    jobId?: StringNullableFilter<"EmailLog"> | string | null
    applicationId?: StringNullableFilter<"EmailLog"> | string | null
    recipientEmail?: StringFilter<"EmailLog"> | string
    recipientName?: StringNullableFilter<"EmailLog"> | string | null
    templateName?: StringFilter<"EmailLog"> | string
    subject?: StringFilter<"EmailLog"> | string
    body?: StringFilter<"EmailLog"> | string
    status?: EnumEmailStatusFilter<"EmailLog"> | $Enums.EmailStatus
    sentAt?: DateTimeFilter<"EmailLog"> | Date | string
    error?: StringNullableFilter<"EmailLog"> | string | null
    triggeredBy?: StringNullableFilter<"EmailLog"> | string | null
    application?: XOR<JobApplicationNullableScalarRelationFilter, JobApplicationWhereInput> | null
  }

  export type EmailLogOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrderInput | SortOrder
    applicationId?: SortOrderInput | SortOrder
    recipientEmail?: SortOrder
    recipientName?: SortOrderInput | SortOrder
    templateName?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    error?: SortOrderInput | SortOrder
    triggeredBy?: SortOrderInput | SortOrder
    application?: JobApplicationOrderByWithRelationInput
  }

  export type EmailLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailLogWhereInput | EmailLogWhereInput[]
    OR?: EmailLogWhereInput[]
    NOT?: EmailLogWhereInput | EmailLogWhereInput[]
    jobId?: StringNullableFilter<"EmailLog"> | string | null
    applicationId?: StringNullableFilter<"EmailLog"> | string | null
    recipientEmail?: StringFilter<"EmailLog"> | string
    recipientName?: StringNullableFilter<"EmailLog"> | string | null
    templateName?: StringFilter<"EmailLog"> | string
    subject?: StringFilter<"EmailLog"> | string
    body?: StringFilter<"EmailLog"> | string
    status?: EnumEmailStatusFilter<"EmailLog"> | $Enums.EmailStatus
    sentAt?: DateTimeFilter<"EmailLog"> | Date | string
    error?: StringNullableFilter<"EmailLog"> | string | null
    triggeredBy?: StringNullableFilter<"EmailLog"> | string | null
    application?: XOR<JobApplicationNullableScalarRelationFilter, JobApplicationWhereInput> | null
  }, "id">

  export type EmailLogOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrderInput | SortOrder
    applicationId?: SortOrderInput | SortOrder
    recipientEmail?: SortOrder
    recipientName?: SortOrderInput | SortOrder
    templateName?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    error?: SortOrderInput | SortOrder
    triggeredBy?: SortOrderInput | SortOrder
    _count?: EmailLogCountOrderByAggregateInput
    _max?: EmailLogMaxOrderByAggregateInput
    _min?: EmailLogMinOrderByAggregateInput
  }

  export type EmailLogScalarWhereWithAggregatesInput = {
    AND?: EmailLogScalarWhereWithAggregatesInput | EmailLogScalarWhereWithAggregatesInput[]
    OR?: EmailLogScalarWhereWithAggregatesInput[]
    NOT?: EmailLogScalarWhereWithAggregatesInput | EmailLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailLog"> | string
    jobId?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    applicationId?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    recipientEmail?: StringWithAggregatesFilter<"EmailLog"> | string
    recipientName?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    templateName?: StringWithAggregatesFilter<"EmailLog"> | string
    subject?: StringWithAggregatesFilter<"EmailLog"> | string
    body?: StringWithAggregatesFilter<"EmailLog"> | string
    status?: EnumEmailStatusWithAggregatesFilter<"EmailLog"> | $Enums.EmailStatus
    sentAt?: DateTimeWithAggregatesFilter<"EmailLog"> | Date | string
    error?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    triggeredBy?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    method?: StringNullableFilter<"AuditLog"> | string | null
    path?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    oldValue?: JsonNullableFilter<"AuditLog">
    newValue?: JsonNullableFilter<"AuditLog">
    applicationId?: StringNullableFilter<"AuditLog"> | string | null
    performedBy?: StringFilter<"AuditLog"> | string
    details?: JsonNullableFilter<"AuditLog">
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    application?: XOR<JobApplicationNullableScalarRelationFilter, JobApplicationWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    action?: SortOrder
    method?: SortOrderInput | SortOrder
    path?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    applicationId?: SortOrderInput | SortOrder
    performedBy?: SortOrder
    details?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    application?: JobApplicationOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    method?: StringNullableFilter<"AuditLog"> | string | null
    path?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    oldValue?: JsonNullableFilter<"AuditLog">
    newValue?: JsonNullableFilter<"AuditLog">
    applicationId?: StringNullableFilter<"AuditLog"> | string | null
    performedBy?: StringFilter<"AuditLog"> | string
    details?: JsonNullableFilter<"AuditLog">
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    application?: XOR<JobApplicationNullableScalarRelationFilter, JobApplicationWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    action?: SortOrder
    method?: SortOrderInput | SortOrder
    path?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    applicationId?: SortOrderInput | SortOrder
    performedBy?: SortOrder
    details?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    method?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    path?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    oldValue?: JsonNullableWithAggregatesFilter<"AuditLog">
    newValue?: JsonNullableWithAggregatesFilter<"AuditLog">
    applicationId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    performedBy?: StringWithAggregatesFilter<"AuditLog"> | string
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type SavedFilterWhereInput = {
    AND?: SavedFilterWhereInput | SavedFilterWhereInput[]
    OR?: SavedFilterWhereInput[]
    NOT?: SavedFilterWhereInput | SavedFilterWhereInput[]
    id?: StringFilter<"SavedFilter"> | string
    name?: StringFilter<"SavedFilter"> | string
    userId?: StringFilter<"SavedFilter"> | string
    page?: StringFilter<"SavedFilter"> | string
    config?: JsonFilter<"SavedFilter">
    createdAt?: DateTimeFilter<"SavedFilter"> | Date | string
    updatedAt?: DateTimeFilter<"SavedFilter"> | Date | string
  }

  export type SavedFilterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    page?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SavedFilterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SavedFilterWhereInput | SavedFilterWhereInput[]
    OR?: SavedFilterWhereInput[]
    NOT?: SavedFilterWhereInput | SavedFilterWhereInput[]
    name?: StringFilter<"SavedFilter"> | string
    userId?: StringFilter<"SavedFilter"> | string
    page?: StringFilter<"SavedFilter"> | string
    config?: JsonFilter<"SavedFilter">
    createdAt?: DateTimeFilter<"SavedFilter"> | Date | string
    updatedAt?: DateTimeFilter<"SavedFilter"> | Date | string
  }, "id">

  export type SavedFilterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    page?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SavedFilterCountOrderByAggregateInput
    _max?: SavedFilterMaxOrderByAggregateInput
    _min?: SavedFilterMinOrderByAggregateInput
  }

  export type SavedFilterScalarWhereWithAggregatesInput = {
    AND?: SavedFilterScalarWhereWithAggregatesInput | SavedFilterScalarWhereWithAggregatesInput[]
    OR?: SavedFilterScalarWhereWithAggregatesInput[]
    NOT?: SavedFilterScalarWhereWithAggregatesInput | SavedFilterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SavedFilter"> | string
    name?: StringWithAggregatesFilter<"SavedFilter"> | string
    userId?: StringWithAggregatesFilter<"SavedFilter"> | string
    page?: StringWithAggregatesFilter<"SavedFilter"> | string
    config?: JsonWithAggregatesFilter<"SavedFilter">
    createdAt?: DateTimeWithAggregatesFilter<"SavedFilter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SavedFilter"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateInput = {
    id?: string
    title: string
    description: string
    thumbnail?: string | null
    category: string
    difficulty?: $Enums.Difficulty
    duration?: number
    price?: Decimal | DecimalJsLike | number | string
    discountPrice?: Decimal | DecimalJsLike | number | string
    courseCode?: string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: string | null
    averageRating?: number
    instructorId: string
    isPublished?: boolean
    hasInterviewPrep?: boolean
    interviewPrice?: Decimal | DecimalJsLike | number | string
    bundlePrice?: Decimal | DecimalJsLike | number | string
    courseType?: $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: $Enums.PublishStatus
    publishedAt?: Date | string | null
    reviewNotes?: string | null
    submittedForReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    payments?: PaymentCreateNestedManyWithoutCourseInput
    reviews?: ReviewCreateNestedManyWithoutCourseInput
    liveClasses?: LiveClassCreateNestedManyWithoutCourseInput
    batches?: BatchCreateNestedManyWithoutCourseInput
    announcements?: AnnouncementCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    thumbnail?: string | null
    category: string
    difficulty?: $Enums.Difficulty
    duration?: number
    price?: Decimal | DecimalJsLike | number | string
    discountPrice?: Decimal | DecimalJsLike | number | string
    courseCode?: string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: string | null
    averageRating?: number
    instructorId: string
    isPublished?: boolean
    hasInterviewPrep?: boolean
    interviewPrice?: Decimal | DecimalJsLike | number | string
    bundlePrice?: Decimal | DecimalJsLike | number | string
    courseType?: $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: $Enums.PublishStatus
    publishedAt?: Date | string | null
    reviewNotes?: string | null
    submittedForReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCourseInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCourseInput
    liveClasses?: LiveClassUncheckedCreateNestedManyWithoutCourseInput
    batches?: BatchUncheckedCreateNestedManyWithoutCourseInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseCode?: NullableStringFieldUpdateOperationsInput | string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    instructorId?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    hasInterviewPrep?: BoolFieldUpdateOperationsInput | boolean
    interviewPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bundlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    payments?: PaymentUpdateManyWithoutCourseNestedInput
    reviews?: ReviewUpdateManyWithoutCourseNestedInput
    liveClasses?: LiveClassUpdateManyWithoutCourseNestedInput
    batches?: BatchUpdateManyWithoutCourseNestedInput
    announcements?: AnnouncementUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseCode?: NullableStringFieldUpdateOperationsInput | string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    instructorId?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    hasInterviewPrep?: BoolFieldUpdateOperationsInput | boolean
    interviewPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bundlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCourseNestedInput
    liveClasses?: LiveClassUncheckedUpdateManyWithoutCourseNestedInput
    batches?: BatchUncheckedUpdateManyWithoutCourseNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    title: string
    description: string
    thumbnail?: string | null
    category: string
    difficulty?: $Enums.Difficulty
    duration?: number
    price?: Decimal | DecimalJsLike | number | string
    discountPrice?: Decimal | DecimalJsLike | number | string
    courseCode?: string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: string | null
    averageRating?: number
    instructorId: string
    isPublished?: boolean
    hasInterviewPrep?: boolean
    interviewPrice?: Decimal | DecimalJsLike | number | string
    bundlePrice?: Decimal | DecimalJsLike | number | string
    courseType?: $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: $Enums.PublishStatus
    publishedAt?: Date | string | null
    reviewNotes?: string | null
    submittedForReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseCode?: NullableStringFieldUpdateOperationsInput | string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    instructorId?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    hasInterviewPrep?: BoolFieldUpdateOperationsInput | boolean
    interviewPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bundlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseCode?: NullableStringFieldUpdateOperationsInput | string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    instructorId?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    hasInterviewPrep?: BoolFieldUpdateOperationsInput | boolean
    interviewPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bundlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchCreateInput = {
    id?: string
    name: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    description?: string | null
    maxStudents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutBatchesInput
    instructor: UserCreateNestedOneWithoutInstructedBatchesInput
    announcements?: AnnouncementCreateNestedManyWithoutBatchInput
    enrollments?: EnrollmentCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateInput = {
    id?: string
    name: string
    courseId: string
    instructorId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    description?: string | null
    maxStudents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutBatchInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutBatchesNestedInput
    instructor?: UserUpdateOneRequiredWithoutInstructedBatchesNestedInput
    announcements?: AnnouncementUpdateManyWithoutBatchNestedInput
    enrollments?: EnrollmentUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    announcements?: AnnouncementUncheckedUpdateManyWithoutBatchNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchCreateManyInput = {
    id?: string
    name: string
    courseId: string
    instructorId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    description?: string | null
    maxStudents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementCreateInput = {
    id?: string
    title: string
    content: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    course?: CourseCreateNestedOneWithoutAnnouncementsInput
    batch?: BatchCreateNestedOneWithoutAnnouncementsInput
    instructor: UserCreateNestedOneWithoutAnnouncementsInput
  }

  export type AnnouncementUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    priority?: string
    courseId?: string | null
    batchId?: string | null
    instructorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneWithoutAnnouncementsNestedInput
    batch?: BatchUpdateOneWithoutAnnouncementsNestedInput
    instructor?: UserUpdateOneRequiredWithoutAnnouncementsNestedInput
  }

  export type AnnouncementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementCreateManyInput = {
    id?: string
    title: string
    content: string
    priority?: string
    courseId?: string | null
    batchId?: string | null
    instructorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCommentCreateInput = {
    id?: string
    content: string
    isPinned?: boolean
    isInstructorResponse?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lesson: LessonCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutLessonCommentsInput
    parent?: LessonCommentCreateNestedOneWithoutRepliesInput
    replies?: LessonCommentCreateNestedManyWithoutParentInput
  }

  export type LessonCommentUncheckedCreateInput = {
    id?: string
    lessonId: string
    userId: string
    content: string
    parentId?: string | null
    isPinned?: boolean
    isInstructorResponse?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: LessonCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type LessonCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isInstructorResponse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutLessonCommentsNestedInput
    parent?: LessonCommentUpdateOneWithoutRepliesNestedInput
    replies?: LessonCommentUpdateManyWithoutParentNestedInput
  }

  export type LessonCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isInstructorResponse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: LessonCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type LessonCommentCreateManyInput = {
    id?: string
    lessonId: string
    userId: string
    content: string
    parentId?: string | null
    isPinned?: boolean
    isInstructorResponse?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isInstructorResponse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isInstructorResponse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleCreateInput = {
    id?: string
    title: string
    description?: string | null
    orderIndex: number
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutModulesInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateInput = {
    id?: string
    courseId: string
    title: string
    description?: string | null
    orderIndex: number
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleCreateManyInput = {
    id?: string
    courseId: string
    title: string
    description?: string | null
    orderIndex: number
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCreateInput = {
    id?: string
    title: string
    content?: string | null
    videoUrl?: string | null
    duration?: number | null
    order: number
    type?: $Enums.LessonType
    isPublished?: boolean
    isPreview?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    module: ModuleCreateNestedOneWithoutLessonsInput
    quizzes?: QuizCreateNestedManyWithoutLessonInput
    progress?: LessonProgressCreateNestedManyWithoutLessonInput
    comments?: LessonCommentCreateNestedManyWithoutLessonInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateInput = {
    id?: string
    moduleId: string
    title: string
    content?: string | null
    videoUrl?: string | null
    duration?: number | null
    order: number
    type?: $Enums.LessonType
    isPublished?: boolean
    isPreview?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    quizzes?: QuizUncheckedCreateNestedManyWithoutLessonInput
    progress?: LessonProgressUncheckedCreateNestedManyWithoutLessonInput
    comments?: LessonCommentUncheckedCreateNestedManyWithoutLessonInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneRequiredWithoutLessonsNestedInput
    quizzes?: QuizUpdateManyWithoutLessonNestedInput
    progress?: LessonProgressUpdateManyWithoutLessonNestedInput
    comments?: LessonCommentUpdateManyWithoutLessonNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizzes?: QuizUncheckedUpdateManyWithoutLessonNestedInput
    progress?: LessonProgressUncheckedUpdateManyWithoutLessonNestedInput
    comments?: LessonCommentUncheckedUpdateManyWithoutLessonNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonCreateManyInput = {
    id?: string
    moduleId: string
    title: string
    content?: string | null
    videoUrl?: string | null
    duration?: number | null
    order: number
    type?: $Enums.LessonType
    isPublished?: boolean
    isPreview?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCreateInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    correctAnswer: string
    explanation?: string | null
    createdAt?: Date | string
    lesson: LessonCreateNestedOneWithoutQuizzesInput
  }

  export type QuizUncheckedCreateInput = {
    id?: string
    lessonId: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    correctAnswer: string
    explanation?: string | null
    createdAt?: Date | string
  }

  export type QuizUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutQuizzesNestedInput
  }

  export type QuizUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCreateManyInput = {
    id?: string
    lessonId: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    correctAnswer: string
    explanation?: string | null
    createdAt?: Date | string
  }

  export type QuizUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentSubmissionCreateInput = {
    id?: string
    content?: string | null
    fileUrl?: string | null
    grade?: number | null
    feedback?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lesson: LessonCreateNestedOneWithoutAssignmentSubmissionsInput
    user: UserCreateNestedOneWithoutAssignmentSubmissionsInput
  }

  export type AssignmentSubmissionUncheckedCreateInput = {
    id?: string
    lessonId: string
    userId: string
    content?: string | null
    fileUrl?: string | null
    grade?: number | null
    feedback?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutAssignmentSubmissionsNestedInput
    user?: UserUpdateOneRequiredWithoutAssignmentSubmissionsNestedInput
  }

  export type AssignmentSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentSubmissionCreateManyInput = {
    id?: string
    lessonId: string
    userId: string
    content?: string | null
    fileUrl?: string | null
    grade?: number | null
    feedback?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentCreateInput = {
    id?: string
    progress?: number
    status?: $Enums.EnrollmentStatus
    hasInterviewAccess?: boolean
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutEnrollmentsInput
    course: CourseCreateNestedOneWithoutEnrollmentsInput
    batch?: BatchCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateInput = {
    id?: string
    userId: string
    courseId: string
    progress?: number
    status?: $Enums.EnrollmentStatus
    hasInterviewAccess?: boolean
    batchId?: string | null
    enrolledAt?: Date | string
    completedAt?: Date | string | null
  }

  export type EnrollmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    hasInterviewAccess?: BoolFieldUpdateOperationsInput | boolean
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutEnrollmentsNestedInput
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
    batch?: BatchUpdateOneWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    hasInterviewAccess?: BoolFieldUpdateOperationsInput | boolean
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnrollmentCreateManyInput = {
    id?: string
    userId: string
    courseId: string
    progress?: number
    status?: $Enums.EnrollmentStatus
    hasInterviewAccess?: boolean
    batchId?: string | null
    enrolledAt?: Date | string
    completedAt?: Date | string | null
  }

  export type EnrollmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    hasInterviewAccess?: BoolFieldUpdateOperationsInput | boolean
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnrollmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    hasInterviewAccess?: BoolFieldUpdateOperationsInput | boolean
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonProgressCreateInput = {
    id?: string
    completed?: boolean
    score?: number | null
    timeSpent?: number
    lastAccessedAt?: Date | string
    user: UserCreateNestedOneWithoutLessonProgressInput
    lesson: LessonCreateNestedOneWithoutProgressInput
  }

  export type LessonProgressUncheckedCreateInput = {
    id?: string
    userId: string
    lessonId: string
    completed?: boolean
    score?: number | null
    timeSpent?: number
    lastAccessedAt?: Date | string
  }

  export type LessonProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpent?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLessonProgressNestedInput
    lesson?: LessonUpdateOneRequiredWithoutProgressNestedInput
  }

  export type LessonProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpent?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonProgressCreateManyInput = {
    id?: string
    userId: string
    lessonId: string
    completed?: boolean
    score?: number | null
    timeSpent?: number
    lastAccessedAt?: Date | string
  }

  export type LessonProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpent?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpent?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    course: CourseCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    userId: string
    courseId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    course?: CourseUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    userId: string
    courseId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewCreateInput = {
    id?: string
    domain: string
    company?: string | null
    role: string
    technology?: string | null
    jobDescription?: string | null
    resumeUrl?: string | null
    difficulty?: $Enums.Difficulty
    panelCount?: number
    linkedCourseId?: string | null
    duration?: number
    selectedAvatars?: InterviewCreateselectedAvatarsInput | string[]
    status?: $Enums.InterviewStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutInterviewsInput
    questions?: InterviewQuestionCreateNestedManyWithoutInterviewInput
    responses?: InterviewResponseCreateNestedManyWithoutInterviewInput
    evaluation?: InterviewEvaluationCreateNestedOneWithoutInterviewInput
  }

  export type InterviewUncheckedCreateInput = {
    id?: string
    userId: string
    domain: string
    company?: string | null
    role: string
    technology?: string | null
    jobDescription?: string | null
    resumeUrl?: string | null
    difficulty?: $Enums.Difficulty
    panelCount?: number
    linkedCourseId?: string | null
    duration?: number
    selectedAvatars?: InterviewCreateselectedAvatarsInput | string[]
    status?: $Enums.InterviewStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    questions?: InterviewQuestionUncheckedCreateNestedManyWithoutInterviewInput
    responses?: InterviewResponseUncheckedCreateNestedManyWithoutInterviewInput
    evaluation?: InterviewEvaluationUncheckedCreateNestedOneWithoutInterviewInput
  }

  export type InterviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    technology?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    panelCount?: IntFieldUpdateOperationsInput | number
    linkedCourseId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    selectedAvatars?: InterviewUpdateselectedAvatarsInput | string[]
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInterviewsNestedInput
    questions?: InterviewQuestionUpdateManyWithoutInterviewNestedInput
    responses?: InterviewResponseUpdateManyWithoutInterviewNestedInput
    evaluation?: InterviewEvaluationUpdateOneWithoutInterviewNestedInput
  }

  export type InterviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    technology?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    panelCount?: IntFieldUpdateOperationsInput | number
    linkedCourseId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    selectedAvatars?: InterviewUpdateselectedAvatarsInput | string[]
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: InterviewQuestionUncheckedUpdateManyWithoutInterviewNestedInput
    responses?: InterviewResponseUncheckedUpdateManyWithoutInterviewNestedInput
    evaluation?: InterviewEvaluationUncheckedUpdateOneWithoutInterviewNestedInput
  }

  export type InterviewCreateManyInput = {
    id?: string
    userId: string
    domain: string
    company?: string | null
    role: string
    technology?: string | null
    jobDescription?: string | null
    resumeUrl?: string | null
    difficulty?: $Enums.Difficulty
    panelCount?: number
    linkedCourseId?: string | null
    duration?: number
    selectedAvatars?: InterviewCreateselectedAvatarsInput | string[]
    status?: $Enums.InterviewStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type InterviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    technology?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    panelCount?: IntFieldUpdateOperationsInput | number
    linkedCourseId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    selectedAvatars?: InterviewUpdateselectedAvatarsInput | string[]
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    technology?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    panelCount?: IntFieldUpdateOperationsInput | number
    linkedCourseId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    selectedAvatars?: InterviewUpdateselectedAvatarsInput | string[]
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewQuestionCreateInput = {
    id?: string
    avatarId?: string | null
    question: string
    type: $Enums.QuestionType
    order: number
    interview: InterviewCreateNestedOneWithoutQuestionsInput
    response?: InterviewResponseCreateNestedOneWithoutQuestionInput
  }

  export type InterviewQuestionUncheckedCreateInput = {
    id?: string
    interviewId: string
    avatarId?: string | null
    question: string
    type: $Enums.QuestionType
    order: number
    response?: InterviewResponseUncheckedCreateNestedOneWithoutQuestionInput
  }

  export type InterviewQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatarId?: NullableStringFieldUpdateOperationsInput | string | null
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    order?: IntFieldUpdateOperationsInput | number
    interview?: InterviewUpdateOneRequiredWithoutQuestionsNestedInput
    response?: InterviewResponseUpdateOneWithoutQuestionNestedInput
  }

  export type InterviewQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interviewId?: StringFieldUpdateOperationsInput | string
    avatarId?: NullableStringFieldUpdateOperationsInput | string | null
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    order?: IntFieldUpdateOperationsInput | number
    response?: InterviewResponseUncheckedUpdateOneWithoutQuestionNestedInput
  }

  export type InterviewQuestionCreateManyInput = {
    id?: string
    interviewId: string
    avatarId?: string | null
    question: string
    type: $Enums.QuestionType
    order: number
  }

  export type InterviewQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatarId?: NullableStringFieldUpdateOperationsInput | string | null
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    order?: IntFieldUpdateOperationsInput | number
  }

  export type InterviewQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    interviewId?: StringFieldUpdateOperationsInput | string
    avatarId?: NullableStringFieldUpdateOperationsInput | string | null
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    order?: IntFieldUpdateOperationsInput | number
  }

  export type InterviewResponseCreateInput = {
    id?: string
    transcript?: string | null
    code?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    duration?: number | null
    respondedAt?: Date | string
    interview: InterviewCreateNestedOneWithoutResponsesInput
    question: InterviewQuestionCreateNestedOneWithoutResponseInput
  }

  export type InterviewResponseUncheckedCreateInput = {
    id?: string
    interviewId: string
    questionId: string
    transcript?: string | null
    code?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    duration?: number | null
    respondedAt?: Date | string
  }

  export type InterviewResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interview?: InterviewUpdateOneRequiredWithoutResponsesNestedInput
    question?: InterviewQuestionUpdateOneRequiredWithoutResponseNestedInput
  }

  export type InterviewResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interviewId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewResponseCreateManyInput = {
    id?: string
    interviewId: string
    questionId: string
    transcript?: string | null
    code?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    duration?: number | null
    respondedAt?: Date | string
  }

  export type InterviewResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    interviewId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewEvaluationCreateInput = {
    id?: string
    overallScore: number
    technicalScore: number
    communicationScore: number
    confidenceScore: number
    starMethodScore: number
    strengths: JsonNullValueInput | InputJsonValue
    weaknesses: JsonNullValueInput | InputJsonValue
    recommendations: JsonNullValueInput | InputJsonValue
    aiInsights?: string | null
    createdAt?: Date | string
    interview: InterviewCreateNestedOneWithoutEvaluationInput
  }

  export type InterviewEvaluationUncheckedCreateInput = {
    id?: string
    interviewId: string
    overallScore: number
    technicalScore: number
    communicationScore: number
    confidenceScore: number
    starMethodScore: number
    strengths: JsonNullValueInput | InputJsonValue
    weaknesses: JsonNullValueInput | InputJsonValue
    recommendations: JsonNullValueInput | InputJsonValue
    aiInsights?: string | null
    createdAt?: Date | string
  }

  export type InterviewEvaluationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    technicalScore?: IntFieldUpdateOperationsInput | number
    communicationScore?: IntFieldUpdateOperationsInput | number
    confidenceScore?: IntFieldUpdateOperationsInput | number
    starMethodScore?: IntFieldUpdateOperationsInput | number
    strengths?: JsonNullValueInput | InputJsonValue
    weaknesses?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    aiInsights?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interview?: InterviewUpdateOneRequiredWithoutEvaluationNestedInput
  }

  export type InterviewEvaluationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interviewId?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    technicalScore?: IntFieldUpdateOperationsInput | number
    communicationScore?: IntFieldUpdateOperationsInput | number
    confidenceScore?: IntFieldUpdateOperationsInput | number
    starMethodScore?: IntFieldUpdateOperationsInput | number
    strengths?: JsonNullValueInput | InputJsonValue
    weaknesses?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    aiInsights?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewEvaluationCreateManyInput = {
    id?: string
    interviewId: string
    overallScore: number
    technicalScore: number
    communicationScore: number
    confidenceScore: number
    starMethodScore: number
    strengths: JsonNullValueInput | InputJsonValue
    weaknesses: JsonNullValueInput | InputJsonValue
    recommendations: JsonNullValueInput | InputJsonValue
    aiInsights?: string | null
    createdAt?: Date | string
  }

  export type InterviewEvaluationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    technicalScore?: IntFieldUpdateOperationsInput | number
    communicationScore?: IntFieldUpdateOperationsInput | number
    confidenceScore?: IntFieldUpdateOperationsInput | number
    starMethodScore?: IntFieldUpdateOperationsInput | number
    strengths?: JsonNullValueInput | InputJsonValue
    weaknesses?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    aiInsights?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewEvaluationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    interviewId?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    technicalScore?: IntFieldUpdateOperationsInput | number
    communicationScore?: IntFieldUpdateOperationsInput | number
    confidenceScore?: IntFieldUpdateOperationsInput | number
    starMethodScore?: IntFieldUpdateOperationsInput | number
    strengths?: JsonNullValueInput | InputJsonValue
    weaknesses?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    aiInsights?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvatarCreateInput = {
    id?: string
    name: string
    role: string
    personality: string
    avatarUrl: string
    voiceId?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AvatarUncheckedCreateInput = {
    id?: string
    name: string
    role: string
    personality: string
    avatarUrl: string
    voiceId?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AvatarUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    voiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvatarUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    voiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvatarCreateManyInput = {
    id?: string
    name: string
    role: string
    personality: string
    avatarUrl: string
    voiceId?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AvatarUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    voiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvatarUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    voiceId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseCreateInput = {
    id?: string
    domain: string
    topic: string
    content: string
    answer?: string | null
    difficulty?: $Enums.Difficulty
    type?: $Enums.QuestionType
    codeSnippet?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.KnowledgeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeBaseUncheckedCreateInput = {
    id?: string
    domain: string
    topic: string
    content: string
    answer?: string | null
    difficulty?: $Enums.Difficulty
    type?: $Enums.QuestionType
    codeSnippet?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.KnowledgeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeBaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    codeSnippet?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumKnowledgeStatusFieldUpdateOperationsInput | $Enums.KnowledgeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    codeSnippet?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumKnowledgeStatusFieldUpdateOperationsInput | $Enums.KnowledgeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseCreateManyInput = {
    id?: string
    domain: string
    topic: string
    content: string
    answer?: string | null
    difficulty?: $Enums.Difficulty
    type?: $Enums.QuestionType
    codeSnippet?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.KnowledgeStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeBaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    codeSnippet?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumKnowledgeStatusFieldUpdateOperationsInput | $Enums.KnowledgeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    codeSnippet?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumKnowledgeStatusFieldUpdateOperationsInput | $Enums.KnowledgeStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemPromptCreateInput = {
    id?: string
    role: string
    prompt: string
    isActive?: boolean
    updatedAt?: Date | string
  }

  export type SystemPromptUncheckedCreateInput = {
    id?: string
    role: string
    prompt: string
    isActive?: boolean
    updatedAt?: Date | string
  }

  export type SystemPromptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemPromptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemPromptCreateManyInput = {
    id?: string
    role: string
    prompt: string
    isActive?: boolean
    updatedAt?: Date | string
  }

  export type SystemPromptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemPromptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    orderId: string
    paymentId?: string | null
    signature?: string | null
    amount: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
    course: CourseCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    orderId: string
    paymentId?: string | null
    signature?: string | null
    amount: number
    currency?: string
    status?: string
    userId: string
    courseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    course?: CourseUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    orderId: string
    paymentId?: string | null
    signature?: string | null
    amount: number
    currency?: string
    status?: string
    userId: string
    courseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: ForumPostCreateNestedManyWithoutCategoryInput
  }

  export type ForumCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: ForumPostUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ForumCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: ForumPostUpdateManyWithoutCategoryNestedInput
  }

  export type ForumCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: ForumPostUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ForumCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostCreateInput = {
    id?: string
    title: string
    content: string
    slug: string
    likes?: number
    views?: number
    isPinned?: boolean
    isSolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPostsInput
    category: ForumCategoryCreateNestedOneWithoutPostsInput
    comments?: ForumCommentCreateNestedManyWithoutPostInput
  }

  export type ForumPostUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    slug: string
    authorId: string
    categoryId: string
    likes?: number
    views?: number
    isPinned?: boolean
    isSolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ForumCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type ForumPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isSolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    category?: ForumCategoryUpdateOneRequiredWithoutPostsNestedInput
    comments?: ForumCommentUpdateManyWithoutPostNestedInput
  }

  export type ForumPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isSolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ForumCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ForumPostCreateManyInput = {
    id?: string
    title: string
    content: string
    slug: string
    authorId: string
    categoryId: string
    likes?: number
    views?: number
    isPinned?: boolean
    isSolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isSolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isSolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentCreateInput = {
    id?: string
    content: string
    parentId?: string | null
    isSolution?: boolean
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    post: ForumPostCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentsInput
  }

  export type ForumCommentUncheckedCreateInput = {
    id?: string
    content: string
    postId: string
    authorId: string
    parentId?: string | null
    isSolution?: boolean
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isSolution?: BoolFieldUpdateOperationsInput | boolean
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: ForumPostUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type ForumCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isSolution?: BoolFieldUpdateOperationsInput | boolean
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentCreateManyInput = {
    id?: string
    content: string
    postId: string
    authorId: string
    parentId?: string | null
    isSolution?: boolean
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isSolution?: BoolFieldUpdateOperationsInput | boolean
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isSolution?: BoolFieldUpdateOperationsInput | boolean
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateInput = {
    id?: string
    name?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: UserCreateNestedManyWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    name?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: UserUncheckedCreateNestedManyWithoutConversationsInput
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: UserUpdateManyWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: UserUncheckedUpdateManyWithoutConversationsNestedInput
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    name?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    readBy?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    senderId: string
    content: string
    readBy?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    readBy?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    readBy?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    conversationId: string
    senderId: string
    content: string
    readBy?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    readBy?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    readBy?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateCreateInput = {
    id?: string
    uniqueId: string
    courseId: string
    enrollmentId: string
    studentName: string
    courseName: string
    courseCategory?: string | null
    issueDate?: Date | string
    expiryDate?: Date | string | null
    signatureUrl?: string | null
    signatoryName?: string | null
    signatoryTitle?: string | null
    verificationUrl?: string | null
    isValid?: boolean
    grade?: string | null
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCertificatesInput
    template?: CertificateTemplateCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateInput = {
    id?: string
    uniqueId: string
    userId: string
    courseId: string
    enrollmentId: string
    studentName: string
    courseName: string
    courseCategory?: string | null
    issueDate?: Date | string
    expiryDate?: Date | string | null
    templateId?: string | null
    signatureUrl?: string | null
    signatoryName?: string | null
    signatoryTitle?: string | null
    verificationUrl?: string | null
    isValid?: boolean
    grade?: string | null
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    courseName?: StringFieldUpdateOperationsInput | string
    courseCategory?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatoryName?: NullableStringFieldUpdateOperationsInput | string | null
    signatoryTitle?: NullableStringFieldUpdateOperationsInput | string | null
    verificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCertificatesNestedInput
    template?: CertificateTemplateUpdateOneWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    courseName?: StringFieldUpdateOperationsInput | string
    courseCategory?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatoryName?: NullableStringFieldUpdateOperationsInput | string | null
    signatoryTitle?: NullableStringFieldUpdateOperationsInput | string | null
    verificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateCreateManyInput = {
    id?: string
    uniqueId: string
    userId: string
    courseId: string
    enrollmentId: string
    studentName: string
    courseName: string
    courseCategory?: string | null
    issueDate?: Date | string
    expiryDate?: Date | string | null
    templateId?: string | null
    signatureUrl?: string | null
    signatoryName?: string | null
    signatoryTitle?: string | null
    verificationUrl?: string | null
    isValid?: boolean
    grade?: string | null
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    courseName?: StringFieldUpdateOperationsInput | string
    courseCategory?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatoryName?: NullableStringFieldUpdateOperationsInput | string | null
    signatoryTitle?: NullableStringFieldUpdateOperationsInput | string | null
    verificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    courseName?: StringFieldUpdateOperationsInput | string
    courseCategory?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatoryName?: NullableStringFieldUpdateOperationsInput | string | null
    signatoryTitle?: NullableStringFieldUpdateOperationsInput | string | null
    verificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    designUrl: string
    previewUrl?: string | null
    isDefault?: boolean
    isActive?: boolean
    layout?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    certificates?: CertificateCreateNestedManyWithoutTemplateInput
  }

  export type CertificateTemplateUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    designUrl: string
    previewUrl?: string | null
    isDefault?: boolean
    isActive?: boolean
    layout?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    certificates?: CertificateUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type CertificateTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    designUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    layout?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificates?: CertificateUpdateManyWithoutTemplateNestedInput
  }

  export type CertificateTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    designUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    layout?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificates?: CertificateUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type CertificateTemplateCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    designUrl: string
    previewUrl?: string | null
    isDefault?: boolean
    isActive?: boolean
    layout?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    designUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    layout?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    designUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    layout?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateSettingsCreateInput = {
    id?: string
    instituteId?: string
    prefix?: string
    yearInId?: boolean
    sequenceDigits?: number
    currentSequence?: number
    defaultSignatureUrl?: string | null
    defaultSignatoryName?: string
    defaultSignatoryTitle?: string
    signaturePosition?: string
    logoPosition?: string
    logoSize?: string
    signatureSize?: string
    borderStyle?: string
    backgroundUrl?: string | null
    defaultValidityMonths?: number | null
    instituteName?: string
    instituteLogoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateSettingsUncheckedCreateInput = {
    id?: string
    instituteId?: string
    prefix?: string
    yearInId?: boolean
    sequenceDigits?: number
    currentSequence?: number
    defaultSignatureUrl?: string | null
    defaultSignatoryName?: string
    defaultSignatoryTitle?: string
    signaturePosition?: string
    logoPosition?: string
    logoSize?: string
    signatureSize?: string
    borderStyle?: string
    backgroundUrl?: string | null
    defaultValidityMonths?: number | null
    instituteName?: string
    instituteLogoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    prefix?: StringFieldUpdateOperationsInput | string
    yearInId?: BoolFieldUpdateOperationsInput | boolean
    sequenceDigits?: IntFieldUpdateOperationsInput | number
    currentSequence?: IntFieldUpdateOperationsInput | number
    defaultSignatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSignatoryName?: StringFieldUpdateOperationsInput | string
    defaultSignatoryTitle?: StringFieldUpdateOperationsInput | string
    signaturePosition?: StringFieldUpdateOperationsInput | string
    logoPosition?: StringFieldUpdateOperationsInput | string
    logoSize?: StringFieldUpdateOperationsInput | string
    signatureSize?: StringFieldUpdateOperationsInput | string
    borderStyle?: StringFieldUpdateOperationsInput | string
    backgroundUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultValidityMonths?: NullableIntFieldUpdateOperationsInput | number | null
    instituteName?: StringFieldUpdateOperationsInput | string
    instituteLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    prefix?: StringFieldUpdateOperationsInput | string
    yearInId?: BoolFieldUpdateOperationsInput | boolean
    sequenceDigits?: IntFieldUpdateOperationsInput | number
    currentSequence?: IntFieldUpdateOperationsInput | number
    defaultSignatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSignatoryName?: StringFieldUpdateOperationsInput | string
    defaultSignatoryTitle?: StringFieldUpdateOperationsInput | string
    signaturePosition?: StringFieldUpdateOperationsInput | string
    logoPosition?: StringFieldUpdateOperationsInput | string
    logoSize?: StringFieldUpdateOperationsInput | string
    signatureSize?: StringFieldUpdateOperationsInput | string
    borderStyle?: StringFieldUpdateOperationsInput | string
    backgroundUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultValidityMonths?: NullableIntFieldUpdateOperationsInput | number | null
    instituteName?: StringFieldUpdateOperationsInput | string
    instituteLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateSettingsCreateManyInput = {
    id?: string
    instituteId?: string
    prefix?: string
    yearInId?: boolean
    sequenceDigits?: number
    currentSequence?: number
    defaultSignatureUrl?: string | null
    defaultSignatoryName?: string
    defaultSignatoryTitle?: string
    signaturePosition?: string
    logoPosition?: string
    logoSize?: string
    signatureSize?: string
    borderStyle?: string
    backgroundUrl?: string | null
    defaultValidityMonths?: number | null
    instituteName?: string
    instituteLogoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    prefix?: StringFieldUpdateOperationsInput | string
    yearInId?: BoolFieldUpdateOperationsInput | boolean
    sequenceDigits?: IntFieldUpdateOperationsInput | number
    currentSequence?: IntFieldUpdateOperationsInput | number
    defaultSignatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSignatoryName?: StringFieldUpdateOperationsInput | string
    defaultSignatoryTitle?: StringFieldUpdateOperationsInput | string
    signaturePosition?: StringFieldUpdateOperationsInput | string
    logoPosition?: StringFieldUpdateOperationsInput | string
    logoSize?: StringFieldUpdateOperationsInput | string
    signatureSize?: StringFieldUpdateOperationsInput | string
    borderStyle?: StringFieldUpdateOperationsInput | string
    backgroundUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultValidityMonths?: NullableIntFieldUpdateOperationsInput | number | null
    instituteName?: StringFieldUpdateOperationsInput | string
    instituteLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    prefix?: StringFieldUpdateOperationsInput | string
    yearInId?: BoolFieldUpdateOperationsInput | boolean
    sequenceDigits?: IntFieldUpdateOperationsInput | number
    currentSequence?: IntFieldUpdateOperationsInput | number
    defaultSignatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultSignatoryName?: StringFieldUpdateOperationsInput | string
    defaultSignatoryTitle?: StringFieldUpdateOperationsInput | string
    signaturePosition?: StringFieldUpdateOperationsInput | string
    logoPosition?: StringFieldUpdateOperationsInput | string
    logoSize?: StringFieldUpdateOperationsInput | string
    signatureSize?: StringFieldUpdateOperationsInput | string
    borderStyle?: StringFieldUpdateOperationsInput | string
    backgroundUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultValidityMonths?: NullableIntFieldUpdateOperationsInput | number | null
    instituteName?: StringFieldUpdateOperationsInput | string
    instituteLogoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIProviderCreateInput = {
    id?: string
    name: string
    provider: string
    apiKey: string
    model: string
    endpoint?: string | null
    isActive?: boolean
    isDefault?: boolean
    usageLimit?: number | null
    currentUsage?: number
    lastResetAt?: Date | string
    temperature?: number
    maxTokens?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIProviderUncheckedCreateInput = {
    id?: string
    name: string
    provider: string
    apiKey: string
    model: string
    endpoint?: string | null
    isActive?: boolean
    isDefault?: boolean
    usageLimit?: number | null
    currentUsage?: number
    lastResetAt?: Date | string
    temperature?: number
    maxTokens?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIProviderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    currentUsage?: IntFieldUpdateOperationsInput | number
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIProviderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    currentUsage?: IntFieldUpdateOperationsInput | number
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIProviderCreateManyInput = {
    id?: string
    name: string
    provider: string
    apiKey: string
    model: string
    endpoint?: string | null
    isActive?: boolean
    isDefault?: boolean
    usageLimit?: number | null
    currentUsage?: number
    lastResetAt?: Date | string
    temperature?: number
    maxTokens?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIProviderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    currentUsage?: IntFieldUpdateOperationsInput | number
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIProviderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    currentUsage?: IntFieldUpdateOperationsInput | number
    lastResetAt?: DateTimeFieldUpdateOperationsInput | Date | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogCreateInput = {
    id?: string
    providerId: string
    userId?: string | null
    feature: string
    tokensUsed: number
    promptHash?: string | null
    createdAt?: Date | string
  }

  export type AIUsageLogUncheckedCreateInput = {
    id?: string
    providerId: string
    userId?: string | null
    feature: string
    tokensUsed: number
    promptHash?: string | null
    createdAt?: Date | string
  }

  export type AIUsageLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    promptHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    promptHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogCreateManyInput = {
    id?: string
    providerId: string
    userId?: string | null
    feature: string
    tokensUsed: number
    promptHash?: string | null
    createdAt?: Date | string
  }

  export type AIUsageLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    promptHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    feature?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    promptHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoIntegrationCreateInput = {
    id?: string
    platform: string
    name: string
    clientId?: string | null
    clientSecret?: string | null
    apiKey?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiry?: Date | string | null
    isActive?: boolean
    webhookUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoIntegrationUncheckedCreateInput = {
    id?: string
    platform: string
    name: string
    clientId?: string | null
    clientSecret?: string | null
    apiKey?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiry?: Date | string | null
    isActive?: boolean
    webhookUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoIntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoIntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoIntegrationCreateManyInput = {
    id?: string
    platform: string
    name: string
    clientId?: string | null
    clientSecret?: string | null
    apiKey?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    tokenExpiry?: Date | string | null
    isActive?: boolean
    webhookUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoIntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoIntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    clientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiveClassCreateInput = {
    id?: string
    title: string
    description?: string | null
    platform: string
    meetingLink?: string | null
    meetingId?: string | null
    password?: string | null
    scheduledAt: Date | string
    duration: number
    timezone?: string
    status?: $Enums.LiveClassStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    recordingUrl?: string | null
    recordingPassword?: string | null
    hostId?: string | null
    hostName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutLiveClassesInput
  }

  export type LiveClassUncheckedCreateInput = {
    id?: string
    courseId: string
    title: string
    description?: string | null
    platform: string
    meetingLink?: string | null
    meetingId?: string | null
    password?: string | null
    scheduledAt: Date | string
    duration: number
    timezone?: string
    status?: $Enums.LiveClassStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    recordingUrl?: string | null
    recordingPassword?: string | null
    hostId?: string | null
    hostName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiveClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    status?: EnumLiveClassStatusFieldUpdateOperationsInput | $Enums.LiveClassStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hostId?: NullableStringFieldUpdateOperationsInput | string | null
    hostName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutLiveClassesNestedInput
  }

  export type LiveClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    status?: EnumLiveClassStatusFieldUpdateOperationsInput | $Enums.LiveClassStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hostId?: NullableStringFieldUpdateOperationsInput | string | null
    hostName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiveClassCreateManyInput = {
    id?: string
    courseId: string
    title: string
    description?: string | null
    platform: string
    meetingLink?: string | null
    meetingId?: string | null
    password?: string | null
    scheduledAt: Date | string
    duration: number
    timezone?: string
    status?: $Enums.LiveClassStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    recordingUrl?: string | null
    recordingPassword?: string | null
    hostId?: string | null
    hostName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiveClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    status?: EnumLiveClassStatusFieldUpdateOperationsInput | $Enums.LiveClassStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hostId?: NullableStringFieldUpdateOperationsInput | string | null
    hostName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiveClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    status?: EnumLiveClassStatusFieldUpdateOperationsInput | $Enums.LiveClassStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hostId?: NullableStringFieldUpdateOperationsInput | string | null
    hostName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    college?: string | null
    qualification?: string | null
    dob?: Date | string | null
    location?: string | null
    gender?: string | null
    source: string
    status?: $Enums.LeadStatus
    notes?: string | null
    assignedTo?: string | null
    platform?: string | null
    campaignId?: string | null
    adGroupId?: string | null
    adId?: string | null
    formId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    college?: string | null
    qualification?: string | null
    dob?: Date | string | null
    location?: string | null
    gender?: string | null
    source: string
    status?: $Enums.LeadStatus
    notes?: string | null
    assignedTo?: string | null
    platform?: string | null
    campaignId?: string | null
    adGroupId?: string | null
    adId?: string | null
    formId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    adGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    adGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadCreateManyInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    college?: string | null
    qualification?: string | null
    dob?: Date | string | null
    location?: string | null
    gender?: string | null
    source: string
    status?: $Enums.LeadStatus
    notes?: string | null
    assignedTo?: string | null
    platform?: string | null
    campaignId?: string | null
    adGroupId?: string | null
    adId?: string | null
    formId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    adGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    adGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingIntegrationCreateInput = {
    id?: string
    platform: string
    name: string
    accessToken?: string | null
    refreshToken?: string | null
    accountId?: string | null
    pageId?: string | null
    isActive?: boolean
    webhookSecret?: string | null
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingIntegrationUncheckedCreateInput = {
    id?: string
    platform: string
    name: string
    accessToken?: string | null
    refreshToken?: string | null
    accountId?: string | null
    pageId?: string | null
    isActive?: boolean
    webhookSecret?: string | null
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingIntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingIntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingIntegrationCreateManyInput = {
    id?: string
    platform: string
    name: string
    accessToken?: string | null
    refreshToken?: string | null
    accountId?: string | null
    pageId?: string | null
    isActive?: boolean
    webhookSecret?: string | null
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingIntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingIntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    webhookSecret?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailIntegrationCreateInput = {
    id?: string
    provider: string
    name?: string | null
    host?: string | null
    port?: number | null
    user?: string | null
    pass?: string | null
    secure?: boolean
    fromEmail?: string | null
    serviceId?: string | null
    templateId?: string | null
    publicKey?: string | null
    privateKey?: string | null
    apiKey?: string | null
    isActive?: boolean
    updatedAt?: Date | string
  }

  export type EmailIntegrationUncheckedCreateInput = {
    id?: string
    provider: string
    name?: string | null
    host?: string | null
    port?: number | null
    user?: string | null
    pass?: string | null
    secure?: boolean
    fromEmail?: string | null
    serviceId?: string | null
    templateId?: string | null
    publicKey?: string | null
    privateKey?: string | null
    apiKey?: string | null
    isActive?: boolean
    updatedAt?: Date | string
  }

  export type EmailIntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: NullableStringFieldUpdateOperationsInput | string | null
    secure?: BoolFieldUpdateOperationsInput | boolean
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    privateKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailIntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: NullableStringFieldUpdateOperationsInput | string | null
    secure?: BoolFieldUpdateOperationsInput | boolean
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    privateKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailIntegrationCreateManyInput = {
    id?: string
    provider: string
    name?: string | null
    host?: string | null
    port?: number | null
    user?: string | null
    pass?: string | null
    secure?: boolean
    fromEmail?: string | null
    serviceId?: string | null
    templateId?: string | null
    publicKey?: string | null
    privateKey?: string | null
    apiKey?: string | null
    isActive?: boolean
    updatedAt?: Date | string
  }

  export type EmailIntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: NullableStringFieldUpdateOperationsInput | string | null
    secure?: BoolFieldUpdateOperationsInput | boolean
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    privateKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailIntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    user?: NullableStringFieldUpdateOperationsInput | string | null
    pass?: NullableStringFieldUpdateOperationsInput | string | null
    secure?: BoolFieldUpdateOperationsInput | boolean
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    privateKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignee?: UserCreateNestedOneWithoutAssignedTasksInput
    creator?: UserCreateNestedOneWithoutCreatedTasksInput
    lead?: LeadCreateNestedOneWithoutTasksInput
    comments?: TaskCommentCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    assignedTo?: string | null
    createdBy?: string | null
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: TaskCommentUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignee?: UserUpdateOneWithoutAssignedTasksNestedInput
    creator?: UserUpdateOneWithoutCreatedTasksNestedInput
    lead?: LeadUpdateOneWithoutTasksNestedInput
    comments?: TaskCommentUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: TaskCommentUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    assignedTo?: string | null
    createdBy?: string | null
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutTaskCommentsInput
  }

  export type TaskCommentUncheckedCreateInput = {
    id?: string
    content: string
    taskId: string
    userId: string
    createdAt?: Date | string
  }

  export type TaskCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutTaskCommentsNestedInput
  }

  export type TaskCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCommentCreateManyInput = {
    id?: string
    content: string
    taskId: string
    userId: string
    createdAt?: Date | string
  }

  export type TaskCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateInput = {
    id?: string
    title: string
    slug: string
    content: string
    summary?: string | null
    coverImage?: string | null
    status?: $Enums.BlogStatus
    tags?: NullableJsonNullValueInput | InputJsonValue
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutBlogPostsInput
  }

  export type BlogPostUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    content: string
    summary?: string | null
    coverImage?: string | null
    status?: $Enums.BlogStatus
    tags?: NullableJsonNullValueInput | InputJsonValue
    authorId: string
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBlogStatusFieldUpdateOperationsInput | $Enums.BlogStatus
    tags?: NullableJsonNullValueInput | InputJsonValue
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutBlogPostsNestedInput
  }

  export type BlogPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBlogStatusFieldUpdateOperationsInput | $Enums.BlogStatus
    tags?: NullableJsonNullValueInput | InputJsonValue
    authorId?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateManyInput = {
    id?: string
    title: string
    slug: string
    content: string
    summary?: string | null
    coverImage?: string | null
    status?: $Enums.BlogStatus
    tags?: NullableJsonNullValueInput | InputJsonValue
    authorId: string
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBlogStatusFieldUpdateOperationsInput | $Enums.BlogStatus
    tags?: NullableJsonNullValueInput | InputJsonValue
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBlogStatusFieldUpdateOperationsInput | $Enums.BlogStatus
    tags?: NullableJsonNullValueInput | InputJsonValue
    authorId?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateInput = {
    id?: string
    subject: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    category?: $Enums.TicketCategory
    assignedTo?: string | null
    internalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTicketsInput
    messages?: TicketMessageCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateInput = {
    id?: string
    subject: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    category?: $Enums.TicketCategory
    userId: string
    assignedTo?: string | null
    internalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: TicketMessageUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
    messages?: TicketMessageUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    userId?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: TicketMessageUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketCreateManyInput = {
    id?: string
    subject: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    category?: $Enums.TicketCategory
    userId: string
    assignedTo?: string | null
    internalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    userId?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMessageCreateInput = {
    id?: string
    message: string
    attachmentUrl?: string | null
    isStaffReply?: boolean
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutMessagesInput
    user?: UserCreateNestedOneWithoutSentTicketMessagesInput
  }

  export type TicketMessageUncheckedCreateInput = {
    id?: string
    message: string
    attachmentUrl?: string | null
    isStaffReply?: boolean
    ticketId: string
    createdAt?: Date | string
    userId?: string | null
  }

  export type TicketMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isStaffReply?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneWithoutSentTicketMessagesNestedInput
  }

  export type TicketMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isStaffReply?: BoolFieldUpdateOperationsInput | boolean
    ticketId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketMessageCreateManyInput = {
    id?: string
    message: string
    attachmentUrl?: string | null
    isStaffReply?: boolean
    ticketId: string
    createdAt?: Date | string
    userId?: string | null
  }

  export type TicketMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isStaffReply?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isStaffReply?: BoolFieldUpdateOperationsInput | boolean
    ticketId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentConfigCreateInput = {
    id?: string
    razorpayKeyId?: string | null
    razorpayKeySecret?: string | null
    stripePublishableKey?: string | null
    stripeSecretKey?: string | null
    activeGateway?: $Enums.Gateway
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentConfigUncheckedCreateInput = {
    id?: string
    razorpayKeyId?: string | null
    razorpayKeySecret?: string | null
    stripePublishableKey?: string | null
    stripeSecretKey?: string | null
    activeGateway?: $Enums.Gateway
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayKeySecret?: NullableStringFieldUpdateOperationsInput | string | null
    stripePublishableKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    activeGateway?: EnumGatewayFieldUpdateOperationsInput | $Enums.Gateway
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayKeySecret?: NullableStringFieldUpdateOperationsInput | string | null
    stripePublishableKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    activeGateway?: EnumGatewayFieldUpdateOperationsInput | $Enums.Gateway
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentConfigCreateManyInput = {
    id?: string
    razorpayKeyId?: string | null
    razorpayKeySecret?: string | null
    stripePublishableKey?: string | null
    stripeSecretKey?: string | null
    activeGateway?: $Enums.Gateway
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayKeySecret?: NullableStringFieldUpdateOperationsInput | string | null
    stripePublishableKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    activeGateway?: EnumGatewayFieldUpdateOperationsInput | $Enums.Gateway
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    razorpayKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    razorpayKeySecret?: NullableStringFieldUpdateOperationsInput | string | null
    stripePublishableKey?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSecretKey?: NullableStringFieldUpdateOperationsInput | string | null
    activeGateway?: EnumGatewayFieldUpdateOperationsInput | $Enums.Gateway
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateInput = {
    id?: string
    title: string
    amount: number
    category: string
    description?: string | null
    date?: Date | string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUncheckedCreateInput = {
    id?: string
    title: string
    amount: number
    category: string
    description?: string | null
    date?: Date | string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateManyInput = {
    id?: string
    title: string
    amount: number
    category: string
    description?: string | null
    date?: Date | string
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsCreateInput = {
    id?: string
    platformName?: string
    supportEmail?: string
    logoUrl?: string | null
    faviconUrl?: string | null
    primaryColor?: string
    isMaintenanceMode?: boolean
    address?: string | null
    phone?: string | null
    updatedAt?: Date | string
  }

  export type SystemSettingsUncheckedCreateInput = {
    id?: string
    platformName?: string
    supportEmail?: string
    logoUrl?: string | null
    faviconUrl?: string | null
    primaryColor?: string
    isMaintenanceMode?: boolean
    address?: string | null
    phone?: string | null
    updatedAt?: Date | string
  }

  export type SystemSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformName?: StringFieldUpdateOperationsInput | string
    supportEmail?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    isMaintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformName?: StringFieldUpdateOperationsInput | string
    supportEmail?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    isMaintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsCreateManyInput = {
    id?: string
    platformName?: string
    supportEmail?: string
    logoUrl?: string | null
    faviconUrl?: string | null
    primaryColor?: string
    isMaintenanceMode?: boolean
    address?: string | null
    phone?: string | null
    updatedAt?: Date | string
  }

  export type SystemSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformName?: StringFieldUpdateOperationsInput | string
    supportEmail?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    isMaintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformName?: StringFieldUpdateOperationsInput | string
    supportEmail?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    faviconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    isMaintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployerProfileCreateInput = {
    id?: string
    companyName: string
    website?: string | null
    description?: string | null
    logo?: string | null
    location?: string | null
    industry?: string | null
    companySize?: string | null
    status?: $Enums.EmployerStatus
    documentsVerified?: boolean
    verificationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmployerProfileInput
  }

  export type EmployerProfileUncheckedCreateInput = {
    id?: string
    userId: string
    companyName: string
    website?: string | null
    description?: string | null
    logo?: string | null
    location?: string | null
    industry?: string | null
    companySize?: string | null
    status?: $Enums.EmployerStatus
    documentsVerified?: boolean
    verificationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployerProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployerStatusFieldUpdateOperationsInput | $Enums.EmployerStatus
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployerProfileNestedInput
  }

  export type EmployerProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployerStatusFieldUpdateOperationsInput | $Enums.EmployerStatus
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployerProfileCreateManyInput = {
    id?: string
    userId: string
    companyName: string
    website?: string | null
    description?: string | null
    logo?: string | null
    location?: string | null
    industry?: string | null
    companySize?: string | null
    status?: $Enums.EmployerStatus
    documentsVerified?: boolean
    verificationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployerProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployerStatusFieldUpdateOperationsInput | $Enums.EmployerStatus
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployerProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployerStatusFieldUpdateOperationsInput | $Enums.EmployerStatus
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCreateInput = {
    id?: string
    title: string
    description: string
    requirements?: string | null
    location: string
    type?: $Enums.JobType
    experience?: string | null
    salary?: string | null
    skills?: string | null
    clientName?: string | null
    shift?: string | null
    domain?: string | null
    qualification?: string | null
    status?: $Enums.JobStatus
    publishedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employer: UserCreateNestedOneWithoutJobsInput
    applications?: JobApplicationCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    requirements?: string | null
    location: string
    type?: $Enums.JobType
    experience?: string | null
    salary?: string | null
    skills?: string | null
    clientName?: string | null
    shift?: string | null
    domain?: string | null
    qualification?: string | null
    employerId: string
    status?: $Enums.JobStatus
    publishedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: JobApplicationUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employer?: UserUpdateOneRequiredWithoutJobsNestedInput
    applications?: JobApplicationUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    employerId?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: JobApplicationUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobCreateManyInput = {
    id?: string
    title: string
    description: string
    requirements?: string | null
    location: string
    type?: $Enums.JobType
    experience?: string | null
    salary?: string | null
    skills?: string | null
    clientName?: string | null
    shift?: string | null
    domain?: string | null
    qualification?: string | null
    employerId: string
    status?: $Enums.JobStatus
    publishedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    employerId?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationCreateInput = {
    id?: string
    source?: $Enums.CandidateSource
    externalName?: string | null
    externalEmail?: string | null
    externalPhone?: string | null
    resumeUrl?: string | null
    coverLetter?: string | null
    resumeParsedText?: string | null
    atsScore?: number
    status?: $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    job: JobCreateNestedOneWithoutApplicationsInput
    applicant?: UserCreateNestedOneWithoutApplicationsInput
    interviews?: JobInterviewCreateNestedManyWithoutApplicationInput
    emailLogs?: EmailLogCreateNestedManyWithoutApplicationInput
    auditLogs?: AuditLogCreateNestedManyWithoutApplicationInput
  }

  export type JobApplicationUncheckedCreateInput = {
    id?: string
    jobId: string
    applicantId?: string | null
    source?: $Enums.CandidateSource
    externalName?: string | null
    externalEmail?: string | null
    externalPhone?: string | null
    resumeUrl?: string | null
    coverLetter?: string | null
    resumeParsedText?: string | null
    atsScore?: number
    status?: $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interviews?: JobInterviewUncheckedCreateNestedManyWithoutApplicationInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutApplicationInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type JobApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumCandidateSourceFieldUpdateOperationsInput | $Enums.CandidateSource
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    externalPhone?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeParsedText?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: FloatFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutApplicationsNestedInput
    applicant?: UserUpdateOneWithoutApplicationsNestedInput
    interviews?: JobInterviewUpdateManyWithoutApplicationNestedInput
    emailLogs?: EmailLogUpdateManyWithoutApplicationNestedInput
    auditLogs?: AuditLogUpdateManyWithoutApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    applicantId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumCandidateSourceFieldUpdateOperationsInput | $Enums.CandidateSource
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    externalPhone?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeParsedText?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: FloatFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interviews?: JobInterviewUncheckedUpdateManyWithoutApplicationNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutApplicationNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type JobApplicationCreateManyInput = {
    id?: string
    jobId: string
    applicantId?: string | null
    source?: $Enums.CandidateSource
    externalName?: string | null
    externalEmail?: string | null
    externalPhone?: string | null
    resumeUrl?: string | null
    coverLetter?: string | null
    resumeParsedText?: string | null
    atsScore?: number
    status?: $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumCandidateSourceFieldUpdateOperationsInput | $Enums.CandidateSource
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    externalPhone?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeParsedText?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: FloatFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    applicantId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumCandidateSourceFieldUpdateOperationsInput | $Enums.CandidateSource
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    externalPhone?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeParsedText?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: FloatFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobInterviewCreateInput = {
    id?: string
    roundName: string
    roundType?: $Enums.InterviewRoundType
    scheduledAt: Date | string
    duration?: number
    meetingLink?: string | null
    location?: string | null
    status?: $Enums.InterviewStatus
    feedback?: string | null
    score?: number | null
    result?: $Enums.InterviewResult | null
    createdAt?: Date | string
    updatedAt?: Date | string
    application: JobApplicationCreateNestedOneWithoutInterviewsInput
    interviewer: UserCreateNestedOneWithoutConductedJobInterviewsInput
  }

  export type JobInterviewUncheckedCreateInput = {
    id?: string
    applicationId: string
    roundName: string
    roundType?: $Enums.InterviewRoundType
    scheduledAt: Date | string
    duration?: number
    meetingLink?: string | null
    location?: string | null
    interviewerId: string
    status?: $Enums.InterviewStatus
    feedback?: string | null
    score?: number | null
    result?: $Enums.InterviewResult | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobInterviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roundName?: StringFieldUpdateOperationsInput | string
    roundType?: EnumInterviewRoundTypeFieldUpdateOperationsInput | $Enums.InterviewRoundType
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableEnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: JobApplicationUpdateOneRequiredWithoutInterviewsNestedInput
    interviewer?: UserUpdateOneRequiredWithoutConductedJobInterviewsNestedInput
  }

  export type JobInterviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    roundName?: StringFieldUpdateOperationsInput | string
    roundType?: EnumInterviewRoundTypeFieldUpdateOperationsInput | $Enums.InterviewRoundType
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    interviewerId?: StringFieldUpdateOperationsInput | string
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableEnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobInterviewCreateManyInput = {
    id?: string
    applicationId: string
    roundName: string
    roundType?: $Enums.InterviewRoundType
    scheduledAt: Date | string
    duration?: number
    meetingLink?: string | null
    location?: string | null
    interviewerId: string
    status?: $Enums.InterviewStatus
    feedback?: string | null
    score?: number | null
    result?: $Enums.InterviewResult | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobInterviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roundName?: StringFieldUpdateOperationsInput | string
    roundType?: EnumInterviewRoundTypeFieldUpdateOperationsInput | $Enums.InterviewRoundType
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableEnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobInterviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    roundName?: StringFieldUpdateOperationsInput | string
    roundType?: EnumInterviewRoundTypeFieldUpdateOperationsInput | $Enums.InterviewRoundType
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    interviewerId?: StringFieldUpdateOperationsInput | string
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableEnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogCreateInput = {
    id?: string
    jobId?: string | null
    recipientEmail: string
    recipientName?: string | null
    templateName: string
    subject: string
    body: string
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    error?: string | null
    triggeredBy?: string | null
    application?: JobApplicationCreateNestedOneWithoutEmailLogsInput
  }

  export type EmailLogUncheckedCreateInput = {
    id?: string
    jobId?: string | null
    applicationId?: string | null
    recipientEmail: string
    recipientName?: string | null
    templateName: string
    subject: string
    body: string
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    error?: string | null
    triggeredBy?: string | null
  }

  export type EmailLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    templateName?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    application?: JobApplicationUpdateOneWithoutEmailLogsNestedInput
  }

  export type EmailLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    templateName?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailLogCreateManyInput = {
    id?: string
    jobId?: string | null
    applicationId?: string | null
    recipientEmail: string
    recipientName?: string | null
    templateName: string
    subject: string
    body: string
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    error?: string | null
    triggeredBy?: string | null
  }

  export type EmailLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    templateName?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    templateName?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    entityType: string
    entityId?: string | null
    action: string
    method?: string | null
    path?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    performedBy: string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    application?: JobApplicationCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    entityType: string
    entityId?: string | null
    action: string
    method?: string | null
    path?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    applicationId?: string | null
    performedBy: string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    performedBy?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: JobApplicationUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    entityType: string
    entityId?: string | null
    action: string
    method?: string | null
    path?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    applicationId?: string | null
    performedBy: string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    performedBy?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    performedBy?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedFilterCreateInput = {
    id?: string
    name: string
    userId: string
    page: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedFilterUncheckedCreateInput = {
    id?: string
    name: string
    userId: string
    page: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedFilterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedFilterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedFilterCreateManyInput = {
    id?: string
    name: string
    userId: string
    page: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedFilterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedFilterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnrollmentListRelationFilter = {
    every?: EnrollmentWhereInput
    some?: EnrollmentWhereInput
    none?: EnrollmentWhereInput
  }

  export type InterviewListRelationFilter = {
    every?: InterviewWhereInput
    some?: InterviewWhereInput
    none?: InterviewWhereInput
  }

  export type LessonProgressListRelationFilter = {
    every?: LessonProgressWhereInput
    some?: LessonProgressWhereInput
    none?: LessonProgressWhereInput
  }

  export type ForumPostListRelationFilter = {
    every?: ForumPostWhereInput
    some?: ForumPostWhereInput
    none?: ForumPostWhereInput
  }

  export type ForumCommentListRelationFilter = {
    every?: ForumCommentWhereInput
    some?: ForumCommentWhereInput
    none?: ForumCommentWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type CertificateListRelationFilter = {
    every?: CertificateWhereInput
    some?: CertificateWhereInput
    none?: CertificateWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type TicketListRelationFilter = {
    every?: TicketWhereInput
    some?: TicketWhereInput
    none?: TicketWhereInput
  }

  export type TicketMessageListRelationFilter = {
    every?: TicketMessageWhereInput
    some?: TicketMessageWhereInput
    none?: TicketMessageWhereInput
  }

  export type EmployerProfileNullableScalarRelationFilter = {
    is?: EmployerProfileWhereInput | null
    isNot?: EmployerProfileWhereInput | null
  }

  export type JobListRelationFilter = {
    every?: JobWhereInput
    some?: JobWhereInput
    none?: JobWhereInput
  }

  export type JobApplicationListRelationFilter = {
    every?: JobApplicationWhereInput
    some?: JobApplicationWhereInput
    none?: JobApplicationWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type BlogPostListRelationFilter = {
    every?: BlogPostWhereInput
    some?: BlogPostWhereInput
    none?: BlogPostWhereInput
  }

  export type TaskCommentListRelationFilter = {
    every?: TaskCommentWhereInput
    some?: TaskCommentWhereInput
    none?: TaskCommentWhereInput
  }

  export type AssignmentSubmissionListRelationFilter = {
    every?: AssignmentSubmissionWhereInput
    some?: AssignmentSubmissionWhereInput
    none?: AssignmentSubmissionWhereInput
  }

  export type LessonCommentListRelationFilter = {
    every?: LessonCommentWhereInput
    some?: LessonCommentWhereInput
    none?: LessonCommentWhereInput
  }

  export type BatchListRelationFilter = {
    every?: BatchWhereInput
    some?: BatchWhereInput
    none?: BatchWhereInput
  }

  export type AnnouncementListRelationFilter = {
    every?: AnnouncementWhereInput
    some?: AnnouncementWhereInput
    none?: AnnouncementWhereInput
  }

  export type JobInterviewListRelationFilter = {
    every?: JobInterviewWhereInput
    some?: JobInterviewWhereInput
    none?: JobInterviewWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForumPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForumCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CertificateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssignmentSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnnouncementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobInterviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumDifficultyFilter<$PrismaModel = never> = {
    equals?: $Enums.Difficulty | EnumDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.Difficulty[] | ListEnumDifficultyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Difficulty[] | ListEnumDifficultyFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyFilter<$PrismaModel> | $Enums.Difficulty
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumCourseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseType | EnumCourseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseTypeFilter<$PrismaModel> | $Enums.CourseType
  }

  export type EnumPublishStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PublishStatus | EnumPublishStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublishStatusFilter<$PrismaModel> | $Enums.PublishStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ModuleListRelationFilter = {
    every?: ModuleWhereInput
    some?: ModuleWhereInput
    none?: ModuleWhereInput
  }

  export type LiveClassListRelationFilter = {
    every?: LiveClassWhereInput
    some?: LiveClassWhereInput
    none?: LiveClassWhereInput
  }

  export type ModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LiveClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseTitleInstructorIdCompoundUniqueInput = {
    title: string
    instructorId: string
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    discountPrice?: SortOrder
    courseCode?: SortOrder
    jobRoles?: SortOrder
    bannerUrl?: SortOrder
    averageRating?: SortOrder
    instructorId?: SortOrder
    isPublished?: SortOrder
    hasInterviewPrep?: SortOrder
    interviewPrice?: SortOrder
    bundlePrice?: SortOrder
    courseType?: SortOrder
    liveSchedule?: SortOrder
    hybridConfig?: SortOrder
    publishStatus?: SortOrder
    publishedAt?: SortOrder
    reviewNotes?: SortOrder
    submittedForReviewAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    duration?: SortOrder
    price?: SortOrder
    discountPrice?: SortOrder
    averageRating?: SortOrder
    interviewPrice?: SortOrder
    bundlePrice?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    discountPrice?: SortOrder
    courseCode?: SortOrder
    bannerUrl?: SortOrder
    averageRating?: SortOrder
    instructorId?: SortOrder
    isPublished?: SortOrder
    hasInterviewPrep?: SortOrder
    interviewPrice?: SortOrder
    bundlePrice?: SortOrder
    courseType?: SortOrder
    publishStatus?: SortOrder
    publishedAt?: SortOrder
    reviewNotes?: SortOrder
    submittedForReviewAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    discountPrice?: SortOrder
    courseCode?: SortOrder
    bannerUrl?: SortOrder
    averageRating?: SortOrder
    instructorId?: SortOrder
    isPublished?: SortOrder
    hasInterviewPrep?: SortOrder
    interviewPrice?: SortOrder
    bundlePrice?: SortOrder
    courseType?: SortOrder
    publishStatus?: SortOrder
    publishedAt?: SortOrder
    reviewNotes?: SortOrder
    submittedForReviewAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    duration?: SortOrder
    price?: SortOrder
    discountPrice?: SortOrder
    averageRating?: SortOrder
    interviewPrice?: SortOrder
    bundlePrice?: SortOrder
  }

  export type EnumDifficultyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Difficulty | EnumDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.Difficulty[] | ListEnumDifficultyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Difficulty[] | ListEnumDifficultyFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyWithAggregatesFilter<$PrismaModel> | $Enums.Difficulty
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDifficultyFilter<$PrismaModel>
    _max?: NestedEnumDifficultyFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumCourseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseType | EnumCourseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseTypeWithAggregatesFilter<$PrismaModel> | $Enums.CourseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseTypeFilter<$PrismaModel>
    _max?: NestedEnumCourseTypeFilter<$PrismaModel>
  }

  export type EnumPublishStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PublishStatus | EnumPublishStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublishStatusWithAggregatesFilter<$PrismaModel> | $Enums.PublishStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPublishStatusFilter<$PrismaModel>
    _max?: NestedEnumPublishStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CourseScalarRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BatchCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    courseId?: SortOrder
    instructorId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    description?: SortOrder
    maxStudents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchAvgOrderByAggregateInput = {
    maxStudents?: SortOrder
  }

  export type BatchMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    courseId?: SortOrder
    instructorId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    description?: SortOrder
    maxStudents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    courseId?: SortOrder
    instructorId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    description?: SortOrder
    maxStudents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchSumOrderByAggregateInput = {
    maxStudents?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CourseNullableScalarRelationFilter = {
    is?: CourseWhereInput | null
    isNot?: CourseWhereInput | null
  }

  export type BatchNullableScalarRelationFilter = {
    is?: BatchWhereInput | null
    isNot?: BatchWhereInput | null
  }

  export type AnnouncementCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    priority?: SortOrder
    courseId?: SortOrder
    batchId?: SortOrder
    instructorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnouncementMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    priority?: SortOrder
    courseId?: SortOrder
    batchId?: SortOrder
    instructorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnouncementMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    priority?: SortOrder
    courseId?: SortOrder
    batchId?: SortOrder
    instructorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonScalarRelationFilter = {
    is?: LessonWhereInput
    isNot?: LessonWhereInput
  }

  export type LessonCommentNullableScalarRelationFilter = {
    is?: LessonCommentWhereInput | null
    isNot?: LessonCommentWhereInput | null
  }

  export type LessonCommentCountOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    parentId?: SortOrder
    isPinned?: SortOrder
    isInstructorResponse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    parentId?: SortOrder
    isPinned?: SortOrder
    isInstructorResponse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonCommentMinOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    parentId?: SortOrder
    isPinned?: SortOrder
    isInstructorResponse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonListRelationFilter = {
    every?: LessonWhereInput
    some?: LessonWhereInput
    none?: LessonWhereInput
  }

  export type LessonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleCourseIdOrderIndexCompoundUniqueInput = {
    courseId: string
    orderIndex: number
  }

  export type ModuleCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    orderIndex?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleAvgOrderByAggregateInput = {
    orderIndex?: SortOrder
  }

  export type ModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    orderIndex?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    orderIndex?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleSumOrderByAggregateInput = {
    orderIndex?: SortOrder
  }

  export type EnumLessonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeFilter<$PrismaModel> | $Enums.LessonType
  }

  export type ModuleScalarRelationFilter = {
    is?: ModuleWhereInput
    isNot?: ModuleWhereInput
  }

  export type QuizListRelationFilter = {
    every?: QuizWhereInput
    some?: QuizWhereInput
    none?: QuizWhereInput
  }

  export type QuizOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonCountOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    videoUrl?: SortOrder
    duration?: SortOrder
    order?: SortOrder
    type?: SortOrder
    isPublished?: SortOrder
    isPreview?: SortOrder
    settings?: SortOrder
    resources?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonAvgOrderByAggregateInput = {
    duration?: SortOrder
    order?: SortOrder
  }

  export type LessonMaxOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    videoUrl?: SortOrder
    duration?: SortOrder
    order?: SortOrder
    type?: SortOrder
    isPublished?: SortOrder
    isPreview?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonMinOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    videoUrl?: SortOrder
    duration?: SortOrder
    order?: SortOrder
    type?: SortOrder
    isPublished?: SortOrder
    isPreview?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonSumOrderByAggregateInput = {
    duration?: SortOrder
    order?: SortOrder
  }

  export type EnumLessonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeWithAggregatesFilter<$PrismaModel> | $Enums.LessonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLessonTypeFilter<$PrismaModel>
    _max?: NestedEnumLessonTypeFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type QuizCountOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    question?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    explanation?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizMaxOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    question?: SortOrder
    correctAnswer?: SortOrder
    explanation?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizMinOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    question?: SortOrder
    correctAnswer?: SortOrder
    explanation?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type AssignmentSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    fileUrl?: SortOrder
    grade?: SortOrder
    feedback?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssignmentSubmissionAvgOrderByAggregateInput = {
    grade?: SortOrder
  }

  export type AssignmentSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    fileUrl?: SortOrder
    grade?: SortOrder
    feedback?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssignmentSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    fileUrl?: SortOrder
    grade?: SortOrder
    feedback?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssignmentSubmissionSumOrderByAggregateInput = {
    grade?: SortOrder
  }

  export type EnumEnrollmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EnrollmentStatus | EnumEnrollmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnrollmentStatusFilter<$PrismaModel> | $Enums.EnrollmentStatus
  }

  export type EnrollmentUserIdCourseIdCompoundUniqueInput = {
    userId: string
    courseId: string
  }

  export type EnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
    status?: SortOrder
    hasInterviewAccess?: SortOrder
    batchId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
  }

  export type EnrollmentAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type EnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
    status?: SortOrder
    hasInterviewAccess?: SortOrder
    batchId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
  }

  export type EnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
    status?: SortOrder
    hasInterviewAccess?: SortOrder
    batchId?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
  }

  export type EnrollmentSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type EnumEnrollmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnrollmentStatus | EnumEnrollmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnrollmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EnrollmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnrollmentStatusFilter<$PrismaModel>
    _max?: NestedEnumEnrollmentStatusFilter<$PrismaModel>
  }

  export type LessonProgressUserIdLessonIdCompoundUniqueInput = {
    userId: string
    lessonId: string
  }

  export type LessonProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    completed?: SortOrder
    score?: SortOrder
    timeSpent?: SortOrder
    lastAccessedAt?: SortOrder
  }

  export type LessonProgressAvgOrderByAggregateInput = {
    score?: SortOrder
    timeSpent?: SortOrder
  }

  export type LessonProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    completed?: SortOrder
    score?: SortOrder
    timeSpent?: SortOrder
    lastAccessedAt?: SortOrder
  }

  export type LessonProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    completed?: SortOrder
    score?: SortOrder
    timeSpent?: SortOrder
    lastAccessedAt?: SortOrder
  }

  export type LessonProgressSumOrderByAggregateInput = {
    score?: SortOrder
    timeSpent?: SortOrder
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumInterviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewStatus | EnumInterviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterviewStatus[] | ListEnumInterviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterviewStatus[] | ListEnumInterviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterviewStatusFilter<$PrismaModel> | $Enums.InterviewStatus
  }

  export type InterviewQuestionListRelationFilter = {
    every?: InterviewQuestionWhereInput
    some?: InterviewQuestionWhereInput
    none?: InterviewQuestionWhereInput
  }

  export type InterviewResponseListRelationFilter = {
    every?: InterviewResponseWhereInput
    some?: InterviewResponseWhereInput
    none?: InterviewResponseWhereInput
  }

  export type InterviewEvaluationNullableScalarRelationFilter = {
    is?: InterviewEvaluationWhereInput | null
    isNot?: InterviewEvaluationWhereInput | null
  }

  export type InterviewQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterviewResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterviewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    domain?: SortOrder
    company?: SortOrder
    role?: SortOrder
    technology?: SortOrder
    jobDescription?: SortOrder
    resumeUrl?: SortOrder
    difficulty?: SortOrder
    panelCount?: SortOrder
    linkedCourseId?: SortOrder
    duration?: SortOrder
    selectedAvatars?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type InterviewAvgOrderByAggregateInput = {
    panelCount?: SortOrder
    duration?: SortOrder
  }

  export type InterviewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    domain?: SortOrder
    company?: SortOrder
    role?: SortOrder
    technology?: SortOrder
    jobDescription?: SortOrder
    resumeUrl?: SortOrder
    difficulty?: SortOrder
    panelCount?: SortOrder
    linkedCourseId?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type InterviewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    domain?: SortOrder
    company?: SortOrder
    role?: SortOrder
    technology?: SortOrder
    jobDescription?: SortOrder
    resumeUrl?: SortOrder
    difficulty?: SortOrder
    panelCount?: SortOrder
    linkedCourseId?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type InterviewSumOrderByAggregateInput = {
    panelCount?: SortOrder
    duration?: SortOrder
  }

  export type EnumInterviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewStatus | EnumInterviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterviewStatus[] | ListEnumInterviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterviewStatus[] | ListEnumInterviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.InterviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterviewStatusFilter<$PrismaModel>
    _max?: NestedEnumInterviewStatusFilter<$PrismaModel>
  }

  export type EnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type InterviewScalarRelationFilter = {
    is?: InterviewWhereInput
    isNot?: InterviewWhereInput
  }

  export type InterviewResponseNullableScalarRelationFilter = {
    is?: InterviewResponseWhereInput | null
    isNot?: InterviewResponseWhereInput | null
  }

  export type InterviewQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    interviewId?: SortOrder
    avatarId?: SortOrder
    question?: SortOrder
    type?: SortOrder
    order?: SortOrder
  }

  export type InterviewQuestionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type InterviewQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    interviewId?: SortOrder
    avatarId?: SortOrder
    question?: SortOrder
    type?: SortOrder
    order?: SortOrder
  }

  export type InterviewQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    interviewId?: SortOrder
    avatarId?: SortOrder
    question?: SortOrder
    type?: SortOrder
    order?: SortOrder
  }

  export type InterviewQuestionSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }

  export type InterviewQuestionScalarRelationFilter = {
    is?: InterviewQuestionWhereInput
    isNot?: InterviewQuestionWhereInput
  }

  export type InterviewResponseCountOrderByAggregateInput = {
    id?: SortOrder
    interviewId?: SortOrder
    questionId?: SortOrder
    transcript?: SortOrder
    code?: SortOrder
    videoUrl?: SortOrder
    audioUrl?: SortOrder
    duration?: SortOrder
    respondedAt?: SortOrder
  }

  export type InterviewResponseAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type InterviewResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    interviewId?: SortOrder
    questionId?: SortOrder
    transcript?: SortOrder
    code?: SortOrder
    videoUrl?: SortOrder
    audioUrl?: SortOrder
    duration?: SortOrder
    respondedAt?: SortOrder
  }

  export type InterviewResponseMinOrderByAggregateInput = {
    id?: SortOrder
    interviewId?: SortOrder
    questionId?: SortOrder
    transcript?: SortOrder
    code?: SortOrder
    videoUrl?: SortOrder
    audioUrl?: SortOrder
    duration?: SortOrder
    respondedAt?: SortOrder
  }

  export type InterviewResponseSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type InterviewEvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    interviewId?: SortOrder
    overallScore?: SortOrder
    technicalScore?: SortOrder
    communicationScore?: SortOrder
    confidenceScore?: SortOrder
    starMethodScore?: SortOrder
    strengths?: SortOrder
    weaknesses?: SortOrder
    recommendations?: SortOrder
    aiInsights?: SortOrder
    createdAt?: SortOrder
  }

  export type InterviewEvaluationAvgOrderByAggregateInput = {
    overallScore?: SortOrder
    technicalScore?: SortOrder
    communicationScore?: SortOrder
    confidenceScore?: SortOrder
    starMethodScore?: SortOrder
  }

  export type InterviewEvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    interviewId?: SortOrder
    overallScore?: SortOrder
    technicalScore?: SortOrder
    communicationScore?: SortOrder
    confidenceScore?: SortOrder
    starMethodScore?: SortOrder
    aiInsights?: SortOrder
    createdAt?: SortOrder
  }

  export type InterviewEvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    interviewId?: SortOrder
    overallScore?: SortOrder
    technicalScore?: SortOrder
    communicationScore?: SortOrder
    confidenceScore?: SortOrder
    starMethodScore?: SortOrder
    aiInsights?: SortOrder
    createdAt?: SortOrder
  }

  export type InterviewEvaluationSumOrderByAggregateInput = {
    overallScore?: SortOrder
    technicalScore?: SortOrder
    communicationScore?: SortOrder
    confidenceScore?: SortOrder
    starMethodScore?: SortOrder
  }

  export type AvatarCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    personality?: SortOrder
    avatarUrl?: SortOrder
    voiceId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AvatarMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    personality?: SortOrder
    avatarUrl?: SortOrder
    voiceId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AvatarMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    personality?: SortOrder
    avatarUrl?: SortOrder
    voiceId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumKnowledgeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KnowledgeStatus | EnumKnowledgeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KnowledgeStatus[] | ListEnumKnowledgeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KnowledgeStatus[] | ListEnumKnowledgeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKnowledgeStatusFilter<$PrismaModel> | $Enums.KnowledgeStatus
  }

  export type KnowledgeBaseCountOrderByAggregateInput = {
    id?: SortOrder
    domain?: SortOrder
    topic?: SortOrder
    content?: SortOrder
    answer?: SortOrder
    difficulty?: SortOrder
    type?: SortOrder
    codeSnippet?: SortOrder
    tags?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeBaseMaxOrderByAggregateInput = {
    id?: SortOrder
    domain?: SortOrder
    topic?: SortOrder
    content?: SortOrder
    answer?: SortOrder
    difficulty?: SortOrder
    type?: SortOrder
    codeSnippet?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeBaseMinOrderByAggregateInput = {
    id?: SortOrder
    domain?: SortOrder
    topic?: SortOrder
    content?: SortOrder
    answer?: SortOrder
    difficulty?: SortOrder
    type?: SortOrder
    codeSnippet?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumKnowledgeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KnowledgeStatus | EnumKnowledgeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KnowledgeStatus[] | ListEnumKnowledgeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KnowledgeStatus[] | ListEnumKnowledgeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKnowledgeStatusWithAggregatesFilter<$PrismaModel> | $Enums.KnowledgeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKnowledgeStatusFilter<$PrismaModel>
    _max?: NestedEnumKnowledgeStatusFilter<$PrismaModel>
  }

  export type SystemPromptCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    prompt?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemPromptMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    prompt?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemPromptMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    prompt?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrder
    signature?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrder
    signature?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrder
    signature?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ForumCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumCategoryScalarRelationFilter = {
    is?: ForumCategoryWhereInput
    isNot?: ForumCategoryWhereInput
  }

  export type ForumPostCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    slug?: SortOrder
    authorId?: SortOrder
    categoryId?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    isSolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumPostAvgOrderByAggregateInput = {
    likes?: SortOrder
    views?: SortOrder
  }

  export type ForumPostMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    slug?: SortOrder
    authorId?: SortOrder
    categoryId?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    isSolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumPostMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    slug?: SortOrder
    authorId?: SortOrder
    categoryId?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    isPinned?: SortOrder
    isSolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumPostSumOrderByAggregateInput = {
    likes?: SortOrder
    views?: SortOrder
  }

  export type ForumPostScalarRelationFilter = {
    is?: ForumPostWhereInput
    isNot?: ForumPostWhereInput
  }

  export type ForumCommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    isSolution?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumCommentAvgOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type ForumCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    isSolution?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumCommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    isSolution?: SortOrder
    likes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumCommentSumOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationScalarRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    readBy?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CertificateTemplateNullableScalarRelationFilter = {
    is?: CertificateTemplateWhereInput | null
    isNot?: CertificateTemplateWhereInput | null
  }

  export type CertificateCountOrderByAggregateInput = {
    id?: SortOrder
    uniqueId?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrollmentId?: SortOrder
    studentName?: SortOrder
    courseName?: SortOrder
    courseCategory?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrder
    templateId?: SortOrder
    signatureUrl?: SortOrder
    signatoryName?: SortOrder
    signatoryTitle?: SortOrder
    verificationUrl?: SortOrder
    isValid?: SortOrder
    grade?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificateAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type CertificateMaxOrderByAggregateInput = {
    id?: SortOrder
    uniqueId?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrollmentId?: SortOrder
    studentName?: SortOrder
    courseName?: SortOrder
    courseCategory?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrder
    templateId?: SortOrder
    signatureUrl?: SortOrder
    signatoryName?: SortOrder
    signatoryTitle?: SortOrder
    verificationUrl?: SortOrder
    isValid?: SortOrder
    grade?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificateMinOrderByAggregateInput = {
    id?: SortOrder
    uniqueId?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrollmentId?: SortOrder
    studentName?: SortOrder
    courseName?: SortOrder
    courseCategory?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrder
    templateId?: SortOrder
    signatureUrl?: SortOrder
    signatoryName?: SortOrder
    signatoryTitle?: SortOrder
    verificationUrl?: SortOrder
    isValid?: SortOrder
    grade?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificateSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type CertificateTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    designUrl?: SortOrder
    previewUrl?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    layout?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificateTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    designUrl?: SortOrder
    previewUrl?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificateTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    designUrl?: SortOrder
    previewUrl?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificateSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    instituteId?: SortOrder
    prefix?: SortOrder
    yearInId?: SortOrder
    sequenceDigits?: SortOrder
    currentSequence?: SortOrder
    defaultSignatureUrl?: SortOrder
    defaultSignatoryName?: SortOrder
    defaultSignatoryTitle?: SortOrder
    signaturePosition?: SortOrder
    logoPosition?: SortOrder
    logoSize?: SortOrder
    signatureSize?: SortOrder
    borderStyle?: SortOrder
    backgroundUrl?: SortOrder
    defaultValidityMonths?: SortOrder
    instituteName?: SortOrder
    instituteLogoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificateSettingsAvgOrderByAggregateInput = {
    sequenceDigits?: SortOrder
    currentSequence?: SortOrder
    defaultValidityMonths?: SortOrder
  }

  export type CertificateSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    instituteId?: SortOrder
    prefix?: SortOrder
    yearInId?: SortOrder
    sequenceDigits?: SortOrder
    currentSequence?: SortOrder
    defaultSignatureUrl?: SortOrder
    defaultSignatoryName?: SortOrder
    defaultSignatoryTitle?: SortOrder
    signaturePosition?: SortOrder
    logoPosition?: SortOrder
    logoSize?: SortOrder
    signatureSize?: SortOrder
    borderStyle?: SortOrder
    backgroundUrl?: SortOrder
    defaultValidityMonths?: SortOrder
    instituteName?: SortOrder
    instituteLogoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificateSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    instituteId?: SortOrder
    prefix?: SortOrder
    yearInId?: SortOrder
    sequenceDigits?: SortOrder
    currentSequence?: SortOrder
    defaultSignatureUrl?: SortOrder
    defaultSignatoryName?: SortOrder
    defaultSignatoryTitle?: SortOrder
    signaturePosition?: SortOrder
    logoPosition?: SortOrder
    logoSize?: SortOrder
    signatureSize?: SortOrder
    borderStyle?: SortOrder
    backgroundUrl?: SortOrder
    defaultValidityMonths?: SortOrder
    instituteName?: SortOrder
    instituteLogoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificateSettingsSumOrderByAggregateInput = {
    sequenceDigits?: SortOrder
    currentSequence?: SortOrder
    defaultValidityMonths?: SortOrder
  }

  export type AIProviderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    provider?: SortOrder
    apiKey?: SortOrder
    model?: SortOrder
    endpoint?: SortOrder
    isActive?: SortOrder
    isDefault?: SortOrder
    usageLimit?: SortOrder
    currentUsage?: SortOrder
    lastResetAt?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIProviderAvgOrderByAggregateInput = {
    usageLimit?: SortOrder
    currentUsage?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
  }

  export type AIProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    provider?: SortOrder
    apiKey?: SortOrder
    model?: SortOrder
    endpoint?: SortOrder
    isActive?: SortOrder
    isDefault?: SortOrder
    usageLimit?: SortOrder
    currentUsage?: SortOrder
    lastResetAt?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIProviderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    provider?: SortOrder
    apiKey?: SortOrder
    model?: SortOrder
    endpoint?: SortOrder
    isActive?: SortOrder
    isDefault?: SortOrder
    usageLimit?: SortOrder
    currentUsage?: SortOrder
    lastResetAt?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIProviderSumOrderByAggregateInput = {
    usageLimit?: SortOrder
    currentUsage?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
  }

  export type AIUsageLogCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    tokensUsed?: SortOrder
    promptHash?: SortOrder
    createdAt?: SortOrder
  }

  export type AIUsageLogAvgOrderByAggregateInput = {
    tokensUsed?: SortOrder
  }

  export type AIUsageLogMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    tokensUsed?: SortOrder
    promptHash?: SortOrder
    createdAt?: SortOrder
  }

  export type AIUsageLogMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    tokensUsed?: SortOrder
    promptHash?: SortOrder
    createdAt?: SortOrder
  }

  export type AIUsageLogSumOrderByAggregateInput = {
    tokensUsed?: SortOrder
  }

  export type VideoIntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    name?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    apiKey?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiry?: SortOrder
    isActive?: SortOrder
    webhookUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoIntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    name?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    apiKey?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiry?: SortOrder
    isActive?: SortOrder
    webhookUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoIntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    name?: SortOrder
    clientId?: SortOrder
    clientSecret?: SortOrder
    apiKey?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiry?: SortOrder
    isActive?: SortOrder
    webhookUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLiveClassStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LiveClassStatus | EnumLiveClassStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LiveClassStatus[] | ListEnumLiveClassStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LiveClassStatus[] | ListEnumLiveClassStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLiveClassStatusFilter<$PrismaModel> | $Enums.LiveClassStatus
  }

  export type LiveClassCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    platform?: SortOrder
    meetingLink?: SortOrder
    meetingId?: SortOrder
    password?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    recordingUrl?: SortOrder
    recordingPassword?: SortOrder
    hostId?: SortOrder
    hostName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LiveClassAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type LiveClassMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    platform?: SortOrder
    meetingLink?: SortOrder
    meetingId?: SortOrder
    password?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    recordingUrl?: SortOrder
    recordingPassword?: SortOrder
    hostId?: SortOrder
    hostName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LiveClassMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    platform?: SortOrder
    meetingLink?: SortOrder
    meetingId?: SortOrder
    password?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    recordingUrl?: SortOrder
    recordingPassword?: SortOrder
    hostId?: SortOrder
    hostName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LiveClassSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumLiveClassStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LiveClassStatus | EnumLiveClassStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LiveClassStatus[] | ListEnumLiveClassStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LiveClassStatus[] | ListEnumLiveClassStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLiveClassStatusWithAggregatesFilter<$PrismaModel> | $Enums.LiveClassStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLiveClassStatusFilter<$PrismaModel>
    _max?: NestedEnumLiveClassStatusFilter<$PrismaModel>
  }

  export type EnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type LeadCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    college?: SortOrder
    qualification?: SortOrder
    dob?: SortOrder
    location?: SortOrder
    gender?: SortOrder
    source?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    assignedTo?: SortOrder
    platform?: SortOrder
    campaignId?: SortOrder
    adGroupId?: SortOrder
    adId?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    college?: SortOrder
    qualification?: SortOrder
    dob?: SortOrder
    location?: SortOrder
    gender?: SortOrder
    source?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    assignedTo?: SortOrder
    platform?: SortOrder
    campaignId?: SortOrder
    adGroupId?: SortOrder
    adId?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    college?: SortOrder
    qualification?: SortOrder
    dob?: SortOrder
    location?: SortOrder
    gender?: SortOrder
    source?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    assignedTo?: SortOrder
    platform?: SortOrder
    campaignId?: SortOrder
    adGroupId?: SortOrder
    adId?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type MarketingIntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    name?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    accountId?: SortOrder
    pageId?: SortOrder
    isActive?: SortOrder
    webhookSecret?: SortOrder
    lastSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingIntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    name?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    accountId?: SortOrder
    pageId?: SortOrder
    isActive?: SortOrder
    webhookSecret?: SortOrder
    lastSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingIntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    name?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    accountId?: SortOrder
    pageId?: SortOrder
    isActive?: SortOrder
    webhookSecret?: SortOrder
    lastSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailIntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    name?: SortOrder
    host?: SortOrder
    port?: SortOrder
    user?: SortOrder
    pass?: SortOrder
    secure?: SortOrder
    fromEmail?: SortOrder
    serviceId?: SortOrder
    templateId?: SortOrder
    publicKey?: SortOrder
    privateKey?: SortOrder
    apiKey?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailIntegrationAvgOrderByAggregateInput = {
    port?: SortOrder
  }

  export type EmailIntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    name?: SortOrder
    host?: SortOrder
    port?: SortOrder
    user?: SortOrder
    pass?: SortOrder
    secure?: SortOrder
    fromEmail?: SortOrder
    serviceId?: SortOrder
    templateId?: SortOrder
    publicKey?: SortOrder
    privateKey?: SortOrder
    apiKey?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailIntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    name?: SortOrder
    host?: SortOrder
    port?: SortOrder
    user?: SortOrder
    pass?: SortOrder
    secure?: SortOrder
    fromEmail?: SortOrder
    serviceId?: SortOrder
    templateId?: SortOrder
    publicKey?: SortOrder
    privateKey?: SortOrder
    apiKey?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailIntegrationSumOrderByAggregateInput = {
    port?: SortOrder
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type LeadNullableScalarRelationFilter = {
    is?: LeadWhereInput | null
    isNot?: LeadWhereInput | null
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    assignedTo?: SortOrder
    createdBy?: SortOrder
    leadId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    assignedTo?: SortOrder
    createdBy?: SortOrder
    leadId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    assignedTo?: SortOrder
    createdBy?: SortOrder
    leadId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type TaskScalarRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type TaskCommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskCommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    taskId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumBlogStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BlogStatus | EnumBlogStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BlogStatus[] | ListEnumBlogStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BlogStatus[] | ListEnumBlogStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBlogStatusFilter<$PrismaModel> | $Enums.BlogStatus
  }

  export type BlogPostCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    coverImage?: SortOrder
    status?: SortOrder
    tags?: SortOrder
    authorId?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogPostMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    coverImage?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogPostMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    coverImage?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBlogStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BlogStatus | EnumBlogStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BlogStatus[] | ListEnumBlogStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BlogStatus[] | ListEnumBlogStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBlogStatusWithAggregatesFilter<$PrismaModel> | $Enums.BlogStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBlogStatusFilter<$PrismaModel>
    _max?: NestedEnumBlogStatusFilter<$PrismaModel>
  }

  export type EnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type EnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type EnumTicketCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketCategory | EnumTicketCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketCategoryFilter<$PrismaModel> | $Enums.TicketCategory
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    userId?: SortOrder
    assignedTo?: SortOrder
    internalNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    userId?: SortOrder
    assignedTo?: SortOrder
    internalNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    userId?: SortOrder
    assignedTo?: SortOrder
    internalNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type EnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type EnumTicketCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketCategory | EnumTicketCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TicketCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketCategoryFilter<$PrismaModel>
    _max?: NestedEnumTicketCategoryFilter<$PrismaModel>
  }

  export type TicketScalarRelationFilter = {
    is?: TicketWhereInput
    isNot?: TicketWhereInput
  }

  export type TicketMessageCountOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    attachmentUrl?: SortOrder
    isStaffReply?: SortOrder
    ticketId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type TicketMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    attachmentUrl?: SortOrder
    isStaffReply?: SortOrder
    ticketId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type TicketMessageMinOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    attachmentUrl?: SortOrder
    isStaffReply?: SortOrder
    ticketId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type EnumGatewayFilter<$PrismaModel = never> = {
    equals?: $Enums.Gateway | EnumGatewayFieldRefInput<$PrismaModel>
    in?: $Enums.Gateway[] | ListEnumGatewayFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gateway[] | ListEnumGatewayFieldRefInput<$PrismaModel>
    not?: NestedEnumGatewayFilter<$PrismaModel> | $Enums.Gateway
  }

  export type PaymentConfigCountOrderByAggregateInput = {
    id?: SortOrder
    razorpayKeyId?: SortOrder
    razorpayKeySecret?: SortOrder
    stripePublishableKey?: SortOrder
    stripeSecretKey?: SortOrder
    activeGateway?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    razorpayKeyId?: SortOrder
    razorpayKeySecret?: SortOrder
    stripePublishableKey?: SortOrder
    stripeSecretKey?: SortOrder
    activeGateway?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentConfigMinOrderByAggregateInput = {
    id?: SortOrder
    razorpayKeyId?: SortOrder
    razorpayKeySecret?: SortOrder
    stripePublishableKey?: SortOrder
    stripeSecretKey?: SortOrder
    activeGateway?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumGatewayWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gateway | EnumGatewayFieldRefInput<$PrismaModel>
    in?: $Enums.Gateway[] | ListEnumGatewayFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gateway[] | ListEnumGatewayFieldRefInput<$PrismaModel>
    not?: NestedEnumGatewayWithAggregatesFilter<$PrismaModel> | $Enums.Gateway
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGatewayFilter<$PrismaModel>
    _max?: NestedEnumGatewayFilter<$PrismaModel>
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrder
    date?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrder
    date?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    description?: SortOrder
    date?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SystemSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    platformName?: SortOrder
    supportEmail?: SortOrder
    logoUrl?: SortOrder
    faviconUrl?: SortOrder
    primaryColor?: SortOrder
    isMaintenanceMode?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    platformName?: SortOrder
    supportEmail?: SortOrder
    logoUrl?: SortOrder
    faviconUrl?: SortOrder
    primaryColor?: SortOrder
    isMaintenanceMode?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    platformName?: SortOrder
    supportEmail?: SortOrder
    logoUrl?: SortOrder
    faviconUrl?: SortOrder
    primaryColor?: SortOrder
    isMaintenanceMode?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEmployerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployerStatus | EnumEmployerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployerStatus[] | ListEnumEmployerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployerStatus[] | ListEnumEmployerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployerStatusFilter<$PrismaModel> | $Enums.EmployerStatus
  }

  export type EmployerProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    website?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    location?: SortOrder
    industry?: SortOrder
    companySize?: SortOrder
    status?: SortOrder
    documentsVerified?: SortOrder
    verificationNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployerProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    website?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    location?: SortOrder
    industry?: SortOrder
    companySize?: SortOrder
    status?: SortOrder
    documentsVerified?: SortOrder
    verificationNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployerProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    website?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    location?: SortOrder
    industry?: SortOrder
    companySize?: SortOrder
    status?: SortOrder
    documentsVerified?: SortOrder
    verificationNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEmployerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployerStatus | EnumEmployerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployerStatus[] | ListEnumEmployerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployerStatus[] | ListEnumEmployerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployerStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmployerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmployerStatusFilter<$PrismaModel>
    _max?: NestedEnumEmployerStatusFilter<$PrismaModel>
  }

  export type EnumJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeFilter<$PrismaModel> | $Enums.JobType
  }

  export type EnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type JobCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirements?: SortOrder
    location?: SortOrder
    type?: SortOrder
    experience?: SortOrder
    salary?: SortOrder
    skills?: SortOrder
    clientName?: SortOrder
    shift?: SortOrder
    domain?: SortOrder
    qualification?: SortOrder
    employerId?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirements?: SortOrder
    location?: SortOrder
    type?: SortOrder
    experience?: SortOrder
    salary?: SortOrder
    skills?: SortOrder
    clientName?: SortOrder
    shift?: SortOrder
    domain?: SortOrder
    qualification?: SortOrder
    employerId?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirements?: SortOrder
    location?: SortOrder
    type?: SortOrder
    experience?: SortOrder
    salary?: SortOrder
    skills?: SortOrder
    clientName?: SortOrder
    shift?: SortOrder
    domain?: SortOrder
    qualification?: SortOrder
    employerId?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.JobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobTypeFilter<$PrismaModel>
    _max?: NestedEnumJobTypeFilter<$PrismaModel>
  }

  export type EnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type EnumCandidateSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.CandidateSource | EnumCandidateSourceFieldRefInput<$PrismaModel>
    in?: $Enums.CandidateSource[] | ListEnumCandidateSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.CandidateSource[] | ListEnumCandidateSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumCandidateSourceFilter<$PrismaModel> | $Enums.CandidateSource
  }

  export type EnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type JobScalarRelationFilter = {
    is?: JobWhereInput
    isNot?: JobWhereInput
  }

  export type EmailLogListRelationFilter = {
    every?: EmailLogWhereInput
    some?: EmailLogWhereInput
    none?: EmailLogWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type EmailLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobApplicationJobIdApplicantIdCompoundUniqueInput = {
    jobId: string
    applicantId: string
  }

  export type JobApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    applicantId?: SortOrder
    source?: SortOrder
    externalName?: SortOrder
    externalEmail?: SortOrder
    externalPhone?: SortOrder
    resumeUrl?: SortOrder
    coverLetter?: SortOrder
    resumeParsedText?: SortOrder
    atsScore?: SortOrder
    status?: SortOrder
    statusHistory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobApplicationAvgOrderByAggregateInput = {
    atsScore?: SortOrder
  }

  export type JobApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    applicantId?: SortOrder
    source?: SortOrder
    externalName?: SortOrder
    externalEmail?: SortOrder
    externalPhone?: SortOrder
    resumeUrl?: SortOrder
    coverLetter?: SortOrder
    resumeParsedText?: SortOrder
    atsScore?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    applicantId?: SortOrder
    source?: SortOrder
    externalName?: SortOrder
    externalEmail?: SortOrder
    externalPhone?: SortOrder
    resumeUrl?: SortOrder
    coverLetter?: SortOrder
    resumeParsedText?: SortOrder
    atsScore?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobApplicationSumOrderByAggregateInput = {
    atsScore?: SortOrder
  }

  export type EnumCandidateSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CandidateSource | EnumCandidateSourceFieldRefInput<$PrismaModel>
    in?: $Enums.CandidateSource[] | ListEnumCandidateSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.CandidateSource[] | ListEnumCandidateSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumCandidateSourceWithAggregatesFilter<$PrismaModel> | $Enums.CandidateSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCandidateSourceFilter<$PrismaModel>
    _max?: NestedEnumCandidateSourceFilter<$PrismaModel>
  }

  export type EnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type EnumInterviewRoundTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewRoundType | EnumInterviewRoundTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InterviewRoundType[] | ListEnumInterviewRoundTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterviewRoundType[] | ListEnumInterviewRoundTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInterviewRoundTypeFilter<$PrismaModel> | $Enums.InterviewRoundType
  }

  export type EnumInterviewResultNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewResult | EnumInterviewResultFieldRefInput<$PrismaModel> | null
    in?: $Enums.InterviewResult[] | ListEnumInterviewResultFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InterviewResult[] | ListEnumInterviewResultFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInterviewResultNullableFilter<$PrismaModel> | $Enums.InterviewResult | null
  }

  export type JobApplicationScalarRelationFilter = {
    is?: JobApplicationWhereInput
    isNot?: JobApplicationWhereInput
  }

  export type JobInterviewCountOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    roundName?: SortOrder
    roundType?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    meetingLink?: SortOrder
    location?: SortOrder
    interviewerId?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
    score?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobInterviewAvgOrderByAggregateInput = {
    duration?: SortOrder
    score?: SortOrder
  }

  export type JobInterviewMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    roundName?: SortOrder
    roundType?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    meetingLink?: SortOrder
    location?: SortOrder
    interviewerId?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
    score?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobInterviewMinOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    roundName?: SortOrder
    roundType?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    meetingLink?: SortOrder
    location?: SortOrder
    interviewerId?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
    score?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobInterviewSumOrderByAggregateInput = {
    duration?: SortOrder
    score?: SortOrder
  }

  export type EnumInterviewRoundTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewRoundType | EnumInterviewRoundTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InterviewRoundType[] | ListEnumInterviewRoundTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterviewRoundType[] | ListEnumInterviewRoundTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInterviewRoundTypeWithAggregatesFilter<$PrismaModel> | $Enums.InterviewRoundType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterviewRoundTypeFilter<$PrismaModel>
    _max?: NestedEnumInterviewRoundTypeFilter<$PrismaModel>
  }

  export type EnumInterviewResultNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewResult | EnumInterviewResultFieldRefInput<$PrismaModel> | null
    in?: $Enums.InterviewResult[] | ListEnumInterviewResultFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InterviewResult[] | ListEnumInterviewResultFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInterviewResultNullableWithAggregatesFilter<$PrismaModel> | $Enums.InterviewResult | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumInterviewResultNullableFilter<$PrismaModel>
    _max?: NestedEnumInterviewResultNullableFilter<$PrismaModel>
  }

  export type EnumEmailStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailStatus | EnumEmailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailStatusFilter<$PrismaModel> | $Enums.EmailStatus
  }

  export type JobApplicationNullableScalarRelationFilter = {
    is?: JobApplicationWhereInput | null
    isNot?: JobApplicationWhereInput | null
  }

  export type EmailLogCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    applicationId?: SortOrder
    recipientEmail?: SortOrder
    recipientName?: SortOrder
    templateName?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    error?: SortOrder
    triggeredBy?: SortOrder
  }

  export type EmailLogMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    applicationId?: SortOrder
    recipientEmail?: SortOrder
    recipientName?: SortOrder
    templateName?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    error?: SortOrder
    triggeredBy?: SortOrder
  }

  export type EmailLogMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    applicationId?: SortOrder
    recipientEmail?: SortOrder
    recipientName?: SortOrder
    templateName?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    error?: SortOrder
    triggeredBy?: SortOrder
  }

  export type EnumEmailStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailStatus | EnumEmailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmailStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailStatusFilter<$PrismaModel>
    _max?: NestedEnumEmailStatusFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    method?: SortOrder
    path?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    applicationId?: SortOrder
    performedBy?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    method?: SortOrder
    path?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    applicationId?: SortOrder
    performedBy?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    method?: SortOrder
    path?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    applicationId?: SortOrder
    performedBy?: SortOrder
    timestamp?: SortOrder
  }

  export type SavedFilterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    page?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SavedFilterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    page?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SavedFilterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    page?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnrollmentCreateNestedManyWithoutUserInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type InterviewCreateNestedManyWithoutUserInput = {
    create?: XOR<InterviewCreateWithoutUserInput, InterviewUncheckedCreateWithoutUserInput> | InterviewCreateWithoutUserInput[] | InterviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterviewCreateOrConnectWithoutUserInput | InterviewCreateOrConnectWithoutUserInput[]
    createMany?: InterviewCreateManyUserInputEnvelope
    connect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
  }

  export type LessonProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<LessonProgressCreateWithoutUserInput, LessonProgressUncheckedCreateWithoutUserInput> | LessonProgressCreateWithoutUserInput[] | LessonProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutUserInput | LessonProgressCreateOrConnectWithoutUserInput[]
    createMany?: LessonProgressCreateManyUserInputEnvelope
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
  }

  export type ForumPostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ForumPostCreateWithoutAuthorInput, ForumPostUncheckedCreateWithoutAuthorInput> | ForumPostCreateWithoutAuthorInput[] | ForumPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutAuthorInput | ForumPostCreateOrConnectWithoutAuthorInput[]
    createMany?: ForumPostCreateManyAuthorInputEnvelope
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
  }

  export type ForumCommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ForumCommentCreateWithoutAuthorInput, ForumCommentUncheckedCreateWithoutAuthorInput> | ForumCommentCreateWithoutAuthorInput[] | ForumCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutAuthorInput | ForumCommentCreateOrConnectWithoutAuthorInput[]
    createMany?: ForumCommentCreateManyAuthorInputEnvelope
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutParticipantsInput = {
    create?: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput> | ConversationCreateWithoutParticipantsInput[] | ConversationUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantsInput | ConversationCreateOrConnectWithoutParticipantsInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutUserInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput> | TicketCreateWithoutUserInput[] | TicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUserInput | TicketCreateOrConnectWithoutUserInput[]
    createMany?: TicketCreateManyUserInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketMessageCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketMessageCreateWithoutUserInput, TicketMessageUncheckedCreateWithoutUserInput> | TicketMessageCreateWithoutUserInput[] | TicketMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutUserInput | TicketMessageCreateOrConnectWithoutUserInput[]
    createMany?: TicketMessageCreateManyUserInputEnvelope
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
  }

  export type EmployerProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployerProfileCreateWithoutUserInput, EmployerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployerProfileCreateOrConnectWithoutUserInput
    connect?: EmployerProfileWhereUniqueInput
  }

  export type JobCreateNestedManyWithoutEmployerInput = {
    create?: XOR<JobCreateWithoutEmployerInput, JobUncheckedCreateWithoutEmployerInput> | JobCreateWithoutEmployerInput[] | JobUncheckedCreateWithoutEmployerInput[]
    connectOrCreate?: JobCreateOrConnectWithoutEmployerInput | JobCreateOrConnectWithoutEmployerInput[]
    createMany?: JobCreateManyEmployerInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type JobApplicationCreateNestedManyWithoutApplicantInput = {
    create?: XOR<JobApplicationCreateWithoutApplicantInput, JobApplicationUncheckedCreateWithoutApplicantInput> | JobApplicationCreateWithoutApplicantInput[] | JobApplicationUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutApplicantInput | JobApplicationCreateOrConnectWithoutApplicantInput[]
    createMany?: JobApplicationCreateManyApplicantInputEnvelope
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput> | TaskCreateWithoutCreatorInput[] | TaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatorInput | TaskCreateOrConnectWithoutCreatorInput[]
    createMany?: TaskCreateManyCreatorInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type BlogPostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type TaskCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskCommentCreateWithoutUserInput, TaskCommentUncheckedCreateWithoutUserInput> | TaskCommentCreateWithoutUserInput[] | TaskCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutUserInput | TaskCommentCreateOrConnectWithoutUserInput[]
    createMany?: TaskCommentCreateManyUserInputEnvelope
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
  }

  export type AssignmentSubmissionCreateNestedManyWithoutUserInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutUserInput, AssignmentSubmissionUncheckedCreateWithoutUserInput> | AssignmentSubmissionCreateWithoutUserInput[] | AssignmentSubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutUserInput | AssignmentSubmissionCreateOrConnectWithoutUserInput[]
    createMany?: AssignmentSubmissionCreateManyUserInputEnvelope
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
  }

  export type LessonCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<LessonCommentCreateWithoutUserInput, LessonCommentUncheckedCreateWithoutUserInput> | LessonCommentCreateWithoutUserInput[] | LessonCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutUserInput | LessonCommentCreateOrConnectWithoutUserInput[]
    createMany?: LessonCommentCreateManyUserInputEnvelope
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
  }

  export type BatchCreateNestedManyWithoutInstructorInput = {
    create?: XOR<BatchCreateWithoutInstructorInput, BatchUncheckedCreateWithoutInstructorInput> | BatchCreateWithoutInstructorInput[] | BatchUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutInstructorInput | BatchCreateOrConnectWithoutInstructorInput[]
    createMany?: BatchCreateManyInstructorInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type AnnouncementCreateNestedManyWithoutInstructorInput = {
    create?: XOR<AnnouncementCreateWithoutInstructorInput, AnnouncementUncheckedCreateWithoutInstructorInput> | AnnouncementCreateWithoutInstructorInput[] | AnnouncementUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutInstructorInput | AnnouncementCreateOrConnectWithoutInstructorInput[]
    createMany?: AnnouncementCreateManyInstructorInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type JobInterviewCreateNestedManyWithoutInterviewerInput = {
    create?: XOR<JobInterviewCreateWithoutInterviewerInput, JobInterviewUncheckedCreateWithoutInterviewerInput> | JobInterviewCreateWithoutInterviewerInput[] | JobInterviewUncheckedCreateWithoutInterviewerInput[]
    connectOrCreate?: JobInterviewCreateOrConnectWithoutInterviewerInput | JobInterviewCreateOrConnectWithoutInterviewerInput[]
    createMany?: JobInterviewCreateManyInterviewerInputEnvelope
    connect?: JobInterviewWhereUniqueInput | JobInterviewWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type InterviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InterviewCreateWithoutUserInput, InterviewUncheckedCreateWithoutUserInput> | InterviewCreateWithoutUserInput[] | InterviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterviewCreateOrConnectWithoutUserInput | InterviewCreateOrConnectWithoutUserInput[]
    createMany?: InterviewCreateManyUserInputEnvelope
    connect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
  }

  export type LessonProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LessonProgressCreateWithoutUserInput, LessonProgressUncheckedCreateWithoutUserInput> | LessonProgressCreateWithoutUserInput[] | LessonProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutUserInput | LessonProgressCreateOrConnectWithoutUserInput[]
    createMany?: LessonProgressCreateManyUserInputEnvelope
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
  }

  export type ForumPostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ForumPostCreateWithoutAuthorInput, ForumPostUncheckedCreateWithoutAuthorInput> | ForumPostCreateWithoutAuthorInput[] | ForumPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutAuthorInput | ForumPostCreateOrConnectWithoutAuthorInput[]
    createMany?: ForumPostCreateManyAuthorInputEnvelope
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
  }

  export type ForumCommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ForumCommentCreateWithoutAuthorInput, ForumCommentUncheckedCreateWithoutAuthorInput> | ForumCommentCreateWithoutAuthorInput[] | ForumCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutAuthorInput | ForumCommentCreateOrConnectWithoutAuthorInput[]
    createMany?: ForumCommentCreateManyAuthorInputEnvelope
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutParticipantsInput = {
    create?: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput> | ConversationCreateWithoutParticipantsInput[] | ConversationUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantsInput | ConversationCreateOrConnectWithoutParticipantsInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput> | TicketCreateWithoutUserInput[] | TicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUserInput | TicketCreateOrConnectWithoutUserInput[]
    createMany?: TicketCreateManyUserInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketMessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketMessageCreateWithoutUserInput, TicketMessageUncheckedCreateWithoutUserInput> | TicketMessageCreateWithoutUserInput[] | TicketMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutUserInput | TicketMessageCreateOrConnectWithoutUserInput[]
    createMany?: TicketMessageCreateManyUserInputEnvelope
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
  }

  export type EmployerProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployerProfileCreateWithoutUserInput, EmployerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployerProfileCreateOrConnectWithoutUserInput
    connect?: EmployerProfileWhereUniqueInput
  }

  export type JobUncheckedCreateNestedManyWithoutEmployerInput = {
    create?: XOR<JobCreateWithoutEmployerInput, JobUncheckedCreateWithoutEmployerInput> | JobCreateWithoutEmployerInput[] | JobUncheckedCreateWithoutEmployerInput[]
    connectOrCreate?: JobCreateOrConnectWithoutEmployerInput | JobCreateOrConnectWithoutEmployerInput[]
    createMany?: JobCreateManyEmployerInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type JobApplicationUncheckedCreateNestedManyWithoutApplicantInput = {
    create?: XOR<JobApplicationCreateWithoutApplicantInput, JobApplicationUncheckedCreateWithoutApplicantInput> | JobApplicationCreateWithoutApplicantInput[] | JobApplicationUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutApplicantInput | JobApplicationCreateOrConnectWithoutApplicantInput[]
    createMany?: JobApplicationCreateManyApplicantInputEnvelope
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput> | TaskCreateWithoutCreatorInput[] | TaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatorInput | TaskCreateOrConnectWithoutCreatorInput[]
    createMany?: TaskCreateManyCreatorInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type BlogPostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type TaskCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskCommentCreateWithoutUserInput, TaskCommentUncheckedCreateWithoutUserInput> | TaskCommentCreateWithoutUserInput[] | TaskCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutUserInput | TaskCommentCreateOrConnectWithoutUserInput[]
    createMany?: TaskCommentCreateManyUserInputEnvelope
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
  }

  export type AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutUserInput, AssignmentSubmissionUncheckedCreateWithoutUserInput> | AssignmentSubmissionCreateWithoutUserInput[] | AssignmentSubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutUserInput | AssignmentSubmissionCreateOrConnectWithoutUserInput[]
    createMany?: AssignmentSubmissionCreateManyUserInputEnvelope
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
  }

  export type LessonCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LessonCommentCreateWithoutUserInput, LessonCommentUncheckedCreateWithoutUserInput> | LessonCommentCreateWithoutUserInput[] | LessonCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutUserInput | LessonCommentCreateOrConnectWithoutUserInput[]
    createMany?: LessonCommentCreateManyUserInputEnvelope
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutInstructorInput = {
    create?: XOR<BatchCreateWithoutInstructorInput, BatchUncheckedCreateWithoutInstructorInput> | BatchCreateWithoutInstructorInput[] | BatchUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutInstructorInput | BatchCreateOrConnectWithoutInstructorInput[]
    createMany?: BatchCreateManyInstructorInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type AnnouncementUncheckedCreateNestedManyWithoutInstructorInput = {
    create?: XOR<AnnouncementCreateWithoutInstructorInput, AnnouncementUncheckedCreateWithoutInstructorInput> | AnnouncementCreateWithoutInstructorInput[] | AnnouncementUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutInstructorInput | AnnouncementCreateOrConnectWithoutInstructorInput[]
    createMany?: AnnouncementCreateManyInstructorInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput = {
    create?: XOR<JobInterviewCreateWithoutInterviewerInput, JobInterviewUncheckedCreateWithoutInterviewerInput> | JobInterviewCreateWithoutInterviewerInput[] | JobInterviewUncheckedCreateWithoutInterviewerInput[]
    connectOrCreate?: JobInterviewCreateOrConnectWithoutInterviewerInput | JobInterviewCreateOrConnectWithoutInterviewerInput[]
    createMany?: JobInterviewCreateManyInterviewerInputEnvelope
    connect?: JobInterviewWhereUniqueInput | JobInterviewWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnrollmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutUserInput | EnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutUserInput | EnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutUserInput | EnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type InterviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<InterviewCreateWithoutUserInput, InterviewUncheckedCreateWithoutUserInput> | InterviewCreateWithoutUserInput[] | InterviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterviewCreateOrConnectWithoutUserInput | InterviewCreateOrConnectWithoutUserInput[]
    upsert?: InterviewUpsertWithWhereUniqueWithoutUserInput | InterviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InterviewCreateManyUserInputEnvelope
    set?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    disconnect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    delete?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    connect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    update?: InterviewUpdateWithWhereUniqueWithoutUserInput | InterviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InterviewUpdateManyWithWhereWithoutUserInput | InterviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InterviewScalarWhereInput | InterviewScalarWhereInput[]
  }

  export type LessonProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<LessonProgressCreateWithoutUserInput, LessonProgressUncheckedCreateWithoutUserInput> | LessonProgressCreateWithoutUserInput[] | LessonProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutUserInput | LessonProgressCreateOrConnectWithoutUserInput[]
    upsert?: LessonProgressUpsertWithWhereUniqueWithoutUserInput | LessonProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LessonProgressCreateManyUserInputEnvelope
    set?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    disconnect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    delete?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    update?: LessonProgressUpdateWithWhereUniqueWithoutUserInput | LessonProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LessonProgressUpdateManyWithWhereWithoutUserInput | LessonProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
  }

  export type ForumPostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ForumPostCreateWithoutAuthorInput, ForumPostUncheckedCreateWithoutAuthorInput> | ForumPostCreateWithoutAuthorInput[] | ForumPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutAuthorInput | ForumPostCreateOrConnectWithoutAuthorInput[]
    upsert?: ForumPostUpsertWithWhereUniqueWithoutAuthorInput | ForumPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ForumPostCreateManyAuthorInputEnvelope
    set?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    disconnect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    delete?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    update?: ForumPostUpdateWithWhereUniqueWithoutAuthorInput | ForumPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ForumPostUpdateManyWithWhereWithoutAuthorInput | ForumPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
  }

  export type ForumCommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ForumCommentCreateWithoutAuthorInput, ForumCommentUncheckedCreateWithoutAuthorInput> | ForumCommentCreateWithoutAuthorInput[] | ForumCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutAuthorInput | ForumCommentCreateOrConnectWithoutAuthorInput[]
    upsert?: ForumCommentUpsertWithWhereUniqueWithoutAuthorInput | ForumCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ForumCommentCreateManyAuthorInputEnvelope
    set?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    disconnect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    delete?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    update?: ForumCommentUpdateWithWhereUniqueWithoutAuthorInput | ForumCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ForumCommentUpdateManyWithWhereWithoutAuthorInput | ForumCommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ForumCommentScalarWhereInput | ForumCommentScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutParticipantsNestedInput = {
    create?: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput> | ConversationCreateWithoutParticipantsInput[] | ConversationUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantsInput | ConversationCreateOrConnectWithoutParticipantsInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutParticipantsInput | ConversationUpsertWithWhereUniqueWithoutParticipantsInput[]
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutParticipantsInput | ConversationUpdateWithWhereUniqueWithoutParticipantsInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutParticipantsInput | ConversationUpdateManyWithWhereWithoutParticipantsInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutUserNestedInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutUserInput | CertificateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutUserInput | CertificateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutUserInput | CertificateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput> | TicketCreateWithoutUserInput[] | TicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUserInput | TicketCreateOrConnectWithoutUserInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutUserInput | TicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketCreateManyUserInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutUserInput | TicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutUserInput | TicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketMessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketMessageCreateWithoutUserInput, TicketMessageUncheckedCreateWithoutUserInput> | TicketMessageCreateWithoutUserInput[] | TicketMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutUserInput | TicketMessageCreateOrConnectWithoutUserInput[]
    upsert?: TicketMessageUpsertWithWhereUniqueWithoutUserInput | TicketMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketMessageCreateManyUserInputEnvelope
    set?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    disconnect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    delete?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    update?: TicketMessageUpdateWithWhereUniqueWithoutUserInput | TicketMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketMessageUpdateManyWithWhereWithoutUserInput | TicketMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketMessageScalarWhereInput | TicketMessageScalarWhereInput[]
  }

  export type EmployerProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployerProfileCreateWithoutUserInput, EmployerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployerProfileCreateOrConnectWithoutUserInput
    upsert?: EmployerProfileUpsertWithoutUserInput
    disconnect?: EmployerProfileWhereInput | boolean
    delete?: EmployerProfileWhereInput | boolean
    connect?: EmployerProfileWhereUniqueInput
    update?: XOR<XOR<EmployerProfileUpdateToOneWithWhereWithoutUserInput, EmployerProfileUpdateWithoutUserInput>, EmployerProfileUncheckedUpdateWithoutUserInput>
  }

  export type JobUpdateManyWithoutEmployerNestedInput = {
    create?: XOR<JobCreateWithoutEmployerInput, JobUncheckedCreateWithoutEmployerInput> | JobCreateWithoutEmployerInput[] | JobUncheckedCreateWithoutEmployerInput[]
    connectOrCreate?: JobCreateOrConnectWithoutEmployerInput | JobCreateOrConnectWithoutEmployerInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutEmployerInput | JobUpsertWithWhereUniqueWithoutEmployerInput[]
    createMany?: JobCreateManyEmployerInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutEmployerInput | JobUpdateWithWhereUniqueWithoutEmployerInput[]
    updateMany?: JobUpdateManyWithWhereWithoutEmployerInput | JobUpdateManyWithWhereWithoutEmployerInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type JobApplicationUpdateManyWithoutApplicantNestedInput = {
    create?: XOR<JobApplicationCreateWithoutApplicantInput, JobApplicationUncheckedCreateWithoutApplicantInput> | JobApplicationCreateWithoutApplicantInput[] | JobApplicationUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutApplicantInput | JobApplicationCreateOrConnectWithoutApplicantInput[]
    upsert?: JobApplicationUpsertWithWhereUniqueWithoutApplicantInput | JobApplicationUpsertWithWhereUniqueWithoutApplicantInput[]
    createMany?: JobApplicationCreateManyApplicantInputEnvelope
    set?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    disconnect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    delete?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    update?: JobApplicationUpdateWithWhereUniqueWithoutApplicantInput | JobApplicationUpdateWithWhereUniqueWithoutApplicantInput[]
    updateMany?: JobApplicationUpdateManyWithWhereWithoutApplicantInput | JobApplicationUpdateManyWithWhereWithoutApplicantInput[]
    deleteMany?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssigneeInput | TaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssigneeInput | TaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssigneeInput | TaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput> | TaskCreateWithoutCreatorInput[] | TaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatorInput | TaskCreateOrConnectWithoutCreatorInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCreatorInput | TaskUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TaskCreateManyCreatorInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCreatorInput | TaskUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCreatorInput | TaskUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type BlogPostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutAuthorInput | BlogPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutAuthorInput | BlogPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutAuthorInput | BlogPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type TaskCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskCommentCreateWithoutUserInput, TaskCommentUncheckedCreateWithoutUserInput> | TaskCommentCreateWithoutUserInput[] | TaskCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutUserInput | TaskCommentCreateOrConnectWithoutUserInput[]
    upsert?: TaskCommentUpsertWithWhereUniqueWithoutUserInput | TaskCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskCommentCreateManyUserInputEnvelope
    set?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    disconnect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    delete?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    update?: TaskCommentUpdateWithWhereUniqueWithoutUserInput | TaskCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskCommentUpdateManyWithWhereWithoutUserInput | TaskCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskCommentScalarWhereInput | TaskCommentScalarWhereInput[]
  }

  export type AssignmentSubmissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutUserInput, AssignmentSubmissionUncheckedCreateWithoutUserInput> | AssignmentSubmissionCreateWithoutUserInput[] | AssignmentSubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutUserInput | AssignmentSubmissionCreateOrConnectWithoutUserInput[]
    upsert?: AssignmentSubmissionUpsertWithWhereUniqueWithoutUserInput | AssignmentSubmissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AssignmentSubmissionCreateManyUserInputEnvelope
    set?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    disconnect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    delete?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    update?: AssignmentSubmissionUpdateWithWhereUniqueWithoutUserInput | AssignmentSubmissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AssignmentSubmissionUpdateManyWithWhereWithoutUserInput | AssignmentSubmissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
  }

  export type LessonCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<LessonCommentCreateWithoutUserInput, LessonCommentUncheckedCreateWithoutUserInput> | LessonCommentCreateWithoutUserInput[] | LessonCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutUserInput | LessonCommentCreateOrConnectWithoutUserInput[]
    upsert?: LessonCommentUpsertWithWhereUniqueWithoutUserInput | LessonCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LessonCommentCreateManyUserInputEnvelope
    set?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    disconnect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    delete?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    update?: LessonCommentUpdateWithWhereUniqueWithoutUserInput | LessonCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LessonCommentUpdateManyWithWhereWithoutUserInput | LessonCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LessonCommentScalarWhereInput | LessonCommentScalarWhereInput[]
  }

  export type BatchUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<BatchCreateWithoutInstructorInput, BatchUncheckedCreateWithoutInstructorInput> | BatchCreateWithoutInstructorInput[] | BatchUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutInstructorInput | BatchCreateOrConnectWithoutInstructorInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutInstructorInput | BatchUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: BatchCreateManyInstructorInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutInstructorInput | BatchUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutInstructorInput | BatchUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type AnnouncementUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<AnnouncementCreateWithoutInstructorInput, AnnouncementUncheckedCreateWithoutInstructorInput> | AnnouncementCreateWithoutInstructorInput[] | AnnouncementUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutInstructorInput | AnnouncementCreateOrConnectWithoutInstructorInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutInstructorInput | AnnouncementUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: AnnouncementCreateManyInstructorInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutInstructorInput | AnnouncementUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutInstructorInput | AnnouncementUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type JobInterviewUpdateManyWithoutInterviewerNestedInput = {
    create?: XOR<JobInterviewCreateWithoutInterviewerInput, JobInterviewUncheckedCreateWithoutInterviewerInput> | JobInterviewCreateWithoutInterviewerInput[] | JobInterviewUncheckedCreateWithoutInterviewerInput[]
    connectOrCreate?: JobInterviewCreateOrConnectWithoutInterviewerInput | JobInterviewCreateOrConnectWithoutInterviewerInput[]
    upsert?: JobInterviewUpsertWithWhereUniqueWithoutInterviewerInput | JobInterviewUpsertWithWhereUniqueWithoutInterviewerInput[]
    createMany?: JobInterviewCreateManyInterviewerInputEnvelope
    set?: JobInterviewWhereUniqueInput | JobInterviewWhereUniqueInput[]
    disconnect?: JobInterviewWhereUniqueInput | JobInterviewWhereUniqueInput[]
    delete?: JobInterviewWhereUniqueInput | JobInterviewWhereUniqueInput[]
    connect?: JobInterviewWhereUniqueInput | JobInterviewWhereUniqueInput[]
    update?: JobInterviewUpdateWithWhereUniqueWithoutInterviewerInput | JobInterviewUpdateWithWhereUniqueWithoutInterviewerInput[]
    updateMany?: JobInterviewUpdateManyWithWhereWithoutInterviewerInput | JobInterviewUpdateManyWithWhereWithoutInterviewerInput[]
    deleteMany?: JobInterviewScalarWhereInput | JobInterviewScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutUserInput | EnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutUserInput | EnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutUserInput | EnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type InterviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InterviewCreateWithoutUserInput, InterviewUncheckedCreateWithoutUserInput> | InterviewCreateWithoutUserInput[] | InterviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterviewCreateOrConnectWithoutUserInput | InterviewCreateOrConnectWithoutUserInput[]
    upsert?: InterviewUpsertWithWhereUniqueWithoutUserInput | InterviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InterviewCreateManyUserInputEnvelope
    set?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    disconnect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    delete?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    connect?: InterviewWhereUniqueInput | InterviewWhereUniqueInput[]
    update?: InterviewUpdateWithWhereUniqueWithoutUserInput | InterviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InterviewUpdateManyWithWhereWithoutUserInput | InterviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InterviewScalarWhereInput | InterviewScalarWhereInput[]
  }

  export type LessonProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LessonProgressCreateWithoutUserInput, LessonProgressUncheckedCreateWithoutUserInput> | LessonProgressCreateWithoutUserInput[] | LessonProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutUserInput | LessonProgressCreateOrConnectWithoutUserInput[]
    upsert?: LessonProgressUpsertWithWhereUniqueWithoutUserInput | LessonProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LessonProgressCreateManyUserInputEnvelope
    set?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    disconnect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    delete?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    update?: LessonProgressUpdateWithWhereUniqueWithoutUserInput | LessonProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LessonProgressUpdateManyWithWhereWithoutUserInput | LessonProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
  }

  export type ForumPostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ForumPostCreateWithoutAuthorInput, ForumPostUncheckedCreateWithoutAuthorInput> | ForumPostCreateWithoutAuthorInput[] | ForumPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutAuthorInput | ForumPostCreateOrConnectWithoutAuthorInput[]
    upsert?: ForumPostUpsertWithWhereUniqueWithoutAuthorInput | ForumPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ForumPostCreateManyAuthorInputEnvelope
    set?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    disconnect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    delete?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    update?: ForumPostUpdateWithWhereUniqueWithoutAuthorInput | ForumPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ForumPostUpdateManyWithWhereWithoutAuthorInput | ForumPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
  }

  export type ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ForumCommentCreateWithoutAuthorInput, ForumCommentUncheckedCreateWithoutAuthorInput> | ForumCommentCreateWithoutAuthorInput[] | ForumCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutAuthorInput | ForumCommentCreateOrConnectWithoutAuthorInput[]
    upsert?: ForumCommentUpsertWithWhereUniqueWithoutAuthorInput | ForumCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ForumCommentCreateManyAuthorInputEnvelope
    set?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    disconnect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    delete?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    update?: ForumCommentUpdateWithWhereUniqueWithoutAuthorInput | ForumCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ForumCommentUpdateManyWithWhereWithoutAuthorInput | ForumCommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ForumCommentScalarWhereInput | ForumCommentScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutParticipantsNestedInput = {
    create?: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput> | ConversationCreateWithoutParticipantsInput[] | ConversationUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantsInput | ConversationCreateOrConnectWithoutParticipantsInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutParticipantsInput | ConversationUpsertWithWhereUniqueWithoutParticipantsInput[]
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutParticipantsInput | ConversationUpdateWithWhereUniqueWithoutParticipantsInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutParticipantsInput | ConversationUpdateManyWithWhereWithoutParticipantsInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutUserInput | CertificateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutUserInput | CertificateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutUserInput | CertificateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput> | TicketCreateWithoutUserInput[] | TicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutUserInput | TicketCreateOrConnectWithoutUserInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutUserInput | TicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketCreateManyUserInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutUserInput | TicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutUserInput | TicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketMessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketMessageCreateWithoutUserInput, TicketMessageUncheckedCreateWithoutUserInput> | TicketMessageCreateWithoutUserInput[] | TicketMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutUserInput | TicketMessageCreateOrConnectWithoutUserInput[]
    upsert?: TicketMessageUpsertWithWhereUniqueWithoutUserInput | TicketMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketMessageCreateManyUserInputEnvelope
    set?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    disconnect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    delete?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    update?: TicketMessageUpdateWithWhereUniqueWithoutUserInput | TicketMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketMessageUpdateManyWithWhereWithoutUserInput | TicketMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketMessageScalarWhereInput | TicketMessageScalarWhereInput[]
  }

  export type EmployerProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployerProfileCreateWithoutUserInput, EmployerProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployerProfileCreateOrConnectWithoutUserInput
    upsert?: EmployerProfileUpsertWithoutUserInput
    disconnect?: EmployerProfileWhereInput | boolean
    delete?: EmployerProfileWhereInput | boolean
    connect?: EmployerProfileWhereUniqueInput
    update?: XOR<XOR<EmployerProfileUpdateToOneWithWhereWithoutUserInput, EmployerProfileUpdateWithoutUserInput>, EmployerProfileUncheckedUpdateWithoutUserInput>
  }

  export type JobUncheckedUpdateManyWithoutEmployerNestedInput = {
    create?: XOR<JobCreateWithoutEmployerInput, JobUncheckedCreateWithoutEmployerInput> | JobCreateWithoutEmployerInput[] | JobUncheckedCreateWithoutEmployerInput[]
    connectOrCreate?: JobCreateOrConnectWithoutEmployerInput | JobCreateOrConnectWithoutEmployerInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutEmployerInput | JobUpsertWithWhereUniqueWithoutEmployerInput[]
    createMany?: JobCreateManyEmployerInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutEmployerInput | JobUpdateWithWhereUniqueWithoutEmployerInput[]
    updateMany?: JobUpdateManyWithWhereWithoutEmployerInput | JobUpdateManyWithWhereWithoutEmployerInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput = {
    create?: XOR<JobApplicationCreateWithoutApplicantInput, JobApplicationUncheckedCreateWithoutApplicantInput> | JobApplicationCreateWithoutApplicantInput[] | JobApplicationUncheckedCreateWithoutApplicantInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutApplicantInput | JobApplicationCreateOrConnectWithoutApplicantInput[]
    upsert?: JobApplicationUpsertWithWhereUniqueWithoutApplicantInput | JobApplicationUpsertWithWhereUniqueWithoutApplicantInput[]
    createMany?: JobApplicationCreateManyApplicantInputEnvelope
    set?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    disconnect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    delete?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    update?: JobApplicationUpdateWithWhereUniqueWithoutApplicantInput | JobApplicationUpdateWithWhereUniqueWithoutApplicantInput[]
    updateMany?: JobApplicationUpdateManyWithWhereWithoutApplicantInput | JobApplicationUpdateManyWithWhereWithoutApplicantInput[]
    deleteMany?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssigneeInput | TaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssigneeInput | TaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssigneeInput | TaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput> | TaskCreateWithoutCreatorInput[] | TaskUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreatorInput | TaskCreateOrConnectWithoutCreatorInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCreatorInput | TaskUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TaskCreateManyCreatorInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCreatorInput | TaskUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCreatorInput | TaskUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type BlogPostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput> | BlogPostCreateWithoutAuthorInput[] | BlogPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutAuthorInput | BlogPostCreateOrConnectWithoutAuthorInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutAuthorInput | BlogPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: BlogPostCreateManyAuthorInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutAuthorInput | BlogPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutAuthorInput | BlogPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type TaskCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskCommentCreateWithoutUserInput, TaskCommentUncheckedCreateWithoutUserInput> | TaskCommentCreateWithoutUserInput[] | TaskCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutUserInput | TaskCommentCreateOrConnectWithoutUserInput[]
    upsert?: TaskCommentUpsertWithWhereUniqueWithoutUserInput | TaskCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskCommentCreateManyUserInputEnvelope
    set?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    disconnect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    delete?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    update?: TaskCommentUpdateWithWhereUniqueWithoutUserInput | TaskCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskCommentUpdateManyWithWhereWithoutUserInput | TaskCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskCommentScalarWhereInput | TaskCommentScalarWhereInput[]
  }

  export type AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutUserInput, AssignmentSubmissionUncheckedCreateWithoutUserInput> | AssignmentSubmissionCreateWithoutUserInput[] | AssignmentSubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutUserInput | AssignmentSubmissionCreateOrConnectWithoutUserInput[]
    upsert?: AssignmentSubmissionUpsertWithWhereUniqueWithoutUserInput | AssignmentSubmissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AssignmentSubmissionCreateManyUserInputEnvelope
    set?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    disconnect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    delete?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    update?: AssignmentSubmissionUpdateWithWhereUniqueWithoutUserInput | AssignmentSubmissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AssignmentSubmissionUpdateManyWithWhereWithoutUserInput | AssignmentSubmissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
  }

  export type LessonCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LessonCommentCreateWithoutUserInput, LessonCommentUncheckedCreateWithoutUserInput> | LessonCommentCreateWithoutUserInput[] | LessonCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutUserInput | LessonCommentCreateOrConnectWithoutUserInput[]
    upsert?: LessonCommentUpsertWithWhereUniqueWithoutUserInput | LessonCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LessonCommentCreateManyUserInputEnvelope
    set?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    disconnect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    delete?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    update?: LessonCommentUpdateWithWhereUniqueWithoutUserInput | LessonCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LessonCommentUpdateManyWithWhereWithoutUserInput | LessonCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LessonCommentScalarWhereInput | LessonCommentScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<BatchCreateWithoutInstructorInput, BatchUncheckedCreateWithoutInstructorInput> | BatchCreateWithoutInstructorInput[] | BatchUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutInstructorInput | BatchCreateOrConnectWithoutInstructorInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutInstructorInput | BatchUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: BatchCreateManyInstructorInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutInstructorInput | BatchUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutInstructorInput | BatchUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<AnnouncementCreateWithoutInstructorInput, AnnouncementUncheckedCreateWithoutInstructorInput> | AnnouncementCreateWithoutInstructorInput[] | AnnouncementUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutInstructorInput | AnnouncementCreateOrConnectWithoutInstructorInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutInstructorInput | AnnouncementUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: AnnouncementCreateManyInstructorInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutInstructorInput | AnnouncementUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutInstructorInput | AnnouncementUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput = {
    create?: XOR<JobInterviewCreateWithoutInterviewerInput, JobInterviewUncheckedCreateWithoutInterviewerInput> | JobInterviewCreateWithoutInterviewerInput[] | JobInterviewUncheckedCreateWithoutInterviewerInput[]
    connectOrCreate?: JobInterviewCreateOrConnectWithoutInterviewerInput | JobInterviewCreateOrConnectWithoutInterviewerInput[]
    upsert?: JobInterviewUpsertWithWhereUniqueWithoutInterviewerInput | JobInterviewUpsertWithWhereUniqueWithoutInterviewerInput[]
    createMany?: JobInterviewCreateManyInterviewerInputEnvelope
    set?: JobInterviewWhereUniqueInput | JobInterviewWhereUniqueInput[]
    disconnect?: JobInterviewWhereUniqueInput | JobInterviewWhereUniqueInput[]
    delete?: JobInterviewWhereUniqueInput | JobInterviewWhereUniqueInput[]
    connect?: JobInterviewWhereUniqueInput | JobInterviewWhereUniqueInput[]
    update?: JobInterviewUpdateWithWhereUniqueWithoutInterviewerInput | JobInterviewUpdateWithWhereUniqueWithoutInterviewerInput[]
    updateMany?: JobInterviewUpdateManyWithWhereWithoutInterviewerInput | JobInterviewUpdateManyWithWhereWithoutInterviewerInput[]
    deleteMany?: JobInterviewScalarWhereInput | JobInterviewScalarWhereInput[]
  }

  export type ModuleCreateNestedManyWithoutCourseInput = {
    create?: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput> | ModuleCreateWithoutCourseInput[] | ModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseInput | ModuleCreateOrConnectWithoutCourseInput[]
    createMany?: ModuleCreateManyCourseInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutCourseInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutCourseInput = {
    create?: XOR<PaymentCreateWithoutCourseInput, PaymentUncheckedCreateWithoutCourseInput> | PaymentCreateWithoutCourseInput[] | PaymentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCourseInput | PaymentCreateOrConnectWithoutCourseInput[]
    createMany?: PaymentCreateManyCourseInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutCourseInput = {
    create?: XOR<ReviewCreateWithoutCourseInput, ReviewUncheckedCreateWithoutCourseInput> | ReviewCreateWithoutCourseInput[] | ReviewUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCourseInput | ReviewCreateOrConnectWithoutCourseInput[]
    createMany?: ReviewCreateManyCourseInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type LiveClassCreateNestedManyWithoutCourseInput = {
    create?: XOR<LiveClassCreateWithoutCourseInput, LiveClassUncheckedCreateWithoutCourseInput> | LiveClassCreateWithoutCourseInput[] | LiveClassUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LiveClassCreateOrConnectWithoutCourseInput | LiveClassCreateOrConnectWithoutCourseInput[]
    createMany?: LiveClassCreateManyCourseInputEnvelope
    connect?: LiveClassWhereUniqueInput | LiveClassWhereUniqueInput[]
  }

  export type BatchCreateNestedManyWithoutCourseInput = {
    create?: XOR<BatchCreateWithoutCourseInput, BatchUncheckedCreateWithoutCourseInput> | BatchCreateWithoutCourseInput[] | BatchUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutCourseInput | BatchCreateOrConnectWithoutCourseInput[]
    createMany?: BatchCreateManyCourseInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type AnnouncementCreateNestedManyWithoutCourseInput = {
    create?: XOR<AnnouncementCreateWithoutCourseInput, AnnouncementUncheckedCreateWithoutCourseInput> | AnnouncementCreateWithoutCourseInput[] | AnnouncementUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutCourseInput | AnnouncementCreateOrConnectWithoutCourseInput[]
    createMany?: AnnouncementCreateManyCourseInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type ModuleUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput> | ModuleCreateWithoutCourseInput[] | ModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseInput | ModuleCreateOrConnectWithoutCourseInput[]
    createMany?: ModuleCreateManyCourseInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<PaymentCreateWithoutCourseInput, PaymentUncheckedCreateWithoutCourseInput> | PaymentCreateWithoutCourseInput[] | PaymentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCourseInput | PaymentCreateOrConnectWithoutCourseInput[]
    createMany?: PaymentCreateManyCourseInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<ReviewCreateWithoutCourseInput, ReviewUncheckedCreateWithoutCourseInput> | ReviewCreateWithoutCourseInput[] | ReviewUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCourseInput | ReviewCreateOrConnectWithoutCourseInput[]
    createMany?: ReviewCreateManyCourseInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type LiveClassUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<LiveClassCreateWithoutCourseInput, LiveClassUncheckedCreateWithoutCourseInput> | LiveClassCreateWithoutCourseInput[] | LiveClassUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LiveClassCreateOrConnectWithoutCourseInput | LiveClassCreateOrConnectWithoutCourseInput[]
    createMany?: LiveClassCreateManyCourseInputEnvelope
    connect?: LiveClassWhereUniqueInput | LiveClassWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<BatchCreateWithoutCourseInput, BatchUncheckedCreateWithoutCourseInput> | BatchCreateWithoutCourseInput[] | BatchUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutCourseInput | BatchCreateOrConnectWithoutCourseInput[]
    createMany?: BatchCreateManyCourseInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type AnnouncementUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<AnnouncementCreateWithoutCourseInput, AnnouncementUncheckedCreateWithoutCourseInput> | AnnouncementCreateWithoutCourseInput[] | AnnouncementUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutCourseInput | AnnouncementCreateOrConnectWithoutCourseInput[]
    createMany?: AnnouncementCreateManyCourseInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type EnumDifficultyFieldUpdateOperationsInput = {
    set?: $Enums.Difficulty
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumCourseTypeFieldUpdateOperationsInput = {
    set?: $Enums.CourseType
  }

  export type EnumPublishStatusFieldUpdateOperationsInput = {
    set?: $Enums.PublishStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ModuleUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput> | ModuleCreateWithoutCourseInput[] | ModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseInput | ModuleCreateOrConnectWithoutCourseInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutCourseInput | ModuleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ModuleCreateManyCourseInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutCourseInput | ModuleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutCourseInput | ModuleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutCourseNestedInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutCourseInput | EnrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutCourseInput | EnrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutCourseInput | EnrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutCourseNestedInput = {
    create?: XOR<PaymentCreateWithoutCourseInput, PaymentUncheckedCreateWithoutCourseInput> | PaymentCreateWithoutCourseInput[] | PaymentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCourseInput | PaymentCreateOrConnectWithoutCourseInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCourseInput | PaymentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: PaymentCreateManyCourseInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCourseInput | PaymentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCourseInput | PaymentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ReviewCreateWithoutCourseInput, ReviewUncheckedCreateWithoutCourseInput> | ReviewCreateWithoutCourseInput[] | ReviewUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCourseInput | ReviewCreateOrConnectWithoutCourseInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutCourseInput | ReviewUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ReviewCreateManyCourseInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutCourseInput | ReviewUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutCourseInput | ReviewUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type LiveClassUpdateManyWithoutCourseNestedInput = {
    create?: XOR<LiveClassCreateWithoutCourseInput, LiveClassUncheckedCreateWithoutCourseInput> | LiveClassCreateWithoutCourseInput[] | LiveClassUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LiveClassCreateOrConnectWithoutCourseInput | LiveClassCreateOrConnectWithoutCourseInput[]
    upsert?: LiveClassUpsertWithWhereUniqueWithoutCourseInput | LiveClassUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: LiveClassCreateManyCourseInputEnvelope
    set?: LiveClassWhereUniqueInput | LiveClassWhereUniqueInput[]
    disconnect?: LiveClassWhereUniqueInput | LiveClassWhereUniqueInput[]
    delete?: LiveClassWhereUniqueInput | LiveClassWhereUniqueInput[]
    connect?: LiveClassWhereUniqueInput | LiveClassWhereUniqueInput[]
    update?: LiveClassUpdateWithWhereUniqueWithoutCourseInput | LiveClassUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: LiveClassUpdateManyWithWhereWithoutCourseInput | LiveClassUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: LiveClassScalarWhereInput | LiveClassScalarWhereInput[]
  }

  export type BatchUpdateManyWithoutCourseNestedInput = {
    create?: XOR<BatchCreateWithoutCourseInput, BatchUncheckedCreateWithoutCourseInput> | BatchCreateWithoutCourseInput[] | BatchUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutCourseInput | BatchCreateOrConnectWithoutCourseInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutCourseInput | BatchUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: BatchCreateManyCourseInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutCourseInput | BatchUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutCourseInput | BatchUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type AnnouncementUpdateManyWithoutCourseNestedInput = {
    create?: XOR<AnnouncementCreateWithoutCourseInput, AnnouncementUncheckedCreateWithoutCourseInput> | AnnouncementCreateWithoutCourseInput[] | AnnouncementUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutCourseInput | AnnouncementCreateOrConnectWithoutCourseInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutCourseInput | AnnouncementUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: AnnouncementCreateManyCourseInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutCourseInput | AnnouncementUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutCourseInput | AnnouncementUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type ModuleUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput> | ModuleCreateWithoutCourseInput[] | ModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseInput | ModuleCreateOrConnectWithoutCourseInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutCourseInput | ModuleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ModuleCreateManyCourseInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutCourseInput | ModuleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutCourseInput | ModuleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutCourseInput | EnrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutCourseInput | EnrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutCourseInput | EnrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<PaymentCreateWithoutCourseInput, PaymentUncheckedCreateWithoutCourseInput> | PaymentCreateWithoutCourseInput[] | PaymentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCourseInput | PaymentCreateOrConnectWithoutCourseInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCourseInput | PaymentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: PaymentCreateManyCourseInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCourseInput | PaymentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCourseInput | PaymentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ReviewCreateWithoutCourseInput, ReviewUncheckedCreateWithoutCourseInput> | ReviewCreateWithoutCourseInput[] | ReviewUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCourseInput | ReviewCreateOrConnectWithoutCourseInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutCourseInput | ReviewUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ReviewCreateManyCourseInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutCourseInput | ReviewUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutCourseInput | ReviewUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type LiveClassUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<LiveClassCreateWithoutCourseInput, LiveClassUncheckedCreateWithoutCourseInput> | LiveClassCreateWithoutCourseInput[] | LiveClassUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LiveClassCreateOrConnectWithoutCourseInput | LiveClassCreateOrConnectWithoutCourseInput[]
    upsert?: LiveClassUpsertWithWhereUniqueWithoutCourseInput | LiveClassUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: LiveClassCreateManyCourseInputEnvelope
    set?: LiveClassWhereUniqueInput | LiveClassWhereUniqueInput[]
    disconnect?: LiveClassWhereUniqueInput | LiveClassWhereUniqueInput[]
    delete?: LiveClassWhereUniqueInput | LiveClassWhereUniqueInput[]
    connect?: LiveClassWhereUniqueInput | LiveClassWhereUniqueInput[]
    update?: LiveClassUpdateWithWhereUniqueWithoutCourseInput | LiveClassUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: LiveClassUpdateManyWithWhereWithoutCourseInput | LiveClassUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: LiveClassScalarWhereInput | LiveClassScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<BatchCreateWithoutCourseInput, BatchUncheckedCreateWithoutCourseInput> | BatchCreateWithoutCourseInput[] | BatchUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutCourseInput | BatchCreateOrConnectWithoutCourseInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutCourseInput | BatchUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: BatchCreateManyCourseInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutCourseInput | BatchUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutCourseInput | BatchUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type AnnouncementUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<AnnouncementCreateWithoutCourseInput, AnnouncementUncheckedCreateWithoutCourseInput> | AnnouncementCreateWithoutCourseInput[] | AnnouncementUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutCourseInput | AnnouncementCreateOrConnectWithoutCourseInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutCourseInput | AnnouncementUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: AnnouncementCreateManyCourseInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutCourseInput | AnnouncementUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutCourseInput | AnnouncementUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutBatchesInput = {
    create?: XOR<CourseCreateWithoutBatchesInput, CourseUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutBatchesInput
    connect?: CourseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInstructedBatchesInput = {
    create?: XOR<UserCreateWithoutInstructedBatchesInput, UserUncheckedCreateWithoutInstructedBatchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstructedBatchesInput
    connect?: UserWhereUniqueInput
  }

  export type AnnouncementCreateNestedManyWithoutBatchInput = {
    create?: XOR<AnnouncementCreateWithoutBatchInput, AnnouncementUncheckedCreateWithoutBatchInput> | AnnouncementCreateWithoutBatchInput[] | AnnouncementUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutBatchInput | AnnouncementCreateOrConnectWithoutBatchInput[]
    createMany?: AnnouncementCreateManyBatchInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutBatchInput = {
    create?: XOR<EnrollmentCreateWithoutBatchInput, EnrollmentUncheckedCreateWithoutBatchInput> | EnrollmentCreateWithoutBatchInput[] | EnrollmentUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutBatchInput | EnrollmentCreateOrConnectWithoutBatchInput[]
    createMany?: EnrollmentCreateManyBatchInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type AnnouncementUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<AnnouncementCreateWithoutBatchInput, AnnouncementUncheckedCreateWithoutBatchInput> | AnnouncementCreateWithoutBatchInput[] | AnnouncementUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutBatchInput | AnnouncementCreateOrConnectWithoutBatchInput[]
    createMany?: AnnouncementCreateManyBatchInputEnvelope
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<EnrollmentCreateWithoutBatchInput, EnrollmentUncheckedCreateWithoutBatchInput> | EnrollmentCreateWithoutBatchInput[] | EnrollmentUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutBatchInput | EnrollmentCreateOrConnectWithoutBatchInput[]
    createMany?: EnrollmentCreateManyBatchInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CourseUpdateOneRequiredWithoutBatchesNestedInput = {
    create?: XOR<CourseCreateWithoutBatchesInput, CourseUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutBatchesInput
    upsert?: CourseUpsertWithoutBatchesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutBatchesInput, CourseUpdateWithoutBatchesInput>, CourseUncheckedUpdateWithoutBatchesInput>
  }

  export type UserUpdateOneRequiredWithoutInstructedBatchesNestedInput = {
    create?: XOR<UserCreateWithoutInstructedBatchesInput, UserUncheckedCreateWithoutInstructedBatchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstructedBatchesInput
    upsert?: UserUpsertWithoutInstructedBatchesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInstructedBatchesInput, UserUpdateWithoutInstructedBatchesInput>, UserUncheckedUpdateWithoutInstructedBatchesInput>
  }

  export type AnnouncementUpdateManyWithoutBatchNestedInput = {
    create?: XOR<AnnouncementCreateWithoutBatchInput, AnnouncementUncheckedCreateWithoutBatchInput> | AnnouncementCreateWithoutBatchInput[] | AnnouncementUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutBatchInput | AnnouncementCreateOrConnectWithoutBatchInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutBatchInput | AnnouncementUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: AnnouncementCreateManyBatchInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutBatchInput | AnnouncementUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutBatchInput | AnnouncementUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutBatchNestedInput = {
    create?: XOR<EnrollmentCreateWithoutBatchInput, EnrollmentUncheckedCreateWithoutBatchInput> | EnrollmentCreateWithoutBatchInput[] | EnrollmentUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutBatchInput | EnrollmentCreateOrConnectWithoutBatchInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutBatchInput | EnrollmentUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: EnrollmentCreateManyBatchInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutBatchInput | EnrollmentUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutBatchInput | EnrollmentUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type AnnouncementUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<AnnouncementCreateWithoutBatchInput, AnnouncementUncheckedCreateWithoutBatchInput> | AnnouncementCreateWithoutBatchInput[] | AnnouncementUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: AnnouncementCreateOrConnectWithoutBatchInput | AnnouncementCreateOrConnectWithoutBatchInput[]
    upsert?: AnnouncementUpsertWithWhereUniqueWithoutBatchInput | AnnouncementUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: AnnouncementCreateManyBatchInputEnvelope
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[]
    update?: AnnouncementUpdateWithWhereUniqueWithoutBatchInput | AnnouncementUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: AnnouncementUpdateManyWithWhereWithoutBatchInput | AnnouncementUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<EnrollmentCreateWithoutBatchInput, EnrollmentUncheckedCreateWithoutBatchInput> | EnrollmentCreateWithoutBatchInput[] | EnrollmentUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutBatchInput | EnrollmentCreateOrConnectWithoutBatchInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutBatchInput | EnrollmentUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: EnrollmentCreateManyBatchInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutBatchInput | EnrollmentUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutBatchInput | EnrollmentUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutAnnouncementsInput = {
    create?: XOR<CourseCreateWithoutAnnouncementsInput, CourseUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutAnnouncementsInput
    connect?: CourseWhereUniqueInput
  }

  export type BatchCreateNestedOneWithoutAnnouncementsInput = {
    create?: XOR<BatchCreateWithoutAnnouncementsInput, BatchUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: BatchCreateOrConnectWithoutAnnouncementsInput
    connect?: BatchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAnnouncementsInput = {
    create?: XOR<UserCreateWithoutAnnouncementsInput, UserUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementsInput
    connect?: UserWhereUniqueInput
  }

  export type CourseUpdateOneWithoutAnnouncementsNestedInput = {
    create?: XOR<CourseCreateWithoutAnnouncementsInput, CourseUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutAnnouncementsInput
    upsert?: CourseUpsertWithoutAnnouncementsInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutAnnouncementsInput, CourseUpdateWithoutAnnouncementsInput>, CourseUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type BatchUpdateOneWithoutAnnouncementsNestedInput = {
    create?: XOR<BatchCreateWithoutAnnouncementsInput, BatchUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: BatchCreateOrConnectWithoutAnnouncementsInput
    upsert?: BatchUpsertWithoutAnnouncementsInput
    disconnect?: BatchWhereInput | boolean
    delete?: BatchWhereInput | boolean
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutAnnouncementsInput, BatchUpdateWithoutAnnouncementsInput>, BatchUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type UserUpdateOneRequiredWithoutAnnouncementsNestedInput = {
    create?: XOR<UserCreateWithoutAnnouncementsInput, UserUncheckedCreateWithoutAnnouncementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementsInput
    upsert?: UserUpsertWithoutAnnouncementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnnouncementsInput, UserUpdateWithoutAnnouncementsInput>, UserUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type LessonCreateNestedOneWithoutCommentsInput = {
    create?: XOR<LessonCreateWithoutCommentsInput, LessonUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutCommentsInput
    connect?: LessonWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLessonCommentsInput = {
    create?: XOR<UserCreateWithoutLessonCommentsInput, UserUncheckedCreateWithoutLessonCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type LessonCommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<LessonCommentCreateWithoutRepliesInput, LessonCommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: LessonCommentCreateOrConnectWithoutRepliesInput
    connect?: LessonCommentWhereUniqueInput
  }

  export type LessonCommentCreateNestedManyWithoutParentInput = {
    create?: XOR<LessonCommentCreateWithoutParentInput, LessonCommentUncheckedCreateWithoutParentInput> | LessonCommentCreateWithoutParentInput[] | LessonCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutParentInput | LessonCommentCreateOrConnectWithoutParentInput[]
    createMany?: LessonCommentCreateManyParentInputEnvelope
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
  }

  export type LessonCommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<LessonCommentCreateWithoutParentInput, LessonCommentUncheckedCreateWithoutParentInput> | LessonCommentCreateWithoutParentInput[] | LessonCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutParentInput | LessonCommentCreateOrConnectWithoutParentInput[]
    createMany?: LessonCommentCreateManyParentInputEnvelope
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
  }

  export type LessonUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<LessonCreateWithoutCommentsInput, LessonUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutCommentsInput
    upsert?: LessonUpsertWithoutCommentsInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutCommentsInput, LessonUpdateWithoutCommentsInput>, LessonUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutLessonCommentsNestedInput = {
    create?: XOR<UserCreateWithoutLessonCommentsInput, UserUncheckedCreateWithoutLessonCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonCommentsInput
    upsert?: UserUpsertWithoutLessonCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLessonCommentsInput, UserUpdateWithoutLessonCommentsInput>, UserUncheckedUpdateWithoutLessonCommentsInput>
  }

  export type LessonCommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<LessonCommentCreateWithoutRepliesInput, LessonCommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: LessonCommentCreateOrConnectWithoutRepliesInput
    upsert?: LessonCommentUpsertWithoutRepliesInput
    disconnect?: LessonCommentWhereInput | boolean
    delete?: LessonCommentWhereInput | boolean
    connect?: LessonCommentWhereUniqueInput
    update?: XOR<XOR<LessonCommentUpdateToOneWithWhereWithoutRepliesInput, LessonCommentUpdateWithoutRepliesInput>, LessonCommentUncheckedUpdateWithoutRepliesInput>
  }

  export type LessonCommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<LessonCommentCreateWithoutParentInput, LessonCommentUncheckedCreateWithoutParentInput> | LessonCommentCreateWithoutParentInput[] | LessonCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutParentInput | LessonCommentCreateOrConnectWithoutParentInput[]
    upsert?: LessonCommentUpsertWithWhereUniqueWithoutParentInput | LessonCommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: LessonCommentCreateManyParentInputEnvelope
    set?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    disconnect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    delete?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    update?: LessonCommentUpdateWithWhereUniqueWithoutParentInput | LessonCommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: LessonCommentUpdateManyWithWhereWithoutParentInput | LessonCommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: LessonCommentScalarWhereInput | LessonCommentScalarWhereInput[]
  }

  export type LessonCommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<LessonCommentCreateWithoutParentInput, LessonCommentUncheckedCreateWithoutParentInput> | LessonCommentCreateWithoutParentInput[] | LessonCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutParentInput | LessonCommentCreateOrConnectWithoutParentInput[]
    upsert?: LessonCommentUpsertWithWhereUniqueWithoutParentInput | LessonCommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: LessonCommentCreateManyParentInputEnvelope
    set?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    disconnect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    delete?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    update?: LessonCommentUpdateWithWhereUniqueWithoutParentInput | LessonCommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: LessonCommentUpdateManyWithWhereWithoutParentInput | LessonCommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: LessonCommentScalarWhereInput | LessonCommentScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutModulesInput = {
    create?: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutModulesInput
    connect?: CourseWhereUniqueInput
  }

  export type LessonCreateNestedManyWithoutModuleInput = {
    create?: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput> | LessonCreateWithoutModuleInput[] | LessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutModuleInput | LessonCreateOrConnectWithoutModuleInput[]
    createMany?: LessonCreateManyModuleInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput> | LessonCreateWithoutModuleInput[] | LessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutModuleInput | LessonCreateOrConnectWithoutModuleInput[]
    createMany?: LessonCreateManyModuleInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type CourseUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutModulesInput
    upsert?: CourseUpsertWithoutModulesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutModulesInput, CourseUpdateWithoutModulesInput>, CourseUncheckedUpdateWithoutModulesInput>
  }

  export type LessonUpdateManyWithoutModuleNestedInput = {
    create?: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput> | LessonCreateWithoutModuleInput[] | LessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutModuleInput | LessonCreateOrConnectWithoutModuleInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutModuleInput | LessonUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: LessonCreateManyModuleInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutModuleInput | LessonUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutModuleInput | LessonUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput> | LessonCreateWithoutModuleInput[] | LessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutModuleInput | LessonCreateOrConnectWithoutModuleInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutModuleInput | LessonUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: LessonCreateManyModuleInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutModuleInput | LessonUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutModuleInput | LessonUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type ModuleCreateNestedOneWithoutLessonsInput = {
    create?: XOR<ModuleCreateWithoutLessonsInput, ModuleUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutLessonsInput
    connect?: ModuleWhereUniqueInput
  }

  export type QuizCreateNestedManyWithoutLessonInput = {
    create?: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput> | QuizCreateWithoutLessonInput[] | QuizUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutLessonInput | QuizCreateOrConnectWithoutLessonInput[]
    createMany?: QuizCreateManyLessonInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type LessonProgressCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonProgressCreateWithoutLessonInput, LessonProgressUncheckedCreateWithoutLessonInput> | LessonProgressCreateWithoutLessonInput[] | LessonProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutLessonInput | LessonProgressCreateOrConnectWithoutLessonInput[]
    createMany?: LessonProgressCreateManyLessonInputEnvelope
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
  }

  export type LessonCommentCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonCommentCreateWithoutLessonInput, LessonCommentUncheckedCreateWithoutLessonInput> | LessonCommentCreateWithoutLessonInput[] | LessonCommentUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutLessonInput | LessonCommentCreateOrConnectWithoutLessonInput[]
    createMany?: LessonCommentCreateManyLessonInputEnvelope
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
  }

  export type AssignmentSubmissionCreateNestedManyWithoutLessonInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutLessonInput, AssignmentSubmissionUncheckedCreateWithoutLessonInput> | AssignmentSubmissionCreateWithoutLessonInput[] | AssignmentSubmissionUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutLessonInput | AssignmentSubmissionCreateOrConnectWithoutLessonInput[]
    createMany?: AssignmentSubmissionCreateManyLessonInputEnvelope
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
  }

  export type QuizUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput> | QuizCreateWithoutLessonInput[] | QuizUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutLessonInput | QuizCreateOrConnectWithoutLessonInput[]
    createMany?: QuizCreateManyLessonInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type LessonProgressUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonProgressCreateWithoutLessonInput, LessonProgressUncheckedCreateWithoutLessonInput> | LessonProgressCreateWithoutLessonInput[] | LessonProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutLessonInput | LessonProgressCreateOrConnectWithoutLessonInput[]
    createMany?: LessonProgressCreateManyLessonInputEnvelope
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
  }

  export type LessonCommentUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonCommentCreateWithoutLessonInput, LessonCommentUncheckedCreateWithoutLessonInput> | LessonCommentCreateWithoutLessonInput[] | LessonCommentUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutLessonInput | LessonCommentCreateOrConnectWithoutLessonInput[]
    createMany?: LessonCommentCreateManyLessonInputEnvelope
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
  }

  export type AssignmentSubmissionUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutLessonInput, AssignmentSubmissionUncheckedCreateWithoutLessonInput> | AssignmentSubmissionCreateWithoutLessonInput[] | AssignmentSubmissionUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutLessonInput | AssignmentSubmissionCreateOrConnectWithoutLessonInput[]
    createMany?: AssignmentSubmissionCreateManyLessonInputEnvelope
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
  }

  export type EnumLessonTypeFieldUpdateOperationsInput = {
    set?: $Enums.LessonType
  }

  export type ModuleUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<ModuleCreateWithoutLessonsInput, ModuleUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutLessonsInput
    upsert?: ModuleUpsertWithoutLessonsInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutLessonsInput, ModuleUpdateWithoutLessonsInput>, ModuleUncheckedUpdateWithoutLessonsInput>
  }

  export type QuizUpdateManyWithoutLessonNestedInput = {
    create?: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput> | QuizCreateWithoutLessonInput[] | QuizUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutLessonInput | QuizCreateOrConnectWithoutLessonInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutLessonInput | QuizUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: QuizCreateManyLessonInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutLessonInput | QuizUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutLessonInput | QuizUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type LessonProgressUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonProgressCreateWithoutLessonInput, LessonProgressUncheckedCreateWithoutLessonInput> | LessonProgressCreateWithoutLessonInput[] | LessonProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutLessonInput | LessonProgressCreateOrConnectWithoutLessonInput[]
    upsert?: LessonProgressUpsertWithWhereUniqueWithoutLessonInput | LessonProgressUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonProgressCreateManyLessonInputEnvelope
    set?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    disconnect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    delete?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    update?: LessonProgressUpdateWithWhereUniqueWithoutLessonInput | LessonProgressUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonProgressUpdateManyWithWhereWithoutLessonInput | LessonProgressUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
  }

  export type LessonCommentUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonCommentCreateWithoutLessonInput, LessonCommentUncheckedCreateWithoutLessonInput> | LessonCommentCreateWithoutLessonInput[] | LessonCommentUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutLessonInput | LessonCommentCreateOrConnectWithoutLessonInput[]
    upsert?: LessonCommentUpsertWithWhereUniqueWithoutLessonInput | LessonCommentUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonCommentCreateManyLessonInputEnvelope
    set?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    disconnect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    delete?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    update?: LessonCommentUpdateWithWhereUniqueWithoutLessonInput | LessonCommentUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonCommentUpdateManyWithWhereWithoutLessonInput | LessonCommentUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonCommentScalarWhereInput | LessonCommentScalarWhereInput[]
  }

  export type AssignmentSubmissionUpdateManyWithoutLessonNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutLessonInput, AssignmentSubmissionUncheckedCreateWithoutLessonInput> | AssignmentSubmissionCreateWithoutLessonInput[] | AssignmentSubmissionUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutLessonInput | AssignmentSubmissionCreateOrConnectWithoutLessonInput[]
    upsert?: AssignmentSubmissionUpsertWithWhereUniqueWithoutLessonInput | AssignmentSubmissionUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: AssignmentSubmissionCreateManyLessonInputEnvelope
    set?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    disconnect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    delete?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    update?: AssignmentSubmissionUpdateWithWhereUniqueWithoutLessonInput | AssignmentSubmissionUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: AssignmentSubmissionUpdateManyWithWhereWithoutLessonInput | AssignmentSubmissionUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
  }

  export type QuizUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput> | QuizCreateWithoutLessonInput[] | QuizUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutLessonInput | QuizCreateOrConnectWithoutLessonInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutLessonInput | QuizUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: QuizCreateManyLessonInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutLessonInput | QuizUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutLessonInput | QuizUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type LessonProgressUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonProgressCreateWithoutLessonInput, LessonProgressUncheckedCreateWithoutLessonInput> | LessonProgressCreateWithoutLessonInput[] | LessonProgressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonProgressCreateOrConnectWithoutLessonInput | LessonProgressCreateOrConnectWithoutLessonInput[]
    upsert?: LessonProgressUpsertWithWhereUniqueWithoutLessonInput | LessonProgressUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonProgressCreateManyLessonInputEnvelope
    set?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    disconnect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    delete?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    connect?: LessonProgressWhereUniqueInput | LessonProgressWhereUniqueInput[]
    update?: LessonProgressUpdateWithWhereUniqueWithoutLessonInput | LessonProgressUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonProgressUpdateManyWithWhereWithoutLessonInput | LessonProgressUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
  }

  export type LessonCommentUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonCommentCreateWithoutLessonInput, LessonCommentUncheckedCreateWithoutLessonInput> | LessonCommentCreateWithoutLessonInput[] | LessonCommentUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonCommentCreateOrConnectWithoutLessonInput | LessonCommentCreateOrConnectWithoutLessonInput[]
    upsert?: LessonCommentUpsertWithWhereUniqueWithoutLessonInput | LessonCommentUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonCommentCreateManyLessonInputEnvelope
    set?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    disconnect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    delete?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    connect?: LessonCommentWhereUniqueInput | LessonCommentWhereUniqueInput[]
    update?: LessonCommentUpdateWithWhereUniqueWithoutLessonInput | LessonCommentUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonCommentUpdateManyWithWhereWithoutLessonInput | LessonCommentUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonCommentScalarWhereInput | LessonCommentScalarWhereInput[]
  }

  export type AssignmentSubmissionUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutLessonInput, AssignmentSubmissionUncheckedCreateWithoutLessonInput> | AssignmentSubmissionCreateWithoutLessonInput[] | AssignmentSubmissionUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutLessonInput | AssignmentSubmissionCreateOrConnectWithoutLessonInput[]
    upsert?: AssignmentSubmissionUpsertWithWhereUniqueWithoutLessonInput | AssignmentSubmissionUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: AssignmentSubmissionCreateManyLessonInputEnvelope
    set?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    disconnect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    delete?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    update?: AssignmentSubmissionUpdateWithWhereUniqueWithoutLessonInput | AssignmentSubmissionUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: AssignmentSubmissionUpdateManyWithWhereWithoutLessonInput | AssignmentSubmissionUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
  }

  export type LessonCreateNestedOneWithoutQuizzesInput = {
    create?: XOR<LessonCreateWithoutQuizzesInput, LessonUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: LessonCreateOrConnectWithoutQuizzesInput
    connect?: LessonWhereUniqueInput
  }

  export type LessonUpdateOneRequiredWithoutQuizzesNestedInput = {
    create?: XOR<LessonCreateWithoutQuizzesInput, LessonUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: LessonCreateOrConnectWithoutQuizzesInput
    upsert?: LessonUpsertWithoutQuizzesInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutQuizzesInput, LessonUpdateWithoutQuizzesInput>, LessonUncheckedUpdateWithoutQuizzesInput>
  }

  export type LessonCreateNestedOneWithoutAssignmentSubmissionsInput = {
    create?: XOR<LessonCreateWithoutAssignmentSubmissionsInput, LessonUncheckedCreateWithoutAssignmentSubmissionsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutAssignmentSubmissionsInput
    connect?: LessonWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignmentSubmissionsInput = {
    create?: XOR<UserCreateWithoutAssignmentSubmissionsInput, UserUncheckedCreateWithoutAssignmentSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignmentSubmissionsInput
    connect?: UserWhereUniqueInput
  }

  export type LessonUpdateOneRequiredWithoutAssignmentSubmissionsNestedInput = {
    create?: XOR<LessonCreateWithoutAssignmentSubmissionsInput, LessonUncheckedCreateWithoutAssignmentSubmissionsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutAssignmentSubmissionsInput
    upsert?: LessonUpsertWithoutAssignmentSubmissionsInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutAssignmentSubmissionsInput, LessonUpdateWithoutAssignmentSubmissionsInput>, LessonUncheckedUpdateWithoutAssignmentSubmissionsInput>
  }

  export type UserUpdateOneRequiredWithoutAssignmentSubmissionsNestedInput = {
    create?: XOR<UserCreateWithoutAssignmentSubmissionsInput, UserUncheckedCreateWithoutAssignmentSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignmentSubmissionsInput
    upsert?: UserUpsertWithoutAssignmentSubmissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignmentSubmissionsInput, UserUpdateWithoutAssignmentSubmissionsInput>, UserUncheckedUpdateWithoutAssignmentSubmissionsInput>
  }

  export type UserCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnrollmentsInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentsInput
    connect?: CourseWhereUniqueInput
  }

  export type BatchCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<BatchCreateWithoutEnrollmentsInput, BatchUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: BatchCreateOrConnectWithoutEnrollmentsInput
    connect?: BatchWhereUniqueInput
  }

  export type EnumEnrollmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.EnrollmentStatus
  }

  export type UserUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnrollmentsInput
    upsert?: UserUpsertWithoutEnrollmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEnrollmentsInput, UserUpdateWithoutEnrollmentsInput>, UserUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentsInput
    upsert?: CourseUpsertWithoutEnrollmentsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutEnrollmentsInput, CourseUpdateWithoutEnrollmentsInput>, CourseUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type BatchUpdateOneWithoutEnrollmentsNestedInput = {
    create?: XOR<BatchCreateWithoutEnrollmentsInput, BatchUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: BatchCreateOrConnectWithoutEnrollmentsInput
    upsert?: BatchUpsertWithoutEnrollmentsInput
    disconnect?: BatchWhereInput | boolean
    delete?: BatchWhereInput | boolean
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutEnrollmentsInput, BatchUpdateWithoutEnrollmentsInput>, BatchUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type UserCreateNestedOneWithoutLessonProgressInput = {
    create?: XOR<UserCreateWithoutLessonProgressInput, UserUncheckedCreateWithoutLessonProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonProgressInput
    connect?: UserWhereUniqueInput
  }

  export type LessonCreateNestedOneWithoutProgressInput = {
    create?: XOR<LessonCreateWithoutProgressInput, LessonUncheckedCreateWithoutProgressInput>
    connectOrCreate?: LessonCreateOrConnectWithoutProgressInput
    connect?: LessonWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLessonProgressNestedInput = {
    create?: XOR<UserCreateWithoutLessonProgressInput, UserUncheckedCreateWithoutLessonProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonProgressInput
    upsert?: UserUpsertWithoutLessonProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLessonProgressInput, UserUpdateWithoutLessonProgressInput>, UserUncheckedUpdateWithoutLessonProgressInput>
  }

  export type LessonUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<LessonCreateWithoutProgressInput, LessonUncheckedCreateWithoutProgressInput>
    connectOrCreate?: LessonCreateOrConnectWithoutProgressInput
    upsert?: LessonUpsertWithoutProgressInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutProgressInput, LessonUpdateWithoutProgressInput>, LessonUncheckedUpdateWithoutProgressInput>
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutReviewsInput = {
    create?: XOR<CourseCreateWithoutReviewsInput, CourseUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutReviewsInput
    connect?: CourseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type CourseUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<CourseCreateWithoutReviewsInput, CourseUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutReviewsInput
    upsert?: CourseUpsertWithoutReviewsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutReviewsInput, CourseUpdateWithoutReviewsInput>, CourseUncheckedUpdateWithoutReviewsInput>
  }

  export type InterviewCreateselectedAvatarsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutInterviewsInput = {
    create?: XOR<UserCreateWithoutInterviewsInput, UserUncheckedCreateWithoutInterviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterviewsInput
    connect?: UserWhereUniqueInput
  }

  export type InterviewQuestionCreateNestedManyWithoutInterviewInput = {
    create?: XOR<InterviewQuestionCreateWithoutInterviewInput, InterviewQuestionUncheckedCreateWithoutInterviewInput> | InterviewQuestionCreateWithoutInterviewInput[] | InterviewQuestionUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: InterviewQuestionCreateOrConnectWithoutInterviewInput | InterviewQuestionCreateOrConnectWithoutInterviewInput[]
    createMany?: InterviewQuestionCreateManyInterviewInputEnvelope
    connect?: InterviewQuestionWhereUniqueInput | InterviewQuestionWhereUniqueInput[]
  }

  export type InterviewResponseCreateNestedManyWithoutInterviewInput = {
    create?: XOR<InterviewResponseCreateWithoutInterviewInput, InterviewResponseUncheckedCreateWithoutInterviewInput> | InterviewResponseCreateWithoutInterviewInput[] | InterviewResponseUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: InterviewResponseCreateOrConnectWithoutInterviewInput | InterviewResponseCreateOrConnectWithoutInterviewInput[]
    createMany?: InterviewResponseCreateManyInterviewInputEnvelope
    connect?: InterviewResponseWhereUniqueInput | InterviewResponseWhereUniqueInput[]
  }

  export type InterviewEvaluationCreateNestedOneWithoutInterviewInput = {
    create?: XOR<InterviewEvaluationCreateWithoutInterviewInput, InterviewEvaluationUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: InterviewEvaluationCreateOrConnectWithoutInterviewInput
    connect?: InterviewEvaluationWhereUniqueInput
  }

  export type InterviewQuestionUncheckedCreateNestedManyWithoutInterviewInput = {
    create?: XOR<InterviewQuestionCreateWithoutInterviewInput, InterviewQuestionUncheckedCreateWithoutInterviewInput> | InterviewQuestionCreateWithoutInterviewInput[] | InterviewQuestionUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: InterviewQuestionCreateOrConnectWithoutInterviewInput | InterviewQuestionCreateOrConnectWithoutInterviewInput[]
    createMany?: InterviewQuestionCreateManyInterviewInputEnvelope
    connect?: InterviewQuestionWhereUniqueInput | InterviewQuestionWhereUniqueInput[]
  }

  export type InterviewResponseUncheckedCreateNestedManyWithoutInterviewInput = {
    create?: XOR<InterviewResponseCreateWithoutInterviewInput, InterviewResponseUncheckedCreateWithoutInterviewInput> | InterviewResponseCreateWithoutInterviewInput[] | InterviewResponseUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: InterviewResponseCreateOrConnectWithoutInterviewInput | InterviewResponseCreateOrConnectWithoutInterviewInput[]
    createMany?: InterviewResponseCreateManyInterviewInputEnvelope
    connect?: InterviewResponseWhereUniqueInput | InterviewResponseWhereUniqueInput[]
  }

  export type InterviewEvaluationUncheckedCreateNestedOneWithoutInterviewInput = {
    create?: XOR<InterviewEvaluationCreateWithoutInterviewInput, InterviewEvaluationUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: InterviewEvaluationCreateOrConnectWithoutInterviewInput
    connect?: InterviewEvaluationWhereUniqueInput
  }

  export type InterviewUpdateselectedAvatarsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumInterviewStatusFieldUpdateOperationsInput = {
    set?: $Enums.InterviewStatus
  }

  export type UserUpdateOneRequiredWithoutInterviewsNestedInput = {
    create?: XOR<UserCreateWithoutInterviewsInput, UserUncheckedCreateWithoutInterviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterviewsInput
    upsert?: UserUpsertWithoutInterviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInterviewsInput, UserUpdateWithoutInterviewsInput>, UserUncheckedUpdateWithoutInterviewsInput>
  }

  export type InterviewQuestionUpdateManyWithoutInterviewNestedInput = {
    create?: XOR<InterviewQuestionCreateWithoutInterviewInput, InterviewQuestionUncheckedCreateWithoutInterviewInput> | InterviewQuestionCreateWithoutInterviewInput[] | InterviewQuestionUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: InterviewQuestionCreateOrConnectWithoutInterviewInput | InterviewQuestionCreateOrConnectWithoutInterviewInput[]
    upsert?: InterviewQuestionUpsertWithWhereUniqueWithoutInterviewInput | InterviewQuestionUpsertWithWhereUniqueWithoutInterviewInput[]
    createMany?: InterviewQuestionCreateManyInterviewInputEnvelope
    set?: InterviewQuestionWhereUniqueInput | InterviewQuestionWhereUniqueInput[]
    disconnect?: InterviewQuestionWhereUniqueInput | InterviewQuestionWhereUniqueInput[]
    delete?: InterviewQuestionWhereUniqueInput | InterviewQuestionWhereUniqueInput[]
    connect?: InterviewQuestionWhereUniqueInput | InterviewQuestionWhereUniqueInput[]
    update?: InterviewQuestionUpdateWithWhereUniqueWithoutInterviewInput | InterviewQuestionUpdateWithWhereUniqueWithoutInterviewInput[]
    updateMany?: InterviewQuestionUpdateManyWithWhereWithoutInterviewInput | InterviewQuestionUpdateManyWithWhereWithoutInterviewInput[]
    deleteMany?: InterviewQuestionScalarWhereInput | InterviewQuestionScalarWhereInput[]
  }

  export type InterviewResponseUpdateManyWithoutInterviewNestedInput = {
    create?: XOR<InterviewResponseCreateWithoutInterviewInput, InterviewResponseUncheckedCreateWithoutInterviewInput> | InterviewResponseCreateWithoutInterviewInput[] | InterviewResponseUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: InterviewResponseCreateOrConnectWithoutInterviewInput | InterviewResponseCreateOrConnectWithoutInterviewInput[]
    upsert?: InterviewResponseUpsertWithWhereUniqueWithoutInterviewInput | InterviewResponseUpsertWithWhereUniqueWithoutInterviewInput[]
    createMany?: InterviewResponseCreateManyInterviewInputEnvelope
    set?: InterviewResponseWhereUniqueInput | InterviewResponseWhereUniqueInput[]
    disconnect?: InterviewResponseWhereUniqueInput | InterviewResponseWhereUniqueInput[]
    delete?: InterviewResponseWhereUniqueInput | InterviewResponseWhereUniqueInput[]
    connect?: InterviewResponseWhereUniqueInput | InterviewResponseWhereUniqueInput[]
    update?: InterviewResponseUpdateWithWhereUniqueWithoutInterviewInput | InterviewResponseUpdateWithWhereUniqueWithoutInterviewInput[]
    updateMany?: InterviewResponseUpdateManyWithWhereWithoutInterviewInput | InterviewResponseUpdateManyWithWhereWithoutInterviewInput[]
    deleteMany?: InterviewResponseScalarWhereInput | InterviewResponseScalarWhereInput[]
  }

  export type InterviewEvaluationUpdateOneWithoutInterviewNestedInput = {
    create?: XOR<InterviewEvaluationCreateWithoutInterviewInput, InterviewEvaluationUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: InterviewEvaluationCreateOrConnectWithoutInterviewInput
    upsert?: InterviewEvaluationUpsertWithoutInterviewInput
    disconnect?: InterviewEvaluationWhereInput | boolean
    delete?: InterviewEvaluationWhereInput | boolean
    connect?: InterviewEvaluationWhereUniqueInput
    update?: XOR<XOR<InterviewEvaluationUpdateToOneWithWhereWithoutInterviewInput, InterviewEvaluationUpdateWithoutInterviewInput>, InterviewEvaluationUncheckedUpdateWithoutInterviewInput>
  }

  export type InterviewQuestionUncheckedUpdateManyWithoutInterviewNestedInput = {
    create?: XOR<InterviewQuestionCreateWithoutInterviewInput, InterviewQuestionUncheckedCreateWithoutInterviewInput> | InterviewQuestionCreateWithoutInterviewInput[] | InterviewQuestionUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: InterviewQuestionCreateOrConnectWithoutInterviewInput | InterviewQuestionCreateOrConnectWithoutInterviewInput[]
    upsert?: InterviewQuestionUpsertWithWhereUniqueWithoutInterviewInput | InterviewQuestionUpsertWithWhereUniqueWithoutInterviewInput[]
    createMany?: InterviewQuestionCreateManyInterviewInputEnvelope
    set?: InterviewQuestionWhereUniqueInput | InterviewQuestionWhereUniqueInput[]
    disconnect?: InterviewQuestionWhereUniqueInput | InterviewQuestionWhereUniqueInput[]
    delete?: InterviewQuestionWhereUniqueInput | InterviewQuestionWhereUniqueInput[]
    connect?: InterviewQuestionWhereUniqueInput | InterviewQuestionWhereUniqueInput[]
    update?: InterviewQuestionUpdateWithWhereUniqueWithoutInterviewInput | InterviewQuestionUpdateWithWhereUniqueWithoutInterviewInput[]
    updateMany?: InterviewQuestionUpdateManyWithWhereWithoutInterviewInput | InterviewQuestionUpdateManyWithWhereWithoutInterviewInput[]
    deleteMany?: InterviewQuestionScalarWhereInput | InterviewQuestionScalarWhereInput[]
  }

  export type InterviewResponseUncheckedUpdateManyWithoutInterviewNestedInput = {
    create?: XOR<InterviewResponseCreateWithoutInterviewInput, InterviewResponseUncheckedCreateWithoutInterviewInput> | InterviewResponseCreateWithoutInterviewInput[] | InterviewResponseUncheckedCreateWithoutInterviewInput[]
    connectOrCreate?: InterviewResponseCreateOrConnectWithoutInterviewInput | InterviewResponseCreateOrConnectWithoutInterviewInput[]
    upsert?: InterviewResponseUpsertWithWhereUniqueWithoutInterviewInput | InterviewResponseUpsertWithWhereUniqueWithoutInterviewInput[]
    createMany?: InterviewResponseCreateManyInterviewInputEnvelope
    set?: InterviewResponseWhereUniqueInput | InterviewResponseWhereUniqueInput[]
    disconnect?: InterviewResponseWhereUniqueInput | InterviewResponseWhereUniqueInput[]
    delete?: InterviewResponseWhereUniqueInput | InterviewResponseWhereUniqueInput[]
    connect?: InterviewResponseWhereUniqueInput | InterviewResponseWhereUniqueInput[]
    update?: InterviewResponseUpdateWithWhereUniqueWithoutInterviewInput | InterviewResponseUpdateWithWhereUniqueWithoutInterviewInput[]
    updateMany?: InterviewResponseUpdateManyWithWhereWithoutInterviewInput | InterviewResponseUpdateManyWithWhereWithoutInterviewInput[]
    deleteMany?: InterviewResponseScalarWhereInput | InterviewResponseScalarWhereInput[]
  }

  export type InterviewEvaluationUncheckedUpdateOneWithoutInterviewNestedInput = {
    create?: XOR<InterviewEvaluationCreateWithoutInterviewInput, InterviewEvaluationUncheckedCreateWithoutInterviewInput>
    connectOrCreate?: InterviewEvaluationCreateOrConnectWithoutInterviewInput
    upsert?: InterviewEvaluationUpsertWithoutInterviewInput
    disconnect?: InterviewEvaluationWhereInput | boolean
    delete?: InterviewEvaluationWhereInput | boolean
    connect?: InterviewEvaluationWhereUniqueInput
    update?: XOR<XOR<InterviewEvaluationUpdateToOneWithWhereWithoutInterviewInput, InterviewEvaluationUpdateWithoutInterviewInput>, InterviewEvaluationUncheckedUpdateWithoutInterviewInput>
  }

  export type InterviewCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<InterviewCreateWithoutQuestionsInput, InterviewUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: InterviewCreateOrConnectWithoutQuestionsInput
    connect?: InterviewWhereUniqueInput
  }

  export type InterviewResponseCreateNestedOneWithoutQuestionInput = {
    create?: XOR<InterviewResponseCreateWithoutQuestionInput, InterviewResponseUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: InterviewResponseCreateOrConnectWithoutQuestionInput
    connect?: InterviewResponseWhereUniqueInput
  }

  export type InterviewResponseUncheckedCreateNestedOneWithoutQuestionInput = {
    create?: XOR<InterviewResponseCreateWithoutQuestionInput, InterviewResponseUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: InterviewResponseCreateOrConnectWithoutQuestionInput
    connect?: InterviewResponseWhereUniqueInput
  }

  export type EnumQuestionTypeFieldUpdateOperationsInput = {
    set?: $Enums.QuestionType
  }

  export type InterviewUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<InterviewCreateWithoutQuestionsInput, InterviewUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: InterviewCreateOrConnectWithoutQuestionsInput
    upsert?: InterviewUpsertWithoutQuestionsInput
    connect?: InterviewWhereUniqueInput
    update?: XOR<XOR<InterviewUpdateToOneWithWhereWithoutQuestionsInput, InterviewUpdateWithoutQuestionsInput>, InterviewUncheckedUpdateWithoutQuestionsInput>
  }

  export type InterviewResponseUpdateOneWithoutQuestionNestedInput = {
    create?: XOR<InterviewResponseCreateWithoutQuestionInput, InterviewResponseUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: InterviewResponseCreateOrConnectWithoutQuestionInput
    upsert?: InterviewResponseUpsertWithoutQuestionInput
    disconnect?: InterviewResponseWhereInput | boolean
    delete?: InterviewResponseWhereInput | boolean
    connect?: InterviewResponseWhereUniqueInput
    update?: XOR<XOR<InterviewResponseUpdateToOneWithWhereWithoutQuestionInput, InterviewResponseUpdateWithoutQuestionInput>, InterviewResponseUncheckedUpdateWithoutQuestionInput>
  }

  export type InterviewResponseUncheckedUpdateOneWithoutQuestionNestedInput = {
    create?: XOR<InterviewResponseCreateWithoutQuestionInput, InterviewResponseUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: InterviewResponseCreateOrConnectWithoutQuestionInput
    upsert?: InterviewResponseUpsertWithoutQuestionInput
    disconnect?: InterviewResponseWhereInput | boolean
    delete?: InterviewResponseWhereInput | boolean
    connect?: InterviewResponseWhereUniqueInput
    update?: XOR<XOR<InterviewResponseUpdateToOneWithWhereWithoutQuestionInput, InterviewResponseUpdateWithoutQuestionInput>, InterviewResponseUncheckedUpdateWithoutQuestionInput>
  }

  export type InterviewCreateNestedOneWithoutResponsesInput = {
    create?: XOR<InterviewCreateWithoutResponsesInput, InterviewUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: InterviewCreateOrConnectWithoutResponsesInput
    connect?: InterviewWhereUniqueInput
  }

  export type InterviewQuestionCreateNestedOneWithoutResponseInput = {
    create?: XOR<InterviewQuestionCreateWithoutResponseInput, InterviewQuestionUncheckedCreateWithoutResponseInput>
    connectOrCreate?: InterviewQuestionCreateOrConnectWithoutResponseInput
    connect?: InterviewQuestionWhereUniqueInput
  }

  export type InterviewUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<InterviewCreateWithoutResponsesInput, InterviewUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: InterviewCreateOrConnectWithoutResponsesInput
    upsert?: InterviewUpsertWithoutResponsesInput
    connect?: InterviewWhereUniqueInput
    update?: XOR<XOR<InterviewUpdateToOneWithWhereWithoutResponsesInput, InterviewUpdateWithoutResponsesInput>, InterviewUncheckedUpdateWithoutResponsesInput>
  }

  export type InterviewQuestionUpdateOneRequiredWithoutResponseNestedInput = {
    create?: XOR<InterviewQuestionCreateWithoutResponseInput, InterviewQuestionUncheckedCreateWithoutResponseInput>
    connectOrCreate?: InterviewQuestionCreateOrConnectWithoutResponseInput
    upsert?: InterviewQuestionUpsertWithoutResponseInput
    connect?: InterviewQuestionWhereUniqueInput
    update?: XOR<XOR<InterviewQuestionUpdateToOneWithWhereWithoutResponseInput, InterviewQuestionUpdateWithoutResponseInput>, InterviewQuestionUncheckedUpdateWithoutResponseInput>
  }

  export type InterviewCreateNestedOneWithoutEvaluationInput = {
    create?: XOR<InterviewCreateWithoutEvaluationInput, InterviewUncheckedCreateWithoutEvaluationInput>
    connectOrCreate?: InterviewCreateOrConnectWithoutEvaluationInput
    connect?: InterviewWhereUniqueInput
  }

  export type InterviewUpdateOneRequiredWithoutEvaluationNestedInput = {
    create?: XOR<InterviewCreateWithoutEvaluationInput, InterviewUncheckedCreateWithoutEvaluationInput>
    connectOrCreate?: InterviewCreateOrConnectWithoutEvaluationInput
    upsert?: InterviewUpsertWithoutEvaluationInput
    connect?: InterviewWhereUniqueInput
    update?: XOR<XOR<InterviewUpdateToOneWithWhereWithoutEvaluationInput, InterviewUpdateWithoutEvaluationInput>, InterviewUncheckedUpdateWithoutEvaluationInput>
  }

  export type EnumKnowledgeStatusFieldUpdateOperationsInput = {
    set?: $Enums.KnowledgeStatus
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<CourseCreateWithoutPaymentsInput, CourseUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPaymentsInput
    connect?: CourseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type CourseUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<CourseCreateWithoutPaymentsInput, CourseUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPaymentsInput
    upsert?: CourseUpsertWithoutPaymentsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutPaymentsInput, CourseUpdateWithoutPaymentsInput>, CourseUncheckedUpdateWithoutPaymentsInput>
  }

  export type ForumPostCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ForumPostCreateWithoutCategoryInput, ForumPostUncheckedCreateWithoutCategoryInput> | ForumPostCreateWithoutCategoryInput[] | ForumPostUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutCategoryInput | ForumPostCreateOrConnectWithoutCategoryInput[]
    createMany?: ForumPostCreateManyCategoryInputEnvelope
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
  }

  export type ForumPostUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ForumPostCreateWithoutCategoryInput, ForumPostUncheckedCreateWithoutCategoryInput> | ForumPostCreateWithoutCategoryInput[] | ForumPostUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutCategoryInput | ForumPostCreateOrConnectWithoutCategoryInput[]
    createMany?: ForumPostCreateManyCategoryInputEnvelope
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
  }

  export type ForumPostUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ForumPostCreateWithoutCategoryInput, ForumPostUncheckedCreateWithoutCategoryInput> | ForumPostCreateWithoutCategoryInput[] | ForumPostUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutCategoryInput | ForumPostCreateOrConnectWithoutCategoryInput[]
    upsert?: ForumPostUpsertWithWhereUniqueWithoutCategoryInput | ForumPostUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ForumPostCreateManyCategoryInputEnvelope
    set?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    disconnect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    delete?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    update?: ForumPostUpdateWithWhereUniqueWithoutCategoryInput | ForumPostUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ForumPostUpdateManyWithWhereWithoutCategoryInput | ForumPostUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
  }

  export type ForumPostUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ForumPostCreateWithoutCategoryInput, ForumPostUncheckedCreateWithoutCategoryInput> | ForumPostCreateWithoutCategoryInput[] | ForumPostUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutCategoryInput | ForumPostCreateOrConnectWithoutCategoryInput[]
    upsert?: ForumPostUpsertWithWhereUniqueWithoutCategoryInput | ForumPostUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ForumPostCreateManyCategoryInputEnvelope
    set?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    disconnect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    delete?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    update?: ForumPostUpdateWithWhereUniqueWithoutCategoryInput | ForumPostUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ForumPostUpdateManyWithWhereWithoutCategoryInput | ForumPostUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type ForumCategoryCreateNestedOneWithoutPostsInput = {
    create?: XOR<ForumCategoryCreateWithoutPostsInput, ForumCategoryUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ForumCategoryCreateOrConnectWithoutPostsInput
    connect?: ForumCategoryWhereUniqueInput
  }

  export type ForumCommentCreateNestedManyWithoutPostInput = {
    create?: XOR<ForumCommentCreateWithoutPostInput, ForumCommentUncheckedCreateWithoutPostInput> | ForumCommentCreateWithoutPostInput[] | ForumCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutPostInput | ForumCommentCreateOrConnectWithoutPostInput[]
    createMany?: ForumCommentCreateManyPostInputEnvelope
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
  }

  export type ForumCommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<ForumCommentCreateWithoutPostInput, ForumCommentUncheckedCreateWithoutPostInput> | ForumCommentCreateWithoutPostInput[] | ForumCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutPostInput | ForumCommentCreateOrConnectWithoutPostInput[]
    createMany?: ForumCommentCreateManyPostInputEnvelope
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostsInput, UserUpdateWithoutPostsInput>, UserUncheckedUpdateWithoutPostsInput>
  }

  export type ForumCategoryUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<ForumCategoryCreateWithoutPostsInput, ForumCategoryUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ForumCategoryCreateOrConnectWithoutPostsInput
    upsert?: ForumCategoryUpsertWithoutPostsInput
    connect?: ForumCategoryWhereUniqueInput
    update?: XOR<XOR<ForumCategoryUpdateToOneWithWhereWithoutPostsInput, ForumCategoryUpdateWithoutPostsInput>, ForumCategoryUncheckedUpdateWithoutPostsInput>
  }

  export type ForumCommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<ForumCommentCreateWithoutPostInput, ForumCommentUncheckedCreateWithoutPostInput> | ForumCommentCreateWithoutPostInput[] | ForumCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutPostInput | ForumCommentCreateOrConnectWithoutPostInput[]
    upsert?: ForumCommentUpsertWithWhereUniqueWithoutPostInput | ForumCommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ForumCommentCreateManyPostInputEnvelope
    set?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    disconnect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    delete?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    update?: ForumCommentUpdateWithWhereUniqueWithoutPostInput | ForumCommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ForumCommentUpdateManyWithWhereWithoutPostInput | ForumCommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ForumCommentScalarWhereInput | ForumCommentScalarWhereInput[]
  }

  export type ForumCommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<ForumCommentCreateWithoutPostInput, ForumCommentUncheckedCreateWithoutPostInput> | ForumCommentCreateWithoutPostInput[] | ForumCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutPostInput | ForumCommentCreateOrConnectWithoutPostInput[]
    upsert?: ForumCommentUpsertWithWhereUniqueWithoutPostInput | ForumCommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ForumCommentCreateManyPostInputEnvelope
    set?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    disconnect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    delete?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    update?: ForumCommentUpdateWithWhereUniqueWithoutPostInput | ForumCommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ForumCommentUpdateManyWithWhereWithoutPostInput | ForumCommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ForumCommentScalarWhereInput | ForumCommentScalarWhereInput[]
  }

  export type ForumPostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ForumPostCreateWithoutCommentsInput, ForumPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ForumPostCreateOrConnectWithoutCommentsInput
    connect?: ForumPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type ForumPostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ForumPostCreateWithoutCommentsInput, ForumPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ForumPostCreateOrConnectWithoutCommentsInput
    upsert?: ForumPostUpsertWithoutCommentsInput
    connect?: ForumPostWhereUniqueInput
    update?: XOR<XOR<ForumPostUpdateToOneWithWhereWithoutCommentsInput, ForumPostUpdateWithoutCommentsInput>, ForumPostUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserCreateNestedManyWithoutConversationsInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput> | UserCreateWithoutConversationsInput[] | UserUncheckedCreateWithoutConversationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput | UserCreateOrConnectWithoutConversationsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutConversationsInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput> | UserCreateWithoutConversationsInput[] | UserUncheckedCreateWithoutConversationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput | UserCreateOrConnectWithoutConversationsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutConversationsNestedInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput> | UserCreateWithoutConversationsInput[] | UserUncheckedCreateWithoutConversationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput | UserCreateOrConnectWithoutConversationsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutConversationsInput | UserUpsertWithWhereUniqueWithoutConversationsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutConversationsInput | UserUpdateWithWhereUniqueWithoutConversationsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutConversationsInput | UserUpdateManyWithWhereWithoutConversationsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutConversationsNestedInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput> | UserCreateWithoutConversationsInput[] | UserUncheckedCreateWithoutConversationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput | UserCreateOrConnectWithoutConversationsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutConversationsInput | UserUpsertWithWhereUniqueWithoutConversationsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutConversationsInput | UserUpdateWithWhereUniqueWithoutConversationsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutConversationsInput | UserUpdateManyWithWhereWithoutConversationsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<UserCreateWithoutCertificatesInput, UserUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCertificatesInput
    connect?: UserWhereUniqueInput
  }

  export type CertificateTemplateCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<CertificateTemplateCreateWithoutCertificatesInput, CertificateTemplateUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: CertificateTemplateCreateOrConnectWithoutCertificatesInput
    connect?: CertificateTemplateWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<UserCreateWithoutCertificatesInput, UserUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCertificatesInput
    upsert?: UserUpsertWithoutCertificatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCertificatesInput, UserUpdateWithoutCertificatesInput>, UserUncheckedUpdateWithoutCertificatesInput>
  }

  export type CertificateTemplateUpdateOneWithoutCertificatesNestedInput = {
    create?: XOR<CertificateTemplateCreateWithoutCertificatesInput, CertificateTemplateUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: CertificateTemplateCreateOrConnectWithoutCertificatesInput
    upsert?: CertificateTemplateUpsertWithoutCertificatesInput
    disconnect?: CertificateTemplateWhereInput | boolean
    delete?: CertificateTemplateWhereInput | boolean
    connect?: CertificateTemplateWhereUniqueInput
    update?: XOR<XOR<CertificateTemplateUpdateToOneWithWhereWithoutCertificatesInput, CertificateTemplateUpdateWithoutCertificatesInput>, CertificateTemplateUncheckedUpdateWithoutCertificatesInput>
  }

  export type CertificateCreateNestedManyWithoutTemplateInput = {
    create?: XOR<CertificateCreateWithoutTemplateInput, CertificateUncheckedCreateWithoutTemplateInput> | CertificateCreateWithoutTemplateInput[] | CertificateUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutTemplateInput | CertificateCreateOrConnectWithoutTemplateInput[]
    createMany?: CertificateCreateManyTemplateInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<CertificateCreateWithoutTemplateInput, CertificateUncheckedCreateWithoutTemplateInput> | CertificateCreateWithoutTemplateInput[] | CertificateUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutTemplateInput | CertificateCreateOrConnectWithoutTemplateInput[]
    createMany?: CertificateCreateManyTemplateInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type CertificateUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<CertificateCreateWithoutTemplateInput, CertificateUncheckedCreateWithoutTemplateInput> | CertificateCreateWithoutTemplateInput[] | CertificateUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutTemplateInput | CertificateCreateOrConnectWithoutTemplateInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutTemplateInput | CertificateUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: CertificateCreateManyTemplateInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutTemplateInput | CertificateUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutTemplateInput | CertificateUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<CertificateCreateWithoutTemplateInput, CertificateUncheckedCreateWithoutTemplateInput> | CertificateCreateWithoutTemplateInput[] | CertificateUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutTemplateInput | CertificateCreateOrConnectWithoutTemplateInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutTemplateInput | CertificateUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: CertificateCreateManyTemplateInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutTemplateInput | CertificateUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutTemplateInput | CertificateUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutLiveClassesInput = {
    create?: XOR<CourseCreateWithoutLiveClassesInput, CourseUncheckedCreateWithoutLiveClassesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLiveClassesInput
    connect?: CourseWhereUniqueInput
  }

  export type EnumLiveClassStatusFieldUpdateOperationsInput = {
    set?: $Enums.LiveClassStatus
  }

  export type CourseUpdateOneRequiredWithoutLiveClassesNestedInput = {
    create?: XOR<CourseCreateWithoutLiveClassesInput, CourseUncheckedCreateWithoutLiveClassesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLiveClassesInput
    upsert?: CourseUpsertWithoutLiveClassesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutLiveClassesInput, CourseUpdateWithoutLiveClassesInput>, CourseUncheckedUpdateWithoutLiveClassesInput>
  }

  export type TaskCreateNestedManyWithoutLeadInput = {
    create?: XOR<TaskCreateWithoutLeadInput, TaskUncheckedCreateWithoutLeadInput> | TaskCreateWithoutLeadInput[] | TaskUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutLeadInput | TaskCreateOrConnectWithoutLeadInput[]
    createMany?: TaskCreateManyLeadInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<TaskCreateWithoutLeadInput, TaskUncheckedCreateWithoutLeadInput> | TaskCreateWithoutLeadInput[] | TaskUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutLeadInput | TaskCreateOrConnectWithoutLeadInput[]
    createMany?: TaskCreateManyLeadInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type EnumLeadStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeadStatus
  }

  export type TaskUpdateManyWithoutLeadNestedInput = {
    create?: XOR<TaskCreateWithoutLeadInput, TaskUncheckedCreateWithoutLeadInput> | TaskCreateWithoutLeadInput[] | TaskUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutLeadInput | TaskCreateOrConnectWithoutLeadInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutLeadInput | TaskUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: TaskCreateManyLeadInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutLeadInput | TaskUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutLeadInput | TaskUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<TaskCreateWithoutLeadInput, TaskUncheckedCreateWithoutLeadInput> | TaskCreateWithoutLeadInput[] | TaskUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutLeadInput | TaskCreateOrConnectWithoutLeadInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutLeadInput | TaskUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: TaskCreateManyLeadInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutLeadInput | TaskUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutLeadInput | TaskUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAssignedTasksInput = {
    create?: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTasksInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedTasksInput = {
    create?: XOR<UserCreateWithoutCreatedTasksInput, UserUncheckedCreateWithoutCreatedTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTasksInput
    connect?: UserWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutTasksInput = {
    create?: XOR<LeadCreateWithoutTasksInput, LeadUncheckedCreateWithoutTasksInput>
    connectOrCreate?: LeadCreateOrConnectWithoutTasksInput
    connect?: LeadWhereUniqueInput
  }

  export type TaskCommentCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskCommentCreateWithoutTaskInput, TaskCommentUncheckedCreateWithoutTaskInput> | TaskCommentCreateWithoutTaskInput[] | TaskCommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutTaskInput | TaskCommentCreateOrConnectWithoutTaskInput[]
    createMany?: TaskCommentCreateManyTaskInputEnvelope
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
  }

  export type TaskCommentUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskCommentCreateWithoutTaskInput, TaskCommentUncheckedCreateWithoutTaskInput> | TaskCommentCreateWithoutTaskInput[] | TaskCommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutTaskInput | TaskCommentCreateOrConnectWithoutTaskInput[]
    createMany?: TaskCommentCreateManyTaskInputEnvelope
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type UserUpdateOneWithoutAssignedTasksNestedInput = {
    create?: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTasksInput
    upsert?: UserUpsertWithoutAssignedTasksInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedTasksInput, UserUpdateWithoutAssignedTasksInput>, UserUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type UserUpdateOneWithoutCreatedTasksNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTasksInput, UserUncheckedCreateWithoutCreatedTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTasksInput
    upsert?: UserUpsertWithoutCreatedTasksInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTasksInput, UserUpdateWithoutCreatedTasksInput>, UserUncheckedUpdateWithoutCreatedTasksInput>
  }

  export type LeadUpdateOneWithoutTasksNestedInput = {
    create?: XOR<LeadCreateWithoutTasksInput, LeadUncheckedCreateWithoutTasksInput>
    connectOrCreate?: LeadCreateOrConnectWithoutTasksInput
    upsert?: LeadUpsertWithoutTasksInput
    disconnect?: LeadWhereInput | boolean
    delete?: LeadWhereInput | boolean
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutTasksInput, LeadUpdateWithoutTasksInput>, LeadUncheckedUpdateWithoutTasksInput>
  }

  export type TaskCommentUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskCommentCreateWithoutTaskInput, TaskCommentUncheckedCreateWithoutTaskInput> | TaskCommentCreateWithoutTaskInput[] | TaskCommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutTaskInput | TaskCommentCreateOrConnectWithoutTaskInput[]
    upsert?: TaskCommentUpsertWithWhereUniqueWithoutTaskInput | TaskCommentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskCommentCreateManyTaskInputEnvelope
    set?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    disconnect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    delete?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    update?: TaskCommentUpdateWithWhereUniqueWithoutTaskInput | TaskCommentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskCommentUpdateManyWithWhereWithoutTaskInput | TaskCommentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskCommentScalarWhereInput | TaskCommentScalarWhereInput[]
  }

  export type TaskCommentUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskCommentCreateWithoutTaskInput, TaskCommentUncheckedCreateWithoutTaskInput> | TaskCommentCreateWithoutTaskInput[] | TaskCommentUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCommentCreateOrConnectWithoutTaskInput | TaskCommentCreateOrConnectWithoutTaskInput[]
    upsert?: TaskCommentUpsertWithWhereUniqueWithoutTaskInput | TaskCommentUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskCommentCreateManyTaskInputEnvelope
    set?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    disconnect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    delete?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    connect?: TaskCommentWhereUniqueInput | TaskCommentWhereUniqueInput[]
    update?: TaskCommentUpdateWithWhereUniqueWithoutTaskInput | TaskCommentUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskCommentUpdateManyWithWhereWithoutTaskInput | TaskCommentUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskCommentScalarWhereInput | TaskCommentScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCommentsInput
    connect?: TaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTaskCommentsInput = {
    create?: XOR<UserCreateWithoutTaskCommentsInput, UserUncheckedCreateWithoutTaskCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCommentsInput
    upsert?: TaskUpsertWithoutCommentsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutCommentsInput, TaskUpdateWithoutCommentsInput>, TaskUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutTaskCommentsNestedInput = {
    create?: XOR<UserCreateWithoutTaskCommentsInput, UserUncheckedCreateWithoutTaskCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskCommentsInput
    upsert?: UserUpsertWithoutTaskCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaskCommentsInput, UserUpdateWithoutTaskCommentsInput>, UserUncheckedUpdateWithoutTaskCommentsInput>
  }

  export type UserCreateNestedOneWithoutBlogPostsInput = {
    create?: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogPostsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumBlogStatusFieldUpdateOperationsInput = {
    set?: $Enums.BlogStatus
  }

  export type UserUpdateOneRequiredWithoutBlogPostsNestedInput = {
    create?: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogPostsInput
    upsert?: UserUpsertWithoutBlogPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogPostsInput, UserUpdateWithoutBlogPostsInput>, UserUncheckedUpdateWithoutBlogPostsInput>
  }

  export type UserCreateNestedOneWithoutTicketsInput = {
    create?: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type TicketMessageCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput> | TicketMessageCreateWithoutTicketInput[] | TicketMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutTicketInput | TicketMessageCreateOrConnectWithoutTicketInput[]
    createMany?: TicketMessageCreateManyTicketInputEnvelope
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
  }

  export type TicketMessageUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput> | TicketMessageCreateWithoutTicketInput[] | TicketMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutTicketInput | TicketMessageCreateOrConnectWithoutTicketInput[]
    createMany?: TicketMessageCreateManyTicketInputEnvelope
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
  }

  export type EnumTicketStatusFieldUpdateOperationsInput = {
    set?: $Enums.TicketStatus
  }

  export type EnumTicketPriorityFieldUpdateOperationsInput = {
    set?: $Enums.TicketPriority
  }

  export type EnumTicketCategoryFieldUpdateOperationsInput = {
    set?: $Enums.TicketCategory
  }

  export type UserUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsInput
    upsert?: UserUpsertWithoutTicketsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketsInput, UserUpdateWithoutTicketsInput>, UserUncheckedUpdateWithoutTicketsInput>
  }

  export type TicketMessageUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput> | TicketMessageCreateWithoutTicketInput[] | TicketMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutTicketInput | TicketMessageCreateOrConnectWithoutTicketInput[]
    upsert?: TicketMessageUpsertWithWhereUniqueWithoutTicketInput | TicketMessageUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketMessageCreateManyTicketInputEnvelope
    set?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    disconnect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    delete?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    update?: TicketMessageUpdateWithWhereUniqueWithoutTicketInput | TicketMessageUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketMessageUpdateManyWithWhereWithoutTicketInput | TicketMessageUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketMessageScalarWhereInput | TicketMessageScalarWhereInput[]
  }

  export type TicketMessageUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput> | TicketMessageCreateWithoutTicketInput[] | TicketMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutTicketInput | TicketMessageCreateOrConnectWithoutTicketInput[]
    upsert?: TicketMessageUpsertWithWhereUniqueWithoutTicketInput | TicketMessageUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketMessageCreateManyTicketInputEnvelope
    set?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    disconnect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    delete?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    update?: TicketMessageUpdateWithWhereUniqueWithoutTicketInput | TicketMessageUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketMessageUpdateManyWithWhereWithoutTicketInput | TicketMessageUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketMessageScalarWhereInput | TicketMessageScalarWhereInput[]
  }

  export type TicketCreateNestedOneWithoutMessagesInput = {
    create?: XOR<TicketCreateWithoutMessagesInput, TicketUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: TicketCreateOrConnectWithoutMessagesInput
    connect?: TicketWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentTicketMessagesInput = {
    create?: XOR<UserCreateWithoutSentTicketMessagesInput, UserUncheckedCreateWithoutSentTicketMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentTicketMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type TicketUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<TicketCreateWithoutMessagesInput, TicketUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: TicketCreateOrConnectWithoutMessagesInput
    upsert?: TicketUpsertWithoutMessagesInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutMessagesInput, TicketUpdateWithoutMessagesInput>, TicketUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneWithoutSentTicketMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentTicketMessagesInput, UserUncheckedCreateWithoutSentTicketMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentTicketMessagesInput
    upsert?: UserUpsertWithoutSentTicketMessagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentTicketMessagesInput, UserUpdateWithoutSentTicketMessagesInput>, UserUncheckedUpdateWithoutSentTicketMessagesInput>
  }

  export type EnumGatewayFieldUpdateOperationsInput = {
    set?: $Enums.Gateway
  }

  export type UserCreateNestedOneWithoutEmployerProfileInput = {
    create?: XOR<UserCreateWithoutEmployerProfileInput, UserUncheckedCreateWithoutEmployerProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployerProfileInput
    connect?: UserWhereUniqueInput
  }

  export type EnumEmployerStatusFieldUpdateOperationsInput = {
    set?: $Enums.EmployerStatus
  }

  export type UserUpdateOneRequiredWithoutEmployerProfileNestedInput = {
    create?: XOR<UserCreateWithoutEmployerProfileInput, UserUncheckedCreateWithoutEmployerProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployerProfileInput
    upsert?: UserUpsertWithoutEmployerProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployerProfileInput, UserUpdateWithoutEmployerProfileInput>, UserUncheckedUpdateWithoutEmployerProfileInput>
  }

  export type UserCreateNestedOneWithoutJobsInput = {
    create?: XOR<UserCreateWithoutJobsInput, UserUncheckedCreateWithoutJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobsInput
    connect?: UserWhereUniqueInput
  }

  export type JobApplicationCreateNestedManyWithoutJobInput = {
    create?: XOR<JobApplicationCreateWithoutJobInput, JobApplicationUncheckedCreateWithoutJobInput> | JobApplicationCreateWithoutJobInput[] | JobApplicationUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutJobInput | JobApplicationCreateOrConnectWithoutJobInput[]
    createMany?: JobApplicationCreateManyJobInputEnvelope
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
  }

  export type JobApplicationUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<JobApplicationCreateWithoutJobInput, JobApplicationUncheckedCreateWithoutJobInput> | JobApplicationCreateWithoutJobInput[] | JobApplicationUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutJobInput | JobApplicationCreateOrConnectWithoutJobInput[]
    createMany?: JobApplicationCreateManyJobInputEnvelope
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
  }

  export type EnumJobTypeFieldUpdateOperationsInput = {
    set?: $Enums.JobType
  }

  export type EnumJobStatusFieldUpdateOperationsInput = {
    set?: $Enums.JobStatus
  }

  export type UserUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<UserCreateWithoutJobsInput, UserUncheckedCreateWithoutJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobsInput
    upsert?: UserUpsertWithoutJobsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJobsInput, UserUpdateWithoutJobsInput>, UserUncheckedUpdateWithoutJobsInput>
  }

  export type JobApplicationUpdateManyWithoutJobNestedInput = {
    create?: XOR<JobApplicationCreateWithoutJobInput, JobApplicationUncheckedCreateWithoutJobInput> | JobApplicationCreateWithoutJobInput[] | JobApplicationUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutJobInput | JobApplicationCreateOrConnectWithoutJobInput[]
    upsert?: JobApplicationUpsertWithWhereUniqueWithoutJobInput | JobApplicationUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: JobApplicationCreateManyJobInputEnvelope
    set?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    disconnect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    delete?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    update?: JobApplicationUpdateWithWhereUniqueWithoutJobInput | JobApplicationUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: JobApplicationUpdateManyWithWhereWithoutJobInput | JobApplicationUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
  }

  export type JobApplicationUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<JobApplicationCreateWithoutJobInput, JobApplicationUncheckedCreateWithoutJobInput> | JobApplicationCreateWithoutJobInput[] | JobApplicationUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobApplicationCreateOrConnectWithoutJobInput | JobApplicationCreateOrConnectWithoutJobInput[]
    upsert?: JobApplicationUpsertWithWhereUniqueWithoutJobInput | JobApplicationUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: JobApplicationCreateManyJobInputEnvelope
    set?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    disconnect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    delete?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    connect?: JobApplicationWhereUniqueInput | JobApplicationWhereUniqueInput[]
    update?: JobApplicationUpdateWithWhereUniqueWithoutJobInput | JobApplicationUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: JobApplicationUpdateManyWithWhereWithoutJobInput | JobApplicationUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
  }

  export type JobCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<JobCreateWithoutApplicationsInput, JobUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: JobCreateOrConnectWithoutApplicationsInput
    connect?: JobWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApplicationsInput
    connect?: UserWhereUniqueInput
  }

  export type JobInterviewCreateNestedManyWithoutApplicationInput = {
    create?: XOR<JobInterviewCreateWithoutApplicationInput, JobInterviewUncheckedCreateWithoutApplicationInput> | JobInterviewCreateWithoutApplicationInput[] | JobInterviewUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: JobInterviewCreateOrConnectWithoutApplicationInput | JobInterviewCreateOrConnectWithoutApplicationInput[]
    createMany?: JobInterviewCreateManyApplicationInputEnvelope
    connect?: JobInterviewWhereUniqueInput | JobInterviewWhereUniqueInput[]
  }

  export type EmailLogCreateNestedManyWithoutApplicationInput = {
    create?: XOR<EmailLogCreateWithoutApplicationInput, EmailLogUncheckedCreateWithoutApplicationInput> | EmailLogCreateWithoutApplicationInput[] | EmailLogUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutApplicationInput | EmailLogCreateOrConnectWithoutApplicationInput[]
    createMany?: EmailLogCreateManyApplicationInputEnvelope
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutApplicationInput = {
    create?: XOR<AuditLogCreateWithoutApplicationInput, AuditLogUncheckedCreateWithoutApplicationInput> | AuditLogCreateWithoutApplicationInput[] | AuditLogUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutApplicationInput | AuditLogCreateOrConnectWithoutApplicationInput[]
    createMany?: AuditLogCreateManyApplicationInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type JobInterviewUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<JobInterviewCreateWithoutApplicationInput, JobInterviewUncheckedCreateWithoutApplicationInput> | JobInterviewCreateWithoutApplicationInput[] | JobInterviewUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: JobInterviewCreateOrConnectWithoutApplicationInput | JobInterviewCreateOrConnectWithoutApplicationInput[]
    createMany?: JobInterviewCreateManyApplicationInputEnvelope
    connect?: JobInterviewWhereUniqueInput | JobInterviewWhereUniqueInput[]
  }

  export type EmailLogUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<EmailLogCreateWithoutApplicationInput, EmailLogUncheckedCreateWithoutApplicationInput> | EmailLogCreateWithoutApplicationInput[] | EmailLogUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutApplicationInput | EmailLogCreateOrConnectWithoutApplicationInput[]
    createMany?: EmailLogCreateManyApplicationInputEnvelope
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<AuditLogCreateWithoutApplicationInput, AuditLogUncheckedCreateWithoutApplicationInput> | AuditLogCreateWithoutApplicationInput[] | AuditLogUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutApplicationInput | AuditLogCreateOrConnectWithoutApplicationInput[]
    createMany?: AuditLogCreateManyApplicationInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type EnumCandidateSourceFieldUpdateOperationsInput = {
    set?: $Enums.CandidateSource
  }

  export type EnumApplicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApplicationStatus
  }

  export type JobUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<JobCreateWithoutApplicationsInput, JobUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: JobCreateOrConnectWithoutApplicationsInput
    upsert?: JobUpsertWithoutApplicationsInput
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutApplicationsInput, JobUpdateWithoutApplicationsInput>, JobUncheckedUpdateWithoutApplicationsInput>
  }

  export type UserUpdateOneWithoutApplicationsNestedInput = {
    create?: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApplicationsInput
    upsert?: UserUpsertWithoutApplicationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApplicationsInput, UserUpdateWithoutApplicationsInput>, UserUncheckedUpdateWithoutApplicationsInput>
  }

  export type JobInterviewUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<JobInterviewCreateWithoutApplicationInput, JobInterviewUncheckedCreateWithoutApplicationInput> | JobInterviewCreateWithoutApplicationInput[] | JobInterviewUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: JobInterviewCreateOrConnectWithoutApplicationInput | JobInterviewCreateOrConnectWithoutApplicationInput[]
    upsert?: JobInterviewUpsertWithWhereUniqueWithoutApplicationInput | JobInterviewUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: JobInterviewCreateManyApplicationInputEnvelope
    set?: JobInterviewWhereUniqueInput | JobInterviewWhereUniqueInput[]
    disconnect?: JobInterviewWhereUniqueInput | JobInterviewWhereUniqueInput[]
    delete?: JobInterviewWhereUniqueInput | JobInterviewWhereUniqueInput[]
    connect?: JobInterviewWhereUniqueInput | JobInterviewWhereUniqueInput[]
    update?: JobInterviewUpdateWithWhereUniqueWithoutApplicationInput | JobInterviewUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: JobInterviewUpdateManyWithWhereWithoutApplicationInput | JobInterviewUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: JobInterviewScalarWhereInput | JobInterviewScalarWhereInput[]
  }

  export type EmailLogUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<EmailLogCreateWithoutApplicationInput, EmailLogUncheckedCreateWithoutApplicationInput> | EmailLogCreateWithoutApplicationInput[] | EmailLogUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutApplicationInput | EmailLogCreateOrConnectWithoutApplicationInput[]
    upsert?: EmailLogUpsertWithWhereUniqueWithoutApplicationInput | EmailLogUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: EmailLogCreateManyApplicationInputEnvelope
    set?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    disconnect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    delete?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    update?: EmailLogUpdateWithWhereUniqueWithoutApplicationInput | EmailLogUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: EmailLogUpdateManyWithWhereWithoutApplicationInput | EmailLogUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<AuditLogCreateWithoutApplicationInput, AuditLogUncheckedCreateWithoutApplicationInput> | AuditLogCreateWithoutApplicationInput[] | AuditLogUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutApplicationInput | AuditLogCreateOrConnectWithoutApplicationInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutApplicationInput | AuditLogUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: AuditLogCreateManyApplicationInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutApplicationInput | AuditLogUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutApplicationInput | AuditLogUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type JobInterviewUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<JobInterviewCreateWithoutApplicationInput, JobInterviewUncheckedCreateWithoutApplicationInput> | JobInterviewCreateWithoutApplicationInput[] | JobInterviewUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: JobInterviewCreateOrConnectWithoutApplicationInput | JobInterviewCreateOrConnectWithoutApplicationInput[]
    upsert?: JobInterviewUpsertWithWhereUniqueWithoutApplicationInput | JobInterviewUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: JobInterviewCreateManyApplicationInputEnvelope
    set?: JobInterviewWhereUniqueInput | JobInterviewWhereUniqueInput[]
    disconnect?: JobInterviewWhereUniqueInput | JobInterviewWhereUniqueInput[]
    delete?: JobInterviewWhereUniqueInput | JobInterviewWhereUniqueInput[]
    connect?: JobInterviewWhereUniqueInput | JobInterviewWhereUniqueInput[]
    update?: JobInterviewUpdateWithWhereUniqueWithoutApplicationInput | JobInterviewUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: JobInterviewUpdateManyWithWhereWithoutApplicationInput | JobInterviewUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: JobInterviewScalarWhereInput | JobInterviewScalarWhereInput[]
  }

  export type EmailLogUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<EmailLogCreateWithoutApplicationInput, EmailLogUncheckedCreateWithoutApplicationInput> | EmailLogCreateWithoutApplicationInput[] | EmailLogUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutApplicationInput | EmailLogCreateOrConnectWithoutApplicationInput[]
    upsert?: EmailLogUpsertWithWhereUniqueWithoutApplicationInput | EmailLogUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: EmailLogCreateManyApplicationInputEnvelope
    set?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    disconnect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    delete?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    update?: EmailLogUpdateWithWhereUniqueWithoutApplicationInput | EmailLogUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: EmailLogUpdateManyWithWhereWithoutApplicationInput | EmailLogUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<AuditLogCreateWithoutApplicationInput, AuditLogUncheckedCreateWithoutApplicationInput> | AuditLogCreateWithoutApplicationInput[] | AuditLogUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutApplicationInput | AuditLogCreateOrConnectWithoutApplicationInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutApplicationInput | AuditLogUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: AuditLogCreateManyApplicationInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutApplicationInput | AuditLogUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutApplicationInput | AuditLogUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type JobApplicationCreateNestedOneWithoutInterviewsInput = {
    create?: XOR<JobApplicationCreateWithoutInterviewsInput, JobApplicationUncheckedCreateWithoutInterviewsInput>
    connectOrCreate?: JobApplicationCreateOrConnectWithoutInterviewsInput
    connect?: JobApplicationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConductedJobInterviewsInput = {
    create?: XOR<UserCreateWithoutConductedJobInterviewsInput, UserUncheckedCreateWithoutConductedJobInterviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConductedJobInterviewsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumInterviewRoundTypeFieldUpdateOperationsInput = {
    set?: $Enums.InterviewRoundType
  }

  export type NullableEnumInterviewResultFieldUpdateOperationsInput = {
    set?: $Enums.InterviewResult | null
  }

  export type JobApplicationUpdateOneRequiredWithoutInterviewsNestedInput = {
    create?: XOR<JobApplicationCreateWithoutInterviewsInput, JobApplicationUncheckedCreateWithoutInterviewsInput>
    connectOrCreate?: JobApplicationCreateOrConnectWithoutInterviewsInput
    upsert?: JobApplicationUpsertWithoutInterviewsInput
    connect?: JobApplicationWhereUniqueInput
    update?: XOR<XOR<JobApplicationUpdateToOneWithWhereWithoutInterviewsInput, JobApplicationUpdateWithoutInterviewsInput>, JobApplicationUncheckedUpdateWithoutInterviewsInput>
  }

  export type UserUpdateOneRequiredWithoutConductedJobInterviewsNestedInput = {
    create?: XOR<UserCreateWithoutConductedJobInterviewsInput, UserUncheckedCreateWithoutConductedJobInterviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConductedJobInterviewsInput
    upsert?: UserUpsertWithoutConductedJobInterviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConductedJobInterviewsInput, UserUpdateWithoutConductedJobInterviewsInput>, UserUncheckedUpdateWithoutConductedJobInterviewsInput>
  }

  export type JobApplicationCreateNestedOneWithoutEmailLogsInput = {
    create?: XOR<JobApplicationCreateWithoutEmailLogsInput, JobApplicationUncheckedCreateWithoutEmailLogsInput>
    connectOrCreate?: JobApplicationCreateOrConnectWithoutEmailLogsInput
    connect?: JobApplicationWhereUniqueInput
  }

  export type EnumEmailStatusFieldUpdateOperationsInput = {
    set?: $Enums.EmailStatus
  }

  export type JobApplicationUpdateOneWithoutEmailLogsNestedInput = {
    create?: XOR<JobApplicationCreateWithoutEmailLogsInput, JobApplicationUncheckedCreateWithoutEmailLogsInput>
    connectOrCreate?: JobApplicationCreateOrConnectWithoutEmailLogsInput
    upsert?: JobApplicationUpsertWithoutEmailLogsInput
    disconnect?: JobApplicationWhereInput | boolean
    delete?: JobApplicationWhereInput | boolean
    connect?: JobApplicationWhereUniqueInput
    update?: XOR<XOR<JobApplicationUpdateToOneWithWhereWithoutEmailLogsInput, JobApplicationUpdateWithoutEmailLogsInput>, JobApplicationUncheckedUpdateWithoutEmailLogsInput>
  }

  export type JobApplicationCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<JobApplicationCreateWithoutAuditLogsInput, JobApplicationUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: JobApplicationCreateOrConnectWithoutAuditLogsInput
    connect?: JobApplicationWhereUniqueInput
  }

  export type JobApplicationUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<JobApplicationCreateWithoutAuditLogsInput, JobApplicationUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: JobApplicationCreateOrConnectWithoutAuditLogsInput
    upsert?: JobApplicationUpsertWithoutAuditLogsInput
    disconnect?: JobApplicationWhereInput | boolean
    delete?: JobApplicationWhereInput | boolean
    connect?: JobApplicationWhereUniqueInput
    update?: XOR<XOR<JobApplicationUpdateToOneWithWhereWithoutAuditLogsInput, JobApplicationUpdateWithoutAuditLogsInput>, JobApplicationUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumDifficultyFilter<$PrismaModel = never> = {
    equals?: $Enums.Difficulty | EnumDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.Difficulty[] | ListEnumDifficultyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Difficulty[] | ListEnumDifficultyFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyFilter<$PrismaModel> | $Enums.Difficulty
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumCourseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseType | EnumCourseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseTypeFilter<$PrismaModel> | $Enums.CourseType
  }

  export type NestedEnumPublishStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PublishStatus | EnumPublishStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublishStatusFilter<$PrismaModel> | $Enums.PublishStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumDifficultyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Difficulty | EnumDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.Difficulty[] | ListEnumDifficultyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Difficulty[] | ListEnumDifficultyFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyWithAggregatesFilter<$PrismaModel> | $Enums.Difficulty
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDifficultyFilter<$PrismaModel>
    _max?: NestedEnumDifficultyFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumCourseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseType | EnumCourseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseTypeWithAggregatesFilter<$PrismaModel> | $Enums.CourseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseTypeFilter<$PrismaModel>
    _max?: NestedEnumCourseTypeFilter<$PrismaModel>
  }

  export type NestedEnumPublishStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PublishStatus | EnumPublishStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublishStatusWithAggregatesFilter<$PrismaModel> | $Enums.PublishStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPublishStatusFilter<$PrismaModel>
    _max?: NestedEnumPublishStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumLessonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeFilter<$PrismaModel> | $Enums.LessonType
  }

  export type NestedEnumLessonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeWithAggregatesFilter<$PrismaModel> | $Enums.LessonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLessonTypeFilter<$PrismaModel>
    _max?: NestedEnumLessonTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumEnrollmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EnrollmentStatus | EnumEnrollmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnrollmentStatusFilter<$PrismaModel> | $Enums.EnrollmentStatus
  }

  export type NestedEnumEnrollmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnrollmentStatus | EnumEnrollmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EnrollmentStatus[] | ListEnumEnrollmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEnrollmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EnrollmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnrollmentStatusFilter<$PrismaModel>
    _max?: NestedEnumEnrollmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumInterviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewStatus | EnumInterviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterviewStatus[] | ListEnumInterviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterviewStatus[] | ListEnumInterviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterviewStatusFilter<$PrismaModel> | $Enums.InterviewStatus
  }

  export type NestedEnumInterviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewStatus | EnumInterviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterviewStatus[] | ListEnumInterviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterviewStatus[] | ListEnumInterviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.InterviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterviewStatusFilter<$PrismaModel>
    _max?: NestedEnumInterviewStatusFilter<$PrismaModel>
  }

  export type NestedEnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }

  export type NestedEnumKnowledgeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KnowledgeStatus | EnumKnowledgeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KnowledgeStatus[] | ListEnumKnowledgeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KnowledgeStatus[] | ListEnumKnowledgeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKnowledgeStatusFilter<$PrismaModel> | $Enums.KnowledgeStatus
  }

  export type NestedEnumKnowledgeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KnowledgeStatus | EnumKnowledgeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KnowledgeStatus[] | ListEnumKnowledgeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KnowledgeStatus[] | ListEnumKnowledgeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKnowledgeStatusWithAggregatesFilter<$PrismaModel> | $Enums.KnowledgeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKnowledgeStatusFilter<$PrismaModel>
    _max?: NestedEnumKnowledgeStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumLiveClassStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LiveClassStatus | EnumLiveClassStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LiveClassStatus[] | ListEnumLiveClassStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LiveClassStatus[] | ListEnumLiveClassStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLiveClassStatusFilter<$PrismaModel> | $Enums.LiveClassStatus
  }

  export type NestedEnumLiveClassStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LiveClassStatus | EnumLiveClassStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LiveClassStatus[] | ListEnumLiveClassStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LiveClassStatus[] | ListEnumLiveClassStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLiveClassStatusWithAggregatesFilter<$PrismaModel> | $Enums.LiveClassStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLiveClassStatusFilter<$PrismaModel>
    _max?: NestedEnumLiveClassStatusFilter<$PrismaModel>
  }

  export type NestedEnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumBlogStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BlogStatus | EnumBlogStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BlogStatus[] | ListEnumBlogStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BlogStatus[] | ListEnumBlogStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBlogStatusFilter<$PrismaModel> | $Enums.BlogStatus
  }

  export type NestedEnumBlogStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BlogStatus | EnumBlogStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BlogStatus[] | ListEnumBlogStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BlogStatus[] | ListEnumBlogStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBlogStatusWithAggregatesFilter<$PrismaModel> | $Enums.BlogStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBlogStatusFilter<$PrismaModel>
    _max?: NestedEnumBlogStatusFilter<$PrismaModel>
  }

  export type NestedEnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type NestedEnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type NestedEnumTicketCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketCategory | EnumTicketCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketCategoryFilter<$PrismaModel> | $Enums.TicketCategory
  }

  export type NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type NestedEnumTicketCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketCategory | EnumTicketCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketCategory[] | ListEnumTicketCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TicketCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketCategoryFilter<$PrismaModel>
    _max?: NestedEnumTicketCategoryFilter<$PrismaModel>
  }

  export type NestedEnumGatewayFilter<$PrismaModel = never> = {
    equals?: $Enums.Gateway | EnumGatewayFieldRefInput<$PrismaModel>
    in?: $Enums.Gateway[] | ListEnumGatewayFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gateway[] | ListEnumGatewayFieldRefInput<$PrismaModel>
    not?: NestedEnumGatewayFilter<$PrismaModel> | $Enums.Gateway
  }

  export type NestedEnumGatewayWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gateway | EnumGatewayFieldRefInput<$PrismaModel>
    in?: $Enums.Gateway[] | ListEnumGatewayFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gateway[] | ListEnumGatewayFieldRefInput<$PrismaModel>
    not?: NestedEnumGatewayWithAggregatesFilter<$PrismaModel> | $Enums.Gateway
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGatewayFilter<$PrismaModel>
    _max?: NestedEnumGatewayFilter<$PrismaModel>
  }

  export type NestedEnumEmployerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployerStatus | EnumEmployerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployerStatus[] | ListEnumEmployerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployerStatus[] | ListEnumEmployerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployerStatusFilter<$PrismaModel> | $Enums.EmployerStatus
  }

  export type NestedEnumEmployerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployerStatus | EnumEmployerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployerStatus[] | ListEnumEmployerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployerStatus[] | ListEnumEmployerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployerStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmployerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmployerStatusFilter<$PrismaModel>
    _max?: NestedEnumEmployerStatusFilter<$PrismaModel>
  }

  export type NestedEnumJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeFilter<$PrismaModel> | $Enums.JobType
  }

  export type NestedEnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type NestedEnumJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.JobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobTypeFilter<$PrismaModel>
    _max?: NestedEnumJobTypeFilter<$PrismaModel>
  }

  export type NestedEnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type NestedEnumCandidateSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.CandidateSource | EnumCandidateSourceFieldRefInput<$PrismaModel>
    in?: $Enums.CandidateSource[] | ListEnumCandidateSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.CandidateSource[] | ListEnumCandidateSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumCandidateSourceFilter<$PrismaModel> | $Enums.CandidateSource
  }

  export type NestedEnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type NestedEnumCandidateSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CandidateSource | EnumCandidateSourceFieldRefInput<$PrismaModel>
    in?: $Enums.CandidateSource[] | ListEnumCandidateSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.CandidateSource[] | ListEnumCandidateSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumCandidateSourceWithAggregatesFilter<$PrismaModel> | $Enums.CandidateSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCandidateSourceFilter<$PrismaModel>
    _max?: NestedEnumCandidateSourceFilter<$PrismaModel>
  }

  export type NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type NestedEnumInterviewRoundTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewRoundType | EnumInterviewRoundTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InterviewRoundType[] | ListEnumInterviewRoundTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterviewRoundType[] | ListEnumInterviewRoundTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInterviewRoundTypeFilter<$PrismaModel> | $Enums.InterviewRoundType
  }

  export type NestedEnumInterviewResultNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewResult | EnumInterviewResultFieldRefInput<$PrismaModel> | null
    in?: $Enums.InterviewResult[] | ListEnumInterviewResultFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InterviewResult[] | ListEnumInterviewResultFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInterviewResultNullableFilter<$PrismaModel> | $Enums.InterviewResult | null
  }

  export type NestedEnumInterviewRoundTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewRoundType | EnumInterviewRoundTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InterviewRoundType[] | ListEnumInterviewRoundTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterviewRoundType[] | ListEnumInterviewRoundTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInterviewRoundTypeWithAggregatesFilter<$PrismaModel> | $Enums.InterviewRoundType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterviewRoundTypeFilter<$PrismaModel>
    _max?: NestedEnumInterviewRoundTypeFilter<$PrismaModel>
  }

  export type NestedEnumInterviewResultNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewResult | EnumInterviewResultFieldRefInput<$PrismaModel> | null
    in?: $Enums.InterviewResult[] | ListEnumInterviewResultFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InterviewResult[] | ListEnumInterviewResultFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInterviewResultNullableWithAggregatesFilter<$PrismaModel> | $Enums.InterviewResult | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumInterviewResultNullableFilter<$PrismaModel>
    _max?: NestedEnumInterviewResultNullableFilter<$PrismaModel>
  }

  export type NestedEnumEmailStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailStatus | EnumEmailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailStatusFilter<$PrismaModel> | $Enums.EmailStatus
  }

  export type NestedEnumEmailStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailStatus | EnumEmailStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailStatus[] | ListEnumEmailStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmailStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailStatusFilter<$PrismaModel>
    _max?: NestedEnumEmailStatusFilter<$PrismaModel>
  }

  export type EnrollmentCreateWithoutUserInput = {
    id?: string
    progress?: number
    status?: $Enums.EnrollmentStatus
    hasInterviewAccess?: boolean
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    course: CourseCreateNestedOneWithoutEnrollmentsInput
    batch?: BatchCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateWithoutUserInput = {
    id?: string
    courseId: string
    progress?: number
    status?: $Enums.EnrollmentStatus
    hasInterviewAccess?: boolean
    batchId?: string | null
    enrolledAt?: Date | string
    completedAt?: Date | string | null
  }

  export type EnrollmentCreateOrConnectWithoutUserInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput>
  }

  export type EnrollmentCreateManyUserInputEnvelope = {
    data: EnrollmentCreateManyUserInput | EnrollmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InterviewCreateWithoutUserInput = {
    id?: string
    domain: string
    company?: string | null
    role: string
    technology?: string | null
    jobDescription?: string | null
    resumeUrl?: string | null
    difficulty?: $Enums.Difficulty
    panelCount?: number
    linkedCourseId?: string | null
    duration?: number
    selectedAvatars?: InterviewCreateselectedAvatarsInput | string[]
    status?: $Enums.InterviewStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    questions?: InterviewQuestionCreateNestedManyWithoutInterviewInput
    responses?: InterviewResponseCreateNestedManyWithoutInterviewInput
    evaluation?: InterviewEvaluationCreateNestedOneWithoutInterviewInput
  }

  export type InterviewUncheckedCreateWithoutUserInput = {
    id?: string
    domain: string
    company?: string | null
    role: string
    technology?: string | null
    jobDescription?: string | null
    resumeUrl?: string | null
    difficulty?: $Enums.Difficulty
    panelCount?: number
    linkedCourseId?: string | null
    duration?: number
    selectedAvatars?: InterviewCreateselectedAvatarsInput | string[]
    status?: $Enums.InterviewStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    questions?: InterviewQuestionUncheckedCreateNestedManyWithoutInterviewInput
    responses?: InterviewResponseUncheckedCreateNestedManyWithoutInterviewInput
    evaluation?: InterviewEvaluationUncheckedCreateNestedOneWithoutInterviewInput
  }

  export type InterviewCreateOrConnectWithoutUserInput = {
    where: InterviewWhereUniqueInput
    create: XOR<InterviewCreateWithoutUserInput, InterviewUncheckedCreateWithoutUserInput>
  }

  export type InterviewCreateManyUserInputEnvelope = {
    data: InterviewCreateManyUserInput | InterviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LessonProgressCreateWithoutUserInput = {
    id?: string
    completed?: boolean
    score?: number | null
    timeSpent?: number
    lastAccessedAt?: Date | string
    lesson: LessonCreateNestedOneWithoutProgressInput
  }

  export type LessonProgressUncheckedCreateWithoutUserInput = {
    id?: string
    lessonId: string
    completed?: boolean
    score?: number | null
    timeSpent?: number
    lastAccessedAt?: Date | string
  }

  export type LessonProgressCreateOrConnectWithoutUserInput = {
    where: LessonProgressWhereUniqueInput
    create: XOR<LessonProgressCreateWithoutUserInput, LessonProgressUncheckedCreateWithoutUserInput>
  }

  export type LessonProgressCreateManyUserInputEnvelope = {
    data: LessonProgressCreateManyUserInput | LessonProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ForumPostCreateWithoutAuthorInput = {
    id?: string
    title: string
    content: string
    slug: string
    likes?: number
    views?: number
    isPinned?: boolean
    isSolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category: ForumCategoryCreateNestedOneWithoutPostsInput
    comments?: ForumCommentCreateNestedManyWithoutPostInput
  }

  export type ForumPostUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    content: string
    slug: string
    categoryId: string
    likes?: number
    views?: number
    isPinned?: boolean
    isSolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ForumCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type ForumPostCreateOrConnectWithoutAuthorInput = {
    where: ForumPostWhereUniqueInput
    create: XOR<ForumPostCreateWithoutAuthorInput, ForumPostUncheckedCreateWithoutAuthorInput>
  }

  export type ForumPostCreateManyAuthorInputEnvelope = {
    data: ForumPostCreateManyAuthorInput | ForumPostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ForumCommentCreateWithoutAuthorInput = {
    id?: string
    content: string
    parentId?: string | null
    isSolution?: boolean
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    post: ForumPostCreateNestedOneWithoutCommentsInput
  }

  export type ForumCommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    content: string
    postId: string
    parentId?: string | null
    isSolution?: boolean
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCommentCreateOrConnectWithoutAuthorInput = {
    where: ForumCommentWhereUniqueInput
    create: XOR<ForumCommentCreateWithoutAuthorInput, ForumCommentUncheckedCreateWithoutAuthorInput>
  }

  export type ForumCommentCreateManyAuthorInputEnvelope = {
    data: ForumCommentCreateManyAuthorInput | ForumCommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutParticipantsInput = {
    id?: string
    name?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutParticipantsInput = {
    id?: string
    name?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutParticipantsInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content: string
    readBy?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    conversationId: string
    content: string
    readBy?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    orderId: string
    paymentId?: string | null
    signature?: string | null
    amount: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    orderId: string
    paymentId?: string | null
    signature?: string | null
    amount: number
    currency?: string
    status?: string
    courseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutUserInput = {
    id?: string
    uniqueId: string
    courseId: string
    enrollmentId: string
    studentName: string
    courseName: string
    courseCategory?: string | null
    issueDate?: Date | string
    expiryDate?: Date | string | null
    signatureUrl?: string | null
    signatoryName?: string | null
    signatoryTitle?: string | null
    verificationUrl?: string | null
    isValid?: boolean
    grade?: string | null
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: CertificateTemplateCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateWithoutUserInput = {
    id?: string
    uniqueId: string
    courseId: string
    enrollmentId: string
    studentName: string
    courseName: string
    courseCategory?: string | null
    issueDate?: Date | string
    expiryDate?: Date | string | null
    templateId?: string | null
    signatureUrl?: string | null
    signatoryName?: string | null
    signatoryTitle?: string | null
    verificationUrl?: string | null
    isValid?: boolean
    grade?: string | null
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateCreateOrConnectWithoutUserInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput>
  }

  export type CertificateCreateManyUserInputEnvelope = {
    data: CertificateCreateManyUserInput | CertificateCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: string
    courseId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutUserInput = {
    id?: string
    subject: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    category?: $Enums.TicketCategory
    assignedTo?: string | null
    internalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: TicketMessageCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutUserInput = {
    id?: string
    subject: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    category?: $Enums.TicketCategory
    assignedTo?: string | null
    internalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: TicketMessageUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutUserInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput>
  }

  export type TicketCreateManyUserInputEnvelope = {
    data: TicketCreateManyUserInput | TicketCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TicketMessageCreateWithoutUserInput = {
    id?: string
    message: string
    attachmentUrl?: string | null
    isStaffReply?: boolean
    createdAt?: Date | string
    ticket: TicketCreateNestedOneWithoutMessagesInput
  }

  export type TicketMessageUncheckedCreateWithoutUserInput = {
    id?: string
    message: string
    attachmentUrl?: string | null
    isStaffReply?: boolean
    ticketId: string
    createdAt?: Date | string
  }

  export type TicketMessageCreateOrConnectWithoutUserInput = {
    where: TicketMessageWhereUniqueInput
    create: XOR<TicketMessageCreateWithoutUserInput, TicketMessageUncheckedCreateWithoutUserInput>
  }

  export type TicketMessageCreateManyUserInputEnvelope = {
    data: TicketMessageCreateManyUserInput | TicketMessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmployerProfileCreateWithoutUserInput = {
    id?: string
    companyName: string
    website?: string | null
    description?: string | null
    logo?: string | null
    location?: string | null
    industry?: string | null
    companySize?: string | null
    status?: $Enums.EmployerStatus
    documentsVerified?: boolean
    verificationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployerProfileUncheckedCreateWithoutUserInput = {
    id?: string
    companyName: string
    website?: string | null
    description?: string | null
    logo?: string | null
    location?: string | null
    industry?: string | null
    companySize?: string | null
    status?: $Enums.EmployerStatus
    documentsVerified?: boolean
    verificationNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployerProfileCreateOrConnectWithoutUserInput = {
    where: EmployerProfileWhereUniqueInput
    create: XOR<EmployerProfileCreateWithoutUserInput, EmployerProfileUncheckedCreateWithoutUserInput>
  }

  export type JobCreateWithoutEmployerInput = {
    id?: string
    title: string
    description: string
    requirements?: string | null
    location: string
    type?: $Enums.JobType
    experience?: string | null
    salary?: string | null
    skills?: string | null
    clientName?: string | null
    shift?: string | null
    domain?: string | null
    qualification?: string | null
    status?: $Enums.JobStatus
    publishedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: JobApplicationCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutEmployerInput = {
    id?: string
    title: string
    description: string
    requirements?: string | null
    location: string
    type?: $Enums.JobType
    experience?: string | null
    salary?: string | null
    skills?: string | null
    clientName?: string | null
    shift?: string | null
    domain?: string | null
    qualification?: string | null
    status?: $Enums.JobStatus
    publishedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: JobApplicationUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutEmployerInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutEmployerInput, JobUncheckedCreateWithoutEmployerInput>
  }

  export type JobCreateManyEmployerInputEnvelope = {
    data: JobCreateManyEmployerInput | JobCreateManyEmployerInput[]
    skipDuplicates?: boolean
  }

  export type JobApplicationCreateWithoutApplicantInput = {
    id?: string
    source?: $Enums.CandidateSource
    externalName?: string | null
    externalEmail?: string | null
    externalPhone?: string | null
    resumeUrl?: string | null
    coverLetter?: string | null
    resumeParsedText?: string | null
    atsScore?: number
    status?: $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    job: JobCreateNestedOneWithoutApplicationsInput
    interviews?: JobInterviewCreateNestedManyWithoutApplicationInput
    emailLogs?: EmailLogCreateNestedManyWithoutApplicationInput
    auditLogs?: AuditLogCreateNestedManyWithoutApplicationInput
  }

  export type JobApplicationUncheckedCreateWithoutApplicantInput = {
    id?: string
    jobId: string
    source?: $Enums.CandidateSource
    externalName?: string | null
    externalEmail?: string | null
    externalPhone?: string | null
    resumeUrl?: string | null
    coverLetter?: string | null
    resumeParsedText?: string | null
    atsScore?: number
    status?: $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interviews?: JobInterviewUncheckedCreateNestedManyWithoutApplicationInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutApplicationInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type JobApplicationCreateOrConnectWithoutApplicantInput = {
    where: JobApplicationWhereUniqueInput
    create: XOR<JobApplicationCreateWithoutApplicantInput, JobApplicationUncheckedCreateWithoutApplicantInput>
  }

  export type JobApplicationCreateManyApplicantInputEnvelope = {
    data: JobApplicationCreateManyApplicantInput | JobApplicationCreateManyApplicantInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutCreatedTasksInput
    lead?: LeadCreateNestedOneWithoutTasksInput
    comments?: TaskCommentCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    createdBy?: string | null
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: TaskCommentUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput>
  }

  export type TaskCreateManyAssigneeInputEnvelope = {
    data: TaskCreateManyAssigneeInput | TaskCreateManyAssigneeInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignee?: UserCreateNestedOneWithoutAssignedTasksInput
    lead?: LeadCreateNestedOneWithoutTasksInput
    comments?: TaskCommentCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    assignedTo?: string | null
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: TaskCommentUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutCreatorInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput>
  }

  export type TaskCreateManyCreatorInputEnvelope = {
    data: TaskCreateManyCreatorInput | TaskCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    content: string
    summary?: string | null
    coverImage?: string | null
    status?: $Enums.BlogStatus
    tags?: NullableJsonNullValueInput | InputJsonValue
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    content: string
    summary?: string | null
    coverImage?: string | null
    status?: $Enums.BlogStatus
    tags?: NullableJsonNullValueInput | InputJsonValue
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostCreateOrConnectWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput>
  }

  export type BlogPostCreateManyAuthorInputEnvelope = {
    data: BlogPostCreateManyAuthorInput | BlogPostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type TaskCommentCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutCommentsInput
  }

  export type TaskCommentUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    taskId: string
    createdAt?: Date | string
  }

  export type TaskCommentCreateOrConnectWithoutUserInput = {
    where: TaskCommentWhereUniqueInput
    create: XOR<TaskCommentCreateWithoutUserInput, TaskCommentUncheckedCreateWithoutUserInput>
  }

  export type TaskCommentCreateManyUserInputEnvelope = {
    data: TaskCommentCreateManyUserInput | TaskCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentSubmissionCreateWithoutUserInput = {
    id?: string
    content?: string | null
    fileUrl?: string | null
    grade?: number | null
    feedback?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lesson: LessonCreateNestedOneWithoutAssignmentSubmissionsInput
  }

  export type AssignmentSubmissionUncheckedCreateWithoutUserInput = {
    id?: string
    lessonId: string
    content?: string | null
    fileUrl?: string | null
    grade?: number | null
    feedback?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentSubmissionCreateOrConnectWithoutUserInput = {
    where: AssignmentSubmissionWhereUniqueInput
    create: XOR<AssignmentSubmissionCreateWithoutUserInput, AssignmentSubmissionUncheckedCreateWithoutUserInput>
  }

  export type AssignmentSubmissionCreateManyUserInputEnvelope = {
    data: AssignmentSubmissionCreateManyUserInput | AssignmentSubmissionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LessonCommentCreateWithoutUserInput = {
    id?: string
    content: string
    isPinned?: boolean
    isInstructorResponse?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lesson: LessonCreateNestedOneWithoutCommentsInput
    parent?: LessonCommentCreateNestedOneWithoutRepliesInput
    replies?: LessonCommentCreateNestedManyWithoutParentInput
  }

  export type LessonCommentUncheckedCreateWithoutUserInput = {
    id?: string
    lessonId: string
    content: string
    parentId?: string | null
    isPinned?: boolean
    isInstructorResponse?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: LessonCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type LessonCommentCreateOrConnectWithoutUserInput = {
    where: LessonCommentWhereUniqueInput
    create: XOR<LessonCommentCreateWithoutUserInput, LessonCommentUncheckedCreateWithoutUserInput>
  }

  export type LessonCommentCreateManyUserInputEnvelope = {
    data: LessonCommentCreateManyUserInput | LessonCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BatchCreateWithoutInstructorInput = {
    id?: string
    name: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    description?: string | null
    maxStudents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutBatchesInput
    announcements?: AnnouncementCreateNestedManyWithoutBatchInput
    enrollments?: EnrollmentCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutInstructorInput = {
    id?: string
    name: string
    courseId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    description?: string | null
    maxStudents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutBatchInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutInstructorInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutInstructorInput, BatchUncheckedCreateWithoutInstructorInput>
  }

  export type BatchCreateManyInstructorInputEnvelope = {
    data: BatchCreateManyInstructorInput | BatchCreateManyInstructorInput[]
    skipDuplicates?: boolean
  }

  export type AnnouncementCreateWithoutInstructorInput = {
    id?: string
    title: string
    content: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    course?: CourseCreateNestedOneWithoutAnnouncementsInput
    batch?: BatchCreateNestedOneWithoutAnnouncementsInput
  }

  export type AnnouncementUncheckedCreateWithoutInstructorInput = {
    id?: string
    title: string
    content: string
    priority?: string
    courseId?: string | null
    batchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementCreateOrConnectWithoutInstructorInput = {
    where: AnnouncementWhereUniqueInput
    create: XOR<AnnouncementCreateWithoutInstructorInput, AnnouncementUncheckedCreateWithoutInstructorInput>
  }

  export type AnnouncementCreateManyInstructorInputEnvelope = {
    data: AnnouncementCreateManyInstructorInput | AnnouncementCreateManyInstructorInput[]
    skipDuplicates?: boolean
  }

  export type JobInterviewCreateWithoutInterviewerInput = {
    id?: string
    roundName: string
    roundType?: $Enums.InterviewRoundType
    scheduledAt: Date | string
    duration?: number
    meetingLink?: string | null
    location?: string | null
    status?: $Enums.InterviewStatus
    feedback?: string | null
    score?: number | null
    result?: $Enums.InterviewResult | null
    createdAt?: Date | string
    updatedAt?: Date | string
    application: JobApplicationCreateNestedOneWithoutInterviewsInput
  }

  export type JobInterviewUncheckedCreateWithoutInterviewerInput = {
    id?: string
    applicationId: string
    roundName: string
    roundType?: $Enums.InterviewRoundType
    scheduledAt: Date | string
    duration?: number
    meetingLink?: string | null
    location?: string | null
    status?: $Enums.InterviewStatus
    feedback?: string | null
    score?: number | null
    result?: $Enums.InterviewResult | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobInterviewCreateOrConnectWithoutInterviewerInput = {
    where: JobInterviewWhereUniqueInput
    create: XOR<JobInterviewCreateWithoutInterviewerInput, JobInterviewUncheckedCreateWithoutInterviewerInput>
  }

  export type JobInterviewCreateManyInterviewerInputEnvelope = {
    data: JobInterviewCreateManyInterviewerInput | JobInterviewCreateManyInterviewerInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutUserInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutUserInput, EnrollmentUncheckedUpdateWithoutUserInput>
    create: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutUserInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutUserInput, EnrollmentUncheckedUpdateWithoutUserInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutUserInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutUserInput>
  }

  export type EnrollmentScalarWhereInput = {
    AND?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    OR?: EnrollmentScalarWhereInput[]
    NOT?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    id?: StringFilter<"Enrollment"> | string
    userId?: StringFilter<"Enrollment"> | string
    courseId?: StringFilter<"Enrollment"> | string
    progress?: IntFilter<"Enrollment"> | number
    status?: EnumEnrollmentStatusFilter<"Enrollment"> | $Enums.EnrollmentStatus
    hasInterviewAccess?: BoolFilter<"Enrollment"> | boolean
    batchId?: StringNullableFilter<"Enrollment"> | string | null
    enrolledAt?: DateTimeFilter<"Enrollment"> | Date | string
    completedAt?: DateTimeNullableFilter<"Enrollment"> | Date | string | null
  }

  export type InterviewUpsertWithWhereUniqueWithoutUserInput = {
    where: InterviewWhereUniqueInput
    update: XOR<InterviewUpdateWithoutUserInput, InterviewUncheckedUpdateWithoutUserInput>
    create: XOR<InterviewCreateWithoutUserInput, InterviewUncheckedCreateWithoutUserInput>
  }

  export type InterviewUpdateWithWhereUniqueWithoutUserInput = {
    where: InterviewWhereUniqueInput
    data: XOR<InterviewUpdateWithoutUserInput, InterviewUncheckedUpdateWithoutUserInput>
  }

  export type InterviewUpdateManyWithWhereWithoutUserInput = {
    where: InterviewScalarWhereInput
    data: XOR<InterviewUpdateManyMutationInput, InterviewUncheckedUpdateManyWithoutUserInput>
  }

  export type InterviewScalarWhereInput = {
    AND?: InterviewScalarWhereInput | InterviewScalarWhereInput[]
    OR?: InterviewScalarWhereInput[]
    NOT?: InterviewScalarWhereInput | InterviewScalarWhereInput[]
    id?: StringFilter<"Interview"> | string
    userId?: StringFilter<"Interview"> | string
    domain?: StringFilter<"Interview"> | string
    company?: StringNullableFilter<"Interview"> | string | null
    role?: StringFilter<"Interview"> | string
    technology?: StringNullableFilter<"Interview"> | string | null
    jobDescription?: StringNullableFilter<"Interview"> | string | null
    resumeUrl?: StringNullableFilter<"Interview"> | string | null
    difficulty?: EnumDifficultyFilter<"Interview"> | $Enums.Difficulty
    panelCount?: IntFilter<"Interview"> | number
    linkedCourseId?: StringNullableFilter<"Interview"> | string | null
    duration?: IntFilter<"Interview"> | number
    selectedAvatars?: StringNullableListFilter<"Interview">
    status?: EnumInterviewStatusFilter<"Interview"> | $Enums.InterviewStatus
    scheduledAt?: DateTimeNullableFilter<"Interview"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Interview"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Interview"> | Date | string | null
    createdAt?: DateTimeFilter<"Interview"> | Date | string
  }

  export type LessonProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: LessonProgressWhereUniqueInput
    update: XOR<LessonProgressUpdateWithoutUserInput, LessonProgressUncheckedUpdateWithoutUserInput>
    create: XOR<LessonProgressCreateWithoutUserInput, LessonProgressUncheckedCreateWithoutUserInput>
  }

  export type LessonProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: LessonProgressWhereUniqueInput
    data: XOR<LessonProgressUpdateWithoutUserInput, LessonProgressUncheckedUpdateWithoutUserInput>
  }

  export type LessonProgressUpdateManyWithWhereWithoutUserInput = {
    where: LessonProgressScalarWhereInput
    data: XOR<LessonProgressUpdateManyMutationInput, LessonProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type LessonProgressScalarWhereInput = {
    AND?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
    OR?: LessonProgressScalarWhereInput[]
    NOT?: LessonProgressScalarWhereInput | LessonProgressScalarWhereInput[]
    id?: StringFilter<"LessonProgress"> | string
    userId?: StringFilter<"LessonProgress"> | string
    lessonId?: StringFilter<"LessonProgress"> | string
    completed?: BoolFilter<"LessonProgress"> | boolean
    score?: IntNullableFilter<"LessonProgress"> | number | null
    timeSpent?: IntFilter<"LessonProgress"> | number
    lastAccessedAt?: DateTimeFilter<"LessonProgress"> | Date | string
  }

  export type ForumPostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ForumPostWhereUniqueInput
    update: XOR<ForumPostUpdateWithoutAuthorInput, ForumPostUncheckedUpdateWithoutAuthorInput>
    create: XOR<ForumPostCreateWithoutAuthorInput, ForumPostUncheckedCreateWithoutAuthorInput>
  }

  export type ForumPostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ForumPostWhereUniqueInput
    data: XOR<ForumPostUpdateWithoutAuthorInput, ForumPostUncheckedUpdateWithoutAuthorInput>
  }

  export type ForumPostUpdateManyWithWhereWithoutAuthorInput = {
    where: ForumPostScalarWhereInput
    data: XOR<ForumPostUpdateManyMutationInput, ForumPostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ForumPostScalarWhereInput = {
    AND?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
    OR?: ForumPostScalarWhereInput[]
    NOT?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
    id?: StringFilter<"ForumPost"> | string
    title?: StringFilter<"ForumPost"> | string
    content?: StringFilter<"ForumPost"> | string
    slug?: StringFilter<"ForumPost"> | string
    authorId?: StringFilter<"ForumPost"> | string
    categoryId?: StringFilter<"ForumPost"> | string
    likes?: IntFilter<"ForumPost"> | number
    views?: IntFilter<"ForumPost"> | number
    isPinned?: BoolFilter<"ForumPost"> | boolean
    isSolved?: BoolFilter<"ForumPost"> | boolean
    createdAt?: DateTimeFilter<"ForumPost"> | Date | string
    updatedAt?: DateTimeFilter<"ForumPost"> | Date | string
  }

  export type ForumCommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ForumCommentWhereUniqueInput
    update: XOR<ForumCommentUpdateWithoutAuthorInput, ForumCommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<ForumCommentCreateWithoutAuthorInput, ForumCommentUncheckedCreateWithoutAuthorInput>
  }

  export type ForumCommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ForumCommentWhereUniqueInput
    data: XOR<ForumCommentUpdateWithoutAuthorInput, ForumCommentUncheckedUpdateWithoutAuthorInput>
  }

  export type ForumCommentUpdateManyWithWhereWithoutAuthorInput = {
    where: ForumCommentScalarWhereInput
    data: XOR<ForumCommentUpdateManyMutationInput, ForumCommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ForumCommentScalarWhereInput = {
    AND?: ForumCommentScalarWhereInput | ForumCommentScalarWhereInput[]
    OR?: ForumCommentScalarWhereInput[]
    NOT?: ForumCommentScalarWhereInput | ForumCommentScalarWhereInput[]
    id?: StringFilter<"ForumComment"> | string
    content?: StringFilter<"ForumComment"> | string
    postId?: StringFilter<"ForumComment"> | string
    authorId?: StringFilter<"ForumComment"> | string
    parentId?: StringNullableFilter<"ForumComment"> | string | null
    isSolution?: BoolFilter<"ForumComment"> | boolean
    likes?: IntFilter<"ForumComment"> | number
    createdAt?: DateTimeFilter<"ForumComment"> | Date | string
    updatedAt?: DateTimeFilter<"ForumComment"> | Date | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutParticipantsInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutParticipantsInput, ConversationUncheckedUpdateWithoutParticipantsInput>
    create: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutParticipantsInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutParticipantsInput, ConversationUncheckedUpdateWithoutParticipantsInput>
  }

  export type ConversationUpdateManyWithWhereWithoutParticipantsInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutParticipantsInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: StringFilter<"Conversation"> | string
    name?: StringNullableFilter<"Conversation"> | string | null
    isGroup?: BoolFilter<"Conversation"> | boolean
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    readBy?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    orderId?: StringFilter<"Payment"> | string
    paymentId?: StringNullableFilter<"Payment"> | string | null
    signature?: StringNullableFilter<"Payment"> | string | null
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    courseId?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type CertificateUpsertWithWhereUniqueWithoutUserInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutUserInput, CertificateUncheckedUpdateWithoutUserInput>
    create: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutUserInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutUserInput, CertificateUncheckedUpdateWithoutUserInput>
  }

  export type CertificateUpdateManyWithWhereWithoutUserInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutUserInput>
  }

  export type CertificateScalarWhereInput = {
    AND?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    OR?: CertificateScalarWhereInput[]
    NOT?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    id?: StringFilter<"Certificate"> | string
    uniqueId?: StringFilter<"Certificate"> | string
    userId?: StringFilter<"Certificate"> | string
    courseId?: StringFilter<"Certificate"> | string
    enrollmentId?: StringFilter<"Certificate"> | string
    studentName?: StringFilter<"Certificate"> | string
    courseName?: StringFilter<"Certificate"> | string
    courseCategory?: StringNullableFilter<"Certificate"> | string | null
    issueDate?: DateTimeFilter<"Certificate"> | Date | string
    expiryDate?: DateTimeNullableFilter<"Certificate"> | Date | string | null
    templateId?: StringNullableFilter<"Certificate"> | string | null
    signatureUrl?: StringNullableFilter<"Certificate"> | string | null
    signatoryName?: StringNullableFilter<"Certificate"> | string | null
    signatoryTitle?: StringNullableFilter<"Certificate"> | string | null
    verificationUrl?: StringNullableFilter<"Certificate"> | string | null
    isValid?: BoolFilter<"Certificate"> | boolean
    grade?: StringNullableFilter<"Certificate"> | string | null
    score?: FloatNullableFilter<"Certificate"> | number | null
    createdAt?: DateTimeFilter<"Certificate"> | Date | string
    updatedAt?: DateTimeFilter<"Certificate"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    courseId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type TicketUpsertWithWhereUniqueWithoutUserInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutUserInput, TicketUncheckedUpdateWithoutUserInput>
    create: XOR<TicketCreateWithoutUserInput, TicketUncheckedCreateWithoutUserInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutUserInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutUserInput, TicketUncheckedUpdateWithoutUserInput>
  }

  export type TicketUpdateManyWithWhereWithoutUserInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutUserInput>
  }

  export type TicketScalarWhereInput = {
    AND?: TicketScalarWhereInput | TicketScalarWhereInput[]
    OR?: TicketScalarWhereInput[]
    NOT?: TicketScalarWhereInput | TicketScalarWhereInput[]
    id?: StringFilter<"Ticket"> | string
    subject?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityFilter<"Ticket"> | $Enums.TicketPriority
    category?: EnumTicketCategoryFilter<"Ticket"> | $Enums.TicketCategory
    userId?: StringFilter<"Ticket"> | string
    assignedTo?: StringNullableFilter<"Ticket"> | string | null
    internalNotes?: StringNullableFilter<"Ticket"> | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
  }

  export type TicketMessageUpsertWithWhereUniqueWithoutUserInput = {
    where: TicketMessageWhereUniqueInput
    update: XOR<TicketMessageUpdateWithoutUserInput, TicketMessageUncheckedUpdateWithoutUserInput>
    create: XOR<TicketMessageCreateWithoutUserInput, TicketMessageUncheckedCreateWithoutUserInput>
  }

  export type TicketMessageUpdateWithWhereUniqueWithoutUserInput = {
    where: TicketMessageWhereUniqueInput
    data: XOR<TicketMessageUpdateWithoutUserInput, TicketMessageUncheckedUpdateWithoutUserInput>
  }

  export type TicketMessageUpdateManyWithWhereWithoutUserInput = {
    where: TicketMessageScalarWhereInput
    data: XOR<TicketMessageUpdateManyMutationInput, TicketMessageUncheckedUpdateManyWithoutUserInput>
  }

  export type TicketMessageScalarWhereInput = {
    AND?: TicketMessageScalarWhereInput | TicketMessageScalarWhereInput[]
    OR?: TicketMessageScalarWhereInput[]
    NOT?: TicketMessageScalarWhereInput | TicketMessageScalarWhereInput[]
    id?: StringFilter<"TicketMessage"> | string
    message?: StringFilter<"TicketMessage"> | string
    attachmentUrl?: StringNullableFilter<"TicketMessage"> | string | null
    isStaffReply?: BoolFilter<"TicketMessage"> | boolean
    ticketId?: StringFilter<"TicketMessage"> | string
    createdAt?: DateTimeFilter<"TicketMessage"> | Date | string
    userId?: StringNullableFilter<"TicketMessage"> | string | null
  }

  export type EmployerProfileUpsertWithoutUserInput = {
    update: XOR<EmployerProfileUpdateWithoutUserInput, EmployerProfileUncheckedUpdateWithoutUserInput>
    create: XOR<EmployerProfileCreateWithoutUserInput, EmployerProfileUncheckedCreateWithoutUserInput>
    where?: EmployerProfileWhereInput
  }

  export type EmployerProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: EmployerProfileWhereInput
    data: XOR<EmployerProfileUpdateWithoutUserInput, EmployerProfileUncheckedUpdateWithoutUserInput>
  }

  export type EmployerProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployerStatusFieldUpdateOperationsInput | $Enums.EmployerStatus
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployerProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployerStatusFieldUpdateOperationsInput | $Enums.EmployerStatus
    documentsVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobUpsertWithWhereUniqueWithoutEmployerInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutEmployerInput, JobUncheckedUpdateWithoutEmployerInput>
    create: XOR<JobCreateWithoutEmployerInput, JobUncheckedCreateWithoutEmployerInput>
  }

  export type JobUpdateWithWhereUniqueWithoutEmployerInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutEmployerInput, JobUncheckedUpdateWithoutEmployerInput>
  }

  export type JobUpdateManyWithWhereWithoutEmployerInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutEmployerInput>
  }

  export type JobScalarWhereInput = {
    AND?: JobScalarWhereInput | JobScalarWhereInput[]
    OR?: JobScalarWhereInput[]
    NOT?: JobScalarWhereInput | JobScalarWhereInput[]
    id?: StringFilter<"Job"> | string
    title?: StringFilter<"Job"> | string
    description?: StringFilter<"Job"> | string
    requirements?: StringNullableFilter<"Job"> | string | null
    location?: StringFilter<"Job"> | string
    type?: EnumJobTypeFilter<"Job"> | $Enums.JobType
    experience?: StringNullableFilter<"Job"> | string | null
    salary?: StringNullableFilter<"Job"> | string | null
    skills?: StringNullableFilter<"Job"> | string | null
    clientName?: StringNullableFilter<"Job"> | string | null
    shift?: StringNullableFilter<"Job"> | string | null
    domain?: StringNullableFilter<"Job"> | string | null
    qualification?: StringNullableFilter<"Job"> | string | null
    employerId?: StringFilter<"Job"> | string
    status?: EnumJobStatusFilter<"Job"> | $Enums.JobStatus
    publishedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
  }

  export type JobApplicationUpsertWithWhereUniqueWithoutApplicantInput = {
    where: JobApplicationWhereUniqueInput
    update: XOR<JobApplicationUpdateWithoutApplicantInput, JobApplicationUncheckedUpdateWithoutApplicantInput>
    create: XOR<JobApplicationCreateWithoutApplicantInput, JobApplicationUncheckedCreateWithoutApplicantInput>
  }

  export type JobApplicationUpdateWithWhereUniqueWithoutApplicantInput = {
    where: JobApplicationWhereUniqueInput
    data: XOR<JobApplicationUpdateWithoutApplicantInput, JobApplicationUncheckedUpdateWithoutApplicantInput>
  }

  export type JobApplicationUpdateManyWithWhereWithoutApplicantInput = {
    where: JobApplicationScalarWhereInput
    data: XOR<JobApplicationUpdateManyMutationInput, JobApplicationUncheckedUpdateManyWithoutApplicantInput>
  }

  export type JobApplicationScalarWhereInput = {
    AND?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
    OR?: JobApplicationScalarWhereInput[]
    NOT?: JobApplicationScalarWhereInput | JobApplicationScalarWhereInput[]
    id?: StringFilter<"JobApplication"> | string
    jobId?: StringFilter<"JobApplication"> | string
    applicantId?: StringNullableFilter<"JobApplication"> | string | null
    source?: EnumCandidateSourceFilter<"JobApplication"> | $Enums.CandidateSource
    externalName?: StringNullableFilter<"JobApplication"> | string | null
    externalEmail?: StringNullableFilter<"JobApplication"> | string | null
    externalPhone?: StringNullableFilter<"JobApplication"> | string | null
    resumeUrl?: StringNullableFilter<"JobApplication"> | string | null
    coverLetter?: StringNullableFilter<"JobApplication"> | string | null
    resumeParsedText?: StringNullableFilter<"JobApplication"> | string | null
    atsScore?: FloatFilter<"JobApplication"> | number
    status?: EnumApplicationStatusFilter<"JobApplication"> | $Enums.ApplicationStatus
    statusHistory?: JsonNullableFilter<"JobApplication">
    createdAt?: DateTimeFilter<"JobApplication"> | Date | string
    updatedAt?: DateTimeFilter<"JobApplication"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutAssigneeInput, TaskUncheckedUpdateWithoutAssigneeInput>
    create: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutAssigneeInput, TaskUncheckedUpdateWithoutAssigneeInput>
  }

  export type TaskUpdateManyWithWhereWithoutAssigneeInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutAssigneeInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    priority?: EnumPriorityFilter<"Task"> | $Enums.Priority
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    assignedTo?: StringNullableFilter<"Task"> | string | null
    createdBy?: StringNullableFilter<"Task"> | string | null
    leadId?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutCreatorInput, TaskUncheckedUpdateWithoutCreatorInput>
    create: XOR<TaskCreateWithoutCreatorInput, TaskUncheckedCreateWithoutCreatorInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutCreatorInput, TaskUncheckedUpdateWithoutCreatorInput>
  }

  export type TaskUpdateManyWithWhereWithoutCreatorInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutCreatorInput>
  }

  export type BlogPostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    update: XOR<BlogPostUpdateWithoutAuthorInput, BlogPostUncheckedUpdateWithoutAuthorInput>
    create: XOR<BlogPostCreateWithoutAuthorInput, BlogPostUncheckedCreateWithoutAuthorInput>
  }

  export type BlogPostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: BlogPostWhereUniqueInput
    data: XOR<BlogPostUpdateWithoutAuthorInput, BlogPostUncheckedUpdateWithoutAuthorInput>
  }

  export type BlogPostUpdateManyWithWhereWithoutAuthorInput = {
    where: BlogPostScalarWhereInput
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type BlogPostScalarWhereInput = {
    AND?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    OR?: BlogPostScalarWhereInput[]
    NOT?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    id?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    slug?: StringFilter<"BlogPost"> | string
    content?: StringFilter<"BlogPost"> | string
    summary?: StringNullableFilter<"BlogPost"> | string | null
    coverImage?: StringNullableFilter<"BlogPost"> | string | null
    status?: EnumBlogStatusFilter<"BlogPost"> | $Enums.BlogStatus
    tags?: JsonNullableFilter<"BlogPost">
    authorId?: StringFilter<"BlogPost"> | string
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
  }

  export type TaskCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskCommentWhereUniqueInput
    update: XOR<TaskCommentUpdateWithoutUserInput, TaskCommentUncheckedUpdateWithoutUserInput>
    create: XOR<TaskCommentCreateWithoutUserInput, TaskCommentUncheckedCreateWithoutUserInput>
  }

  export type TaskCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskCommentWhereUniqueInput
    data: XOR<TaskCommentUpdateWithoutUserInput, TaskCommentUncheckedUpdateWithoutUserInput>
  }

  export type TaskCommentUpdateManyWithWhereWithoutUserInput = {
    where: TaskCommentScalarWhereInput
    data: XOR<TaskCommentUpdateManyMutationInput, TaskCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type TaskCommentScalarWhereInput = {
    AND?: TaskCommentScalarWhereInput | TaskCommentScalarWhereInput[]
    OR?: TaskCommentScalarWhereInput[]
    NOT?: TaskCommentScalarWhereInput | TaskCommentScalarWhereInput[]
    id?: StringFilter<"TaskComment"> | string
    content?: StringFilter<"TaskComment"> | string
    taskId?: StringFilter<"TaskComment"> | string
    userId?: StringFilter<"TaskComment"> | string
    createdAt?: DateTimeFilter<"TaskComment"> | Date | string
  }

  export type AssignmentSubmissionUpsertWithWhereUniqueWithoutUserInput = {
    where: AssignmentSubmissionWhereUniqueInput
    update: XOR<AssignmentSubmissionUpdateWithoutUserInput, AssignmentSubmissionUncheckedUpdateWithoutUserInput>
    create: XOR<AssignmentSubmissionCreateWithoutUserInput, AssignmentSubmissionUncheckedCreateWithoutUserInput>
  }

  export type AssignmentSubmissionUpdateWithWhereUniqueWithoutUserInput = {
    where: AssignmentSubmissionWhereUniqueInput
    data: XOR<AssignmentSubmissionUpdateWithoutUserInput, AssignmentSubmissionUncheckedUpdateWithoutUserInput>
  }

  export type AssignmentSubmissionUpdateManyWithWhereWithoutUserInput = {
    where: AssignmentSubmissionScalarWhereInput
    data: XOR<AssignmentSubmissionUpdateManyMutationInput, AssignmentSubmissionUncheckedUpdateManyWithoutUserInput>
  }

  export type AssignmentSubmissionScalarWhereInput = {
    AND?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
    OR?: AssignmentSubmissionScalarWhereInput[]
    NOT?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
    id?: StringFilter<"AssignmentSubmission"> | string
    lessonId?: StringFilter<"AssignmentSubmission"> | string
    userId?: StringFilter<"AssignmentSubmission"> | string
    content?: StringNullableFilter<"AssignmentSubmission"> | string | null
    fileUrl?: StringNullableFilter<"AssignmentSubmission"> | string | null
    grade?: IntNullableFilter<"AssignmentSubmission"> | number | null
    feedback?: StringNullableFilter<"AssignmentSubmission"> | string | null
    status?: StringFilter<"AssignmentSubmission"> | string
    createdAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
  }

  export type LessonCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: LessonCommentWhereUniqueInput
    update: XOR<LessonCommentUpdateWithoutUserInput, LessonCommentUncheckedUpdateWithoutUserInput>
    create: XOR<LessonCommentCreateWithoutUserInput, LessonCommentUncheckedCreateWithoutUserInput>
  }

  export type LessonCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: LessonCommentWhereUniqueInput
    data: XOR<LessonCommentUpdateWithoutUserInput, LessonCommentUncheckedUpdateWithoutUserInput>
  }

  export type LessonCommentUpdateManyWithWhereWithoutUserInput = {
    where: LessonCommentScalarWhereInput
    data: XOR<LessonCommentUpdateManyMutationInput, LessonCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type LessonCommentScalarWhereInput = {
    AND?: LessonCommentScalarWhereInput | LessonCommentScalarWhereInput[]
    OR?: LessonCommentScalarWhereInput[]
    NOT?: LessonCommentScalarWhereInput | LessonCommentScalarWhereInput[]
    id?: StringFilter<"LessonComment"> | string
    lessonId?: StringFilter<"LessonComment"> | string
    userId?: StringFilter<"LessonComment"> | string
    content?: StringFilter<"LessonComment"> | string
    parentId?: StringNullableFilter<"LessonComment"> | string | null
    isPinned?: BoolFilter<"LessonComment"> | boolean
    isInstructorResponse?: BoolFilter<"LessonComment"> | boolean
    createdAt?: DateTimeFilter<"LessonComment"> | Date | string
    updatedAt?: DateTimeFilter<"LessonComment"> | Date | string
  }

  export type BatchUpsertWithWhereUniqueWithoutInstructorInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutInstructorInput, BatchUncheckedUpdateWithoutInstructorInput>
    create: XOR<BatchCreateWithoutInstructorInput, BatchUncheckedCreateWithoutInstructorInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutInstructorInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutInstructorInput, BatchUncheckedUpdateWithoutInstructorInput>
  }

  export type BatchUpdateManyWithWhereWithoutInstructorInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutInstructorInput>
  }

  export type BatchScalarWhereInput = {
    AND?: BatchScalarWhereInput | BatchScalarWhereInput[]
    OR?: BatchScalarWhereInput[]
    NOT?: BatchScalarWhereInput | BatchScalarWhereInput[]
    id?: StringFilter<"Batch"> | string
    name?: StringFilter<"Batch"> | string
    courseId?: StringFilter<"Batch"> | string
    instructorId?: StringFilter<"Batch"> | string
    startDate?: DateTimeNullableFilter<"Batch"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Batch"> | Date | string | null
    description?: StringNullableFilter<"Batch"> | string | null
    maxStudents?: IntNullableFilter<"Batch"> | number | null
    createdAt?: DateTimeFilter<"Batch"> | Date | string
    updatedAt?: DateTimeFilter<"Batch"> | Date | string
  }

  export type AnnouncementUpsertWithWhereUniqueWithoutInstructorInput = {
    where: AnnouncementWhereUniqueInput
    update: XOR<AnnouncementUpdateWithoutInstructorInput, AnnouncementUncheckedUpdateWithoutInstructorInput>
    create: XOR<AnnouncementCreateWithoutInstructorInput, AnnouncementUncheckedCreateWithoutInstructorInput>
  }

  export type AnnouncementUpdateWithWhereUniqueWithoutInstructorInput = {
    where: AnnouncementWhereUniqueInput
    data: XOR<AnnouncementUpdateWithoutInstructorInput, AnnouncementUncheckedUpdateWithoutInstructorInput>
  }

  export type AnnouncementUpdateManyWithWhereWithoutInstructorInput = {
    where: AnnouncementScalarWhereInput
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyWithoutInstructorInput>
  }

  export type AnnouncementScalarWhereInput = {
    AND?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    OR?: AnnouncementScalarWhereInput[]
    NOT?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[]
    id?: StringFilter<"Announcement"> | string
    title?: StringFilter<"Announcement"> | string
    content?: StringFilter<"Announcement"> | string
    priority?: StringFilter<"Announcement"> | string
    courseId?: StringNullableFilter<"Announcement"> | string | null
    batchId?: StringNullableFilter<"Announcement"> | string | null
    instructorId?: StringFilter<"Announcement"> | string
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeFilter<"Announcement"> | Date | string
  }

  export type JobInterviewUpsertWithWhereUniqueWithoutInterviewerInput = {
    where: JobInterviewWhereUniqueInput
    update: XOR<JobInterviewUpdateWithoutInterviewerInput, JobInterviewUncheckedUpdateWithoutInterviewerInput>
    create: XOR<JobInterviewCreateWithoutInterviewerInput, JobInterviewUncheckedCreateWithoutInterviewerInput>
  }

  export type JobInterviewUpdateWithWhereUniqueWithoutInterviewerInput = {
    where: JobInterviewWhereUniqueInput
    data: XOR<JobInterviewUpdateWithoutInterviewerInput, JobInterviewUncheckedUpdateWithoutInterviewerInput>
  }

  export type JobInterviewUpdateManyWithWhereWithoutInterviewerInput = {
    where: JobInterviewScalarWhereInput
    data: XOR<JobInterviewUpdateManyMutationInput, JobInterviewUncheckedUpdateManyWithoutInterviewerInput>
  }

  export type JobInterviewScalarWhereInput = {
    AND?: JobInterviewScalarWhereInput | JobInterviewScalarWhereInput[]
    OR?: JobInterviewScalarWhereInput[]
    NOT?: JobInterviewScalarWhereInput | JobInterviewScalarWhereInput[]
    id?: StringFilter<"JobInterview"> | string
    applicationId?: StringFilter<"JobInterview"> | string
    roundName?: StringFilter<"JobInterview"> | string
    roundType?: EnumInterviewRoundTypeFilter<"JobInterview"> | $Enums.InterviewRoundType
    scheduledAt?: DateTimeFilter<"JobInterview"> | Date | string
    duration?: IntFilter<"JobInterview"> | number
    meetingLink?: StringNullableFilter<"JobInterview"> | string | null
    location?: StringNullableFilter<"JobInterview"> | string | null
    interviewerId?: StringFilter<"JobInterview"> | string
    status?: EnumInterviewStatusFilter<"JobInterview"> | $Enums.InterviewStatus
    feedback?: StringNullableFilter<"JobInterview"> | string | null
    score?: IntNullableFilter<"JobInterview"> | number | null
    result?: EnumInterviewResultNullableFilter<"JobInterview"> | $Enums.InterviewResult | null
    createdAt?: DateTimeFilter<"JobInterview"> | Date | string
    updatedAt?: DateTimeFilter<"JobInterview"> | Date | string
  }

  export type ModuleCreateWithoutCourseInput = {
    id?: string
    title: string
    description?: string | null
    orderIndex: number
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lessons?: LessonCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutCourseInput = {
    id?: string
    title: string
    description?: string | null
    orderIndex: number
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutCourseInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput>
  }

  export type ModuleCreateManyCourseInputEnvelope = {
    data: ModuleCreateManyCourseInput | ModuleCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentCreateWithoutCourseInput = {
    id?: string
    progress?: number
    status?: $Enums.EnrollmentStatus
    hasInterviewAccess?: boolean
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutEnrollmentsInput
    batch?: BatchCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    progress?: number
    status?: $Enums.EnrollmentStatus
    hasInterviewAccess?: boolean
    batchId?: string | null
    enrolledAt?: Date | string
    completedAt?: Date | string | null
  }

  export type EnrollmentCreateOrConnectWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput>
  }

  export type EnrollmentCreateManyCourseInputEnvelope = {
    data: EnrollmentCreateManyCourseInput | EnrollmentCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutCourseInput = {
    id?: string
    orderId: string
    paymentId?: string | null
    signature?: string | null
    amount: number
    currency?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutCourseInput = {
    id?: string
    orderId: string
    paymentId?: string | null
    signature?: string | null
    amount: number
    currency?: string
    status?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutCourseInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCourseInput, PaymentUncheckedCreateWithoutCourseInput>
  }

  export type PaymentCreateManyCourseInputEnvelope = {
    data: PaymentCreateManyCourseInput | PaymentCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutCourseInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutCourseInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutCourseInput, ReviewUncheckedCreateWithoutCourseInput>
  }

  export type ReviewCreateManyCourseInputEnvelope = {
    data: ReviewCreateManyCourseInput | ReviewCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type LiveClassCreateWithoutCourseInput = {
    id?: string
    title: string
    description?: string | null
    platform: string
    meetingLink?: string | null
    meetingId?: string | null
    password?: string | null
    scheduledAt: Date | string
    duration: number
    timezone?: string
    status?: $Enums.LiveClassStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    recordingUrl?: string | null
    recordingPassword?: string | null
    hostId?: string | null
    hostName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiveClassUncheckedCreateWithoutCourseInput = {
    id?: string
    title: string
    description?: string | null
    platform: string
    meetingLink?: string | null
    meetingId?: string | null
    password?: string | null
    scheduledAt: Date | string
    duration: number
    timezone?: string
    status?: $Enums.LiveClassStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    recordingUrl?: string | null
    recordingPassword?: string | null
    hostId?: string | null
    hostName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiveClassCreateOrConnectWithoutCourseInput = {
    where: LiveClassWhereUniqueInput
    create: XOR<LiveClassCreateWithoutCourseInput, LiveClassUncheckedCreateWithoutCourseInput>
  }

  export type LiveClassCreateManyCourseInputEnvelope = {
    data: LiveClassCreateManyCourseInput | LiveClassCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type BatchCreateWithoutCourseInput = {
    id?: string
    name: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    description?: string | null
    maxStudents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    instructor: UserCreateNestedOneWithoutInstructedBatchesInput
    announcements?: AnnouncementCreateNestedManyWithoutBatchInput
    enrollments?: EnrollmentCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutCourseInput = {
    id?: string
    name: string
    instructorId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    description?: string | null
    maxStudents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutBatchInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutCourseInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutCourseInput, BatchUncheckedCreateWithoutCourseInput>
  }

  export type BatchCreateManyCourseInputEnvelope = {
    data: BatchCreateManyCourseInput | BatchCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type AnnouncementCreateWithoutCourseInput = {
    id?: string
    title: string
    content: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    batch?: BatchCreateNestedOneWithoutAnnouncementsInput
    instructor: UserCreateNestedOneWithoutAnnouncementsInput
  }

  export type AnnouncementUncheckedCreateWithoutCourseInput = {
    id?: string
    title: string
    content: string
    priority?: string
    batchId?: string | null
    instructorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementCreateOrConnectWithoutCourseInput = {
    where: AnnouncementWhereUniqueInput
    create: XOR<AnnouncementCreateWithoutCourseInput, AnnouncementUncheckedCreateWithoutCourseInput>
  }

  export type AnnouncementCreateManyCourseInputEnvelope = {
    data: AnnouncementCreateManyCourseInput | AnnouncementCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type ModuleUpsertWithWhereUniqueWithoutCourseInput = {
    where: ModuleWhereUniqueInput
    update: XOR<ModuleUpdateWithoutCourseInput, ModuleUncheckedUpdateWithoutCourseInput>
    create: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput>
  }

  export type ModuleUpdateWithWhereUniqueWithoutCourseInput = {
    where: ModuleWhereUniqueInput
    data: XOR<ModuleUpdateWithoutCourseInput, ModuleUncheckedUpdateWithoutCourseInput>
  }

  export type ModuleUpdateManyWithWhereWithoutCourseInput = {
    where: ModuleScalarWhereInput
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyWithoutCourseInput>
  }

  export type ModuleScalarWhereInput = {
    AND?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    OR?: ModuleScalarWhereInput[]
    NOT?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    id?: StringFilter<"Module"> | string
    courseId?: StringFilter<"Module"> | string
    title?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    orderIndex?: IntFilter<"Module"> | number
    isPublished?: BoolFilter<"Module"> | boolean
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutCourseInput, EnrollmentUncheckedUpdateWithoutCourseInput>
    create: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutCourseInput, EnrollmentUncheckedUpdateWithoutCourseInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutCourseInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutCourseInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutCourseInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCourseInput, PaymentUncheckedUpdateWithoutCourseInput>
    create: XOR<PaymentCreateWithoutCourseInput, PaymentUncheckedCreateWithoutCourseInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCourseInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCourseInput, PaymentUncheckedUpdateWithoutCourseInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCourseInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutCourseInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutCourseInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutCourseInput, ReviewUncheckedUpdateWithoutCourseInput>
    create: XOR<ReviewCreateWithoutCourseInput, ReviewUncheckedCreateWithoutCourseInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutCourseInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutCourseInput, ReviewUncheckedUpdateWithoutCourseInput>
  }

  export type ReviewUpdateManyWithWhereWithoutCourseInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutCourseInput>
  }

  export type LiveClassUpsertWithWhereUniqueWithoutCourseInput = {
    where: LiveClassWhereUniqueInput
    update: XOR<LiveClassUpdateWithoutCourseInput, LiveClassUncheckedUpdateWithoutCourseInput>
    create: XOR<LiveClassCreateWithoutCourseInput, LiveClassUncheckedCreateWithoutCourseInput>
  }

  export type LiveClassUpdateWithWhereUniqueWithoutCourseInput = {
    where: LiveClassWhereUniqueInput
    data: XOR<LiveClassUpdateWithoutCourseInput, LiveClassUncheckedUpdateWithoutCourseInput>
  }

  export type LiveClassUpdateManyWithWhereWithoutCourseInput = {
    where: LiveClassScalarWhereInput
    data: XOR<LiveClassUpdateManyMutationInput, LiveClassUncheckedUpdateManyWithoutCourseInput>
  }

  export type LiveClassScalarWhereInput = {
    AND?: LiveClassScalarWhereInput | LiveClassScalarWhereInput[]
    OR?: LiveClassScalarWhereInput[]
    NOT?: LiveClassScalarWhereInput | LiveClassScalarWhereInput[]
    id?: StringFilter<"LiveClass"> | string
    courseId?: StringFilter<"LiveClass"> | string
    title?: StringFilter<"LiveClass"> | string
    description?: StringNullableFilter<"LiveClass"> | string | null
    platform?: StringFilter<"LiveClass"> | string
    meetingLink?: StringNullableFilter<"LiveClass"> | string | null
    meetingId?: StringNullableFilter<"LiveClass"> | string | null
    password?: StringNullableFilter<"LiveClass"> | string | null
    scheduledAt?: DateTimeFilter<"LiveClass"> | Date | string
    duration?: IntFilter<"LiveClass"> | number
    timezone?: StringFilter<"LiveClass"> | string
    status?: EnumLiveClassStatusFilter<"LiveClass"> | $Enums.LiveClassStatus
    startedAt?: DateTimeNullableFilter<"LiveClass"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"LiveClass"> | Date | string | null
    recordingUrl?: StringNullableFilter<"LiveClass"> | string | null
    recordingPassword?: StringNullableFilter<"LiveClass"> | string | null
    hostId?: StringNullableFilter<"LiveClass"> | string | null
    hostName?: StringNullableFilter<"LiveClass"> | string | null
    createdAt?: DateTimeFilter<"LiveClass"> | Date | string
    updatedAt?: DateTimeFilter<"LiveClass"> | Date | string
  }

  export type BatchUpsertWithWhereUniqueWithoutCourseInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutCourseInput, BatchUncheckedUpdateWithoutCourseInput>
    create: XOR<BatchCreateWithoutCourseInput, BatchUncheckedCreateWithoutCourseInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutCourseInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutCourseInput, BatchUncheckedUpdateWithoutCourseInput>
  }

  export type BatchUpdateManyWithWhereWithoutCourseInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutCourseInput>
  }

  export type AnnouncementUpsertWithWhereUniqueWithoutCourseInput = {
    where: AnnouncementWhereUniqueInput
    update: XOR<AnnouncementUpdateWithoutCourseInput, AnnouncementUncheckedUpdateWithoutCourseInput>
    create: XOR<AnnouncementCreateWithoutCourseInput, AnnouncementUncheckedCreateWithoutCourseInput>
  }

  export type AnnouncementUpdateWithWhereUniqueWithoutCourseInput = {
    where: AnnouncementWhereUniqueInput
    data: XOR<AnnouncementUpdateWithoutCourseInput, AnnouncementUncheckedUpdateWithoutCourseInput>
  }

  export type AnnouncementUpdateManyWithWhereWithoutCourseInput = {
    where: AnnouncementScalarWhereInput
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseCreateWithoutBatchesInput = {
    id?: string
    title: string
    description: string
    thumbnail?: string | null
    category: string
    difficulty?: $Enums.Difficulty
    duration?: number
    price?: Decimal | DecimalJsLike | number | string
    discountPrice?: Decimal | DecimalJsLike | number | string
    courseCode?: string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: string | null
    averageRating?: number
    instructorId: string
    isPublished?: boolean
    hasInterviewPrep?: boolean
    interviewPrice?: Decimal | DecimalJsLike | number | string
    bundlePrice?: Decimal | DecimalJsLike | number | string
    courseType?: $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: $Enums.PublishStatus
    publishedAt?: Date | string | null
    reviewNotes?: string | null
    submittedForReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    payments?: PaymentCreateNestedManyWithoutCourseInput
    reviews?: ReviewCreateNestedManyWithoutCourseInput
    liveClasses?: LiveClassCreateNestedManyWithoutCourseInput
    announcements?: AnnouncementCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutBatchesInput = {
    id?: string
    title: string
    description: string
    thumbnail?: string | null
    category: string
    difficulty?: $Enums.Difficulty
    duration?: number
    price?: Decimal | DecimalJsLike | number | string
    discountPrice?: Decimal | DecimalJsLike | number | string
    courseCode?: string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: string | null
    averageRating?: number
    instructorId: string
    isPublished?: boolean
    hasInterviewPrep?: boolean
    interviewPrice?: Decimal | DecimalJsLike | number | string
    bundlePrice?: Decimal | DecimalJsLike | number | string
    courseType?: $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: $Enums.PublishStatus
    publishedAt?: Date | string | null
    reviewNotes?: string | null
    submittedForReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCourseInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCourseInput
    liveClasses?: LiveClassUncheckedCreateNestedManyWithoutCourseInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutBatchesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutBatchesInput, CourseUncheckedCreateWithoutBatchesInput>
  }

  export type UserCreateWithoutInstructedBatchesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutInstructedBatchesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutInstructedBatchesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInstructedBatchesInput, UserUncheckedCreateWithoutInstructedBatchesInput>
  }

  export type AnnouncementCreateWithoutBatchInput = {
    id?: string
    title: string
    content: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    course?: CourseCreateNestedOneWithoutAnnouncementsInput
    instructor: UserCreateNestedOneWithoutAnnouncementsInput
  }

  export type AnnouncementUncheckedCreateWithoutBatchInput = {
    id?: string
    title: string
    content: string
    priority?: string
    courseId?: string | null
    instructorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementCreateOrConnectWithoutBatchInput = {
    where: AnnouncementWhereUniqueInput
    create: XOR<AnnouncementCreateWithoutBatchInput, AnnouncementUncheckedCreateWithoutBatchInput>
  }

  export type AnnouncementCreateManyBatchInputEnvelope = {
    data: AnnouncementCreateManyBatchInput | AnnouncementCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentCreateWithoutBatchInput = {
    id?: string
    progress?: number
    status?: $Enums.EnrollmentStatus
    hasInterviewAccess?: boolean
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutEnrollmentsInput
    course: CourseCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateWithoutBatchInput = {
    id?: string
    userId: string
    courseId: string
    progress?: number
    status?: $Enums.EnrollmentStatus
    hasInterviewAccess?: boolean
    enrolledAt?: Date | string
    completedAt?: Date | string | null
  }

  export type EnrollmentCreateOrConnectWithoutBatchInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutBatchInput, EnrollmentUncheckedCreateWithoutBatchInput>
  }

  export type EnrollmentCreateManyBatchInputEnvelope = {
    data: EnrollmentCreateManyBatchInput | EnrollmentCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutBatchesInput = {
    update: XOR<CourseUpdateWithoutBatchesInput, CourseUncheckedUpdateWithoutBatchesInput>
    create: XOR<CourseCreateWithoutBatchesInput, CourseUncheckedCreateWithoutBatchesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutBatchesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutBatchesInput, CourseUncheckedUpdateWithoutBatchesInput>
  }

  export type CourseUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseCode?: NullableStringFieldUpdateOperationsInput | string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    instructorId?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    hasInterviewPrep?: BoolFieldUpdateOperationsInput | boolean
    interviewPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bundlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    payments?: PaymentUpdateManyWithoutCourseNestedInput
    reviews?: ReviewUpdateManyWithoutCourseNestedInput
    liveClasses?: LiveClassUpdateManyWithoutCourseNestedInput
    announcements?: AnnouncementUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseCode?: NullableStringFieldUpdateOperationsInput | string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    instructorId?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    hasInterviewPrep?: BoolFieldUpdateOperationsInput | boolean
    interviewPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bundlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCourseNestedInput
    liveClasses?: LiveClassUncheckedUpdateManyWithoutCourseNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserUpsertWithoutInstructedBatchesInput = {
    update: XOR<UserUpdateWithoutInstructedBatchesInput, UserUncheckedUpdateWithoutInstructedBatchesInput>
    create: XOR<UserCreateWithoutInstructedBatchesInput, UserUncheckedCreateWithoutInstructedBatchesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInstructedBatchesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInstructedBatchesInput, UserUncheckedUpdateWithoutInstructedBatchesInput>
  }

  export type UserUpdateWithoutInstructedBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutInstructedBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type AnnouncementUpsertWithWhereUniqueWithoutBatchInput = {
    where: AnnouncementWhereUniqueInput
    update: XOR<AnnouncementUpdateWithoutBatchInput, AnnouncementUncheckedUpdateWithoutBatchInput>
    create: XOR<AnnouncementCreateWithoutBatchInput, AnnouncementUncheckedCreateWithoutBatchInput>
  }

  export type AnnouncementUpdateWithWhereUniqueWithoutBatchInput = {
    where: AnnouncementWhereUniqueInput
    data: XOR<AnnouncementUpdateWithoutBatchInput, AnnouncementUncheckedUpdateWithoutBatchInput>
  }

  export type AnnouncementUpdateManyWithWhereWithoutBatchInput = {
    where: AnnouncementScalarWhereInput
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyWithoutBatchInput>
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutBatchInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutBatchInput, EnrollmentUncheckedUpdateWithoutBatchInput>
    create: XOR<EnrollmentCreateWithoutBatchInput, EnrollmentUncheckedCreateWithoutBatchInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutBatchInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutBatchInput, EnrollmentUncheckedUpdateWithoutBatchInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutBatchInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutBatchInput>
  }

  export type CourseCreateWithoutAnnouncementsInput = {
    id?: string
    title: string
    description: string
    thumbnail?: string | null
    category: string
    difficulty?: $Enums.Difficulty
    duration?: number
    price?: Decimal | DecimalJsLike | number | string
    discountPrice?: Decimal | DecimalJsLike | number | string
    courseCode?: string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: string | null
    averageRating?: number
    instructorId: string
    isPublished?: boolean
    hasInterviewPrep?: boolean
    interviewPrice?: Decimal | DecimalJsLike | number | string
    bundlePrice?: Decimal | DecimalJsLike | number | string
    courseType?: $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: $Enums.PublishStatus
    publishedAt?: Date | string | null
    reviewNotes?: string | null
    submittedForReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    payments?: PaymentCreateNestedManyWithoutCourseInput
    reviews?: ReviewCreateNestedManyWithoutCourseInput
    liveClasses?: LiveClassCreateNestedManyWithoutCourseInput
    batches?: BatchCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutAnnouncementsInput = {
    id?: string
    title: string
    description: string
    thumbnail?: string | null
    category: string
    difficulty?: $Enums.Difficulty
    duration?: number
    price?: Decimal | DecimalJsLike | number | string
    discountPrice?: Decimal | DecimalJsLike | number | string
    courseCode?: string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: string | null
    averageRating?: number
    instructorId: string
    isPublished?: boolean
    hasInterviewPrep?: boolean
    interviewPrice?: Decimal | DecimalJsLike | number | string
    bundlePrice?: Decimal | DecimalJsLike | number | string
    courseType?: $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: $Enums.PublishStatus
    publishedAt?: Date | string | null
    reviewNotes?: string | null
    submittedForReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCourseInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCourseInput
    liveClasses?: LiveClassUncheckedCreateNestedManyWithoutCourseInput
    batches?: BatchUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutAnnouncementsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutAnnouncementsInput, CourseUncheckedCreateWithoutAnnouncementsInput>
  }

  export type BatchCreateWithoutAnnouncementsInput = {
    id?: string
    name: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    description?: string | null
    maxStudents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutBatchesInput
    instructor: UserCreateNestedOneWithoutInstructedBatchesInput
    enrollments?: EnrollmentCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutAnnouncementsInput = {
    id?: string
    name: string
    courseId: string
    instructorId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    description?: string | null
    maxStudents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutAnnouncementsInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutAnnouncementsInput, BatchUncheckedCreateWithoutAnnouncementsInput>
  }

  export type UserCreateWithoutAnnouncementsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutAnnouncementsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutAnnouncementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnnouncementsInput, UserUncheckedCreateWithoutAnnouncementsInput>
  }

  export type CourseUpsertWithoutAnnouncementsInput = {
    update: XOR<CourseUpdateWithoutAnnouncementsInput, CourseUncheckedUpdateWithoutAnnouncementsInput>
    create: XOR<CourseCreateWithoutAnnouncementsInput, CourseUncheckedCreateWithoutAnnouncementsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutAnnouncementsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutAnnouncementsInput, CourseUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type CourseUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseCode?: NullableStringFieldUpdateOperationsInput | string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    instructorId?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    hasInterviewPrep?: BoolFieldUpdateOperationsInput | boolean
    interviewPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bundlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    payments?: PaymentUpdateManyWithoutCourseNestedInput
    reviews?: ReviewUpdateManyWithoutCourseNestedInput
    liveClasses?: LiveClassUpdateManyWithoutCourseNestedInput
    batches?: BatchUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseCode?: NullableStringFieldUpdateOperationsInput | string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    instructorId?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    hasInterviewPrep?: BoolFieldUpdateOperationsInput | boolean
    interviewPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bundlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCourseNestedInput
    liveClasses?: LiveClassUncheckedUpdateManyWithoutCourseNestedInput
    batches?: BatchUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type BatchUpsertWithoutAnnouncementsInput = {
    update: XOR<BatchUpdateWithoutAnnouncementsInput, BatchUncheckedUpdateWithoutAnnouncementsInput>
    create: XOR<BatchCreateWithoutAnnouncementsInput, BatchUncheckedCreateWithoutAnnouncementsInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutAnnouncementsInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutAnnouncementsInput, BatchUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type BatchUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutBatchesNestedInput
    instructor?: UserUpdateOneRequiredWithoutInstructedBatchesNestedInput
    enrollments?: EnrollmentUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type UserUpsertWithoutAnnouncementsInput = {
    update: XOR<UserUpdateWithoutAnnouncementsInput, UserUncheckedUpdateWithoutAnnouncementsInput>
    create: XOR<UserCreateWithoutAnnouncementsInput, UserUncheckedCreateWithoutAnnouncementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnnouncementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnnouncementsInput, UserUncheckedUpdateWithoutAnnouncementsInput>
  }

  export type UserUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type LessonCreateWithoutCommentsInput = {
    id?: string
    title: string
    content?: string | null
    videoUrl?: string | null
    duration?: number | null
    order: number
    type?: $Enums.LessonType
    isPublished?: boolean
    isPreview?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    module: ModuleCreateNestedOneWithoutLessonsInput
    quizzes?: QuizCreateNestedManyWithoutLessonInput
    progress?: LessonProgressCreateNestedManyWithoutLessonInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutCommentsInput = {
    id?: string
    moduleId: string
    title: string
    content?: string | null
    videoUrl?: string | null
    duration?: number | null
    order: number
    type?: $Enums.LessonType
    isPublished?: boolean
    isPreview?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    quizzes?: QuizUncheckedCreateNestedManyWithoutLessonInput
    progress?: LessonProgressUncheckedCreateNestedManyWithoutLessonInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutCommentsInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutCommentsInput, LessonUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutLessonCommentsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutLessonCommentsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutLessonCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLessonCommentsInput, UserUncheckedCreateWithoutLessonCommentsInput>
  }

  export type LessonCommentCreateWithoutRepliesInput = {
    id?: string
    content: string
    isPinned?: boolean
    isInstructorResponse?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lesson: LessonCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutLessonCommentsInput
    parent?: LessonCommentCreateNestedOneWithoutRepliesInput
  }

  export type LessonCommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    lessonId: string
    userId: string
    content: string
    parentId?: string | null
    isPinned?: boolean
    isInstructorResponse?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonCommentCreateOrConnectWithoutRepliesInput = {
    where: LessonCommentWhereUniqueInput
    create: XOR<LessonCommentCreateWithoutRepliesInput, LessonCommentUncheckedCreateWithoutRepliesInput>
  }

  export type LessonCommentCreateWithoutParentInput = {
    id?: string
    content: string
    isPinned?: boolean
    isInstructorResponse?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lesson: LessonCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutLessonCommentsInput
    replies?: LessonCommentCreateNestedManyWithoutParentInput
  }

  export type LessonCommentUncheckedCreateWithoutParentInput = {
    id?: string
    lessonId: string
    userId: string
    content: string
    isPinned?: boolean
    isInstructorResponse?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: LessonCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type LessonCommentCreateOrConnectWithoutParentInput = {
    where: LessonCommentWhereUniqueInput
    create: XOR<LessonCommentCreateWithoutParentInput, LessonCommentUncheckedCreateWithoutParentInput>
  }

  export type LessonCommentCreateManyParentInputEnvelope = {
    data: LessonCommentCreateManyParentInput | LessonCommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type LessonUpsertWithoutCommentsInput = {
    update: XOR<LessonUpdateWithoutCommentsInput, LessonUncheckedUpdateWithoutCommentsInput>
    create: XOR<LessonCreateWithoutCommentsInput, LessonUncheckedCreateWithoutCommentsInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutCommentsInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutCommentsInput, LessonUncheckedUpdateWithoutCommentsInput>
  }

  export type LessonUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneRequiredWithoutLessonsNestedInput
    quizzes?: QuizUpdateManyWithoutLessonNestedInput
    progress?: LessonProgressUpdateManyWithoutLessonNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizzes?: QuizUncheckedUpdateManyWithoutLessonNestedInput
    progress?: LessonProgressUncheckedUpdateManyWithoutLessonNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type UserUpsertWithoutLessonCommentsInput = {
    update: XOR<UserUpdateWithoutLessonCommentsInput, UserUncheckedUpdateWithoutLessonCommentsInput>
    create: XOR<UserCreateWithoutLessonCommentsInput, UserUncheckedCreateWithoutLessonCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLessonCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLessonCommentsInput, UserUncheckedUpdateWithoutLessonCommentsInput>
  }

  export type UserUpdateWithoutLessonCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutLessonCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type LessonCommentUpsertWithoutRepliesInput = {
    update: XOR<LessonCommentUpdateWithoutRepliesInput, LessonCommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<LessonCommentCreateWithoutRepliesInput, LessonCommentUncheckedCreateWithoutRepliesInput>
    where?: LessonCommentWhereInput
  }

  export type LessonCommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: LessonCommentWhereInput
    data: XOR<LessonCommentUpdateWithoutRepliesInput, LessonCommentUncheckedUpdateWithoutRepliesInput>
  }

  export type LessonCommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isInstructorResponse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutLessonCommentsNestedInput
    parent?: LessonCommentUpdateOneWithoutRepliesNestedInput
  }

  export type LessonCommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isInstructorResponse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCommentUpsertWithWhereUniqueWithoutParentInput = {
    where: LessonCommentWhereUniqueInput
    update: XOR<LessonCommentUpdateWithoutParentInput, LessonCommentUncheckedUpdateWithoutParentInput>
    create: XOR<LessonCommentCreateWithoutParentInput, LessonCommentUncheckedCreateWithoutParentInput>
  }

  export type LessonCommentUpdateWithWhereUniqueWithoutParentInput = {
    where: LessonCommentWhereUniqueInput
    data: XOR<LessonCommentUpdateWithoutParentInput, LessonCommentUncheckedUpdateWithoutParentInput>
  }

  export type LessonCommentUpdateManyWithWhereWithoutParentInput = {
    where: LessonCommentScalarWhereInput
    data: XOR<LessonCommentUpdateManyMutationInput, LessonCommentUncheckedUpdateManyWithoutParentInput>
  }

  export type CourseCreateWithoutModulesInput = {
    id?: string
    title: string
    description: string
    thumbnail?: string | null
    category: string
    difficulty?: $Enums.Difficulty
    duration?: number
    price?: Decimal | DecimalJsLike | number | string
    discountPrice?: Decimal | DecimalJsLike | number | string
    courseCode?: string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: string | null
    averageRating?: number
    instructorId: string
    isPublished?: boolean
    hasInterviewPrep?: boolean
    interviewPrice?: Decimal | DecimalJsLike | number | string
    bundlePrice?: Decimal | DecimalJsLike | number | string
    courseType?: $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: $Enums.PublishStatus
    publishedAt?: Date | string | null
    reviewNotes?: string | null
    submittedForReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    payments?: PaymentCreateNestedManyWithoutCourseInput
    reviews?: ReviewCreateNestedManyWithoutCourseInput
    liveClasses?: LiveClassCreateNestedManyWithoutCourseInput
    batches?: BatchCreateNestedManyWithoutCourseInput
    announcements?: AnnouncementCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutModulesInput = {
    id?: string
    title: string
    description: string
    thumbnail?: string | null
    category: string
    difficulty?: $Enums.Difficulty
    duration?: number
    price?: Decimal | DecimalJsLike | number | string
    discountPrice?: Decimal | DecimalJsLike | number | string
    courseCode?: string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: string | null
    averageRating?: number
    instructorId: string
    isPublished?: boolean
    hasInterviewPrep?: boolean
    interviewPrice?: Decimal | DecimalJsLike | number | string
    bundlePrice?: Decimal | DecimalJsLike | number | string
    courseType?: $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: $Enums.PublishStatus
    publishedAt?: Date | string | null
    reviewNotes?: string | null
    submittedForReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCourseInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCourseInput
    liveClasses?: LiveClassUncheckedCreateNestedManyWithoutCourseInput
    batches?: BatchUncheckedCreateNestedManyWithoutCourseInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutModulesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
  }

  export type LessonCreateWithoutModuleInput = {
    id?: string
    title: string
    content?: string | null
    videoUrl?: string | null
    duration?: number | null
    order: number
    type?: $Enums.LessonType
    isPublished?: boolean
    isPreview?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    quizzes?: QuizCreateNestedManyWithoutLessonInput
    progress?: LessonProgressCreateNestedManyWithoutLessonInput
    comments?: LessonCommentCreateNestedManyWithoutLessonInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutModuleInput = {
    id?: string
    title: string
    content?: string | null
    videoUrl?: string | null
    duration?: number | null
    order: number
    type?: $Enums.LessonType
    isPublished?: boolean
    isPreview?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    quizzes?: QuizUncheckedCreateNestedManyWithoutLessonInput
    progress?: LessonProgressUncheckedCreateNestedManyWithoutLessonInput
    comments?: LessonCommentUncheckedCreateNestedManyWithoutLessonInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutModuleInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput>
  }

  export type LessonCreateManyModuleInputEnvelope = {
    data: LessonCreateManyModuleInput | LessonCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutModulesInput = {
    update: XOR<CourseUpdateWithoutModulesInput, CourseUncheckedUpdateWithoutModulesInput>
    create: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutModulesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutModulesInput, CourseUncheckedUpdateWithoutModulesInput>
  }

  export type CourseUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseCode?: NullableStringFieldUpdateOperationsInput | string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    instructorId?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    hasInterviewPrep?: BoolFieldUpdateOperationsInput | boolean
    interviewPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bundlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    payments?: PaymentUpdateManyWithoutCourseNestedInput
    reviews?: ReviewUpdateManyWithoutCourseNestedInput
    liveClasses?: LiveClassUpdateManyWithoutCourseNestedInput
    batches?: BatchUpdateManyWithoutCourseNestedInput
    announcements?: AnnouncementUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseCode?: NullableStringFieldUpdateOperationsInput | string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    instructorId?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    hasInterviewPrep?: BoolFieldUpdateOperationsInput | boolean
    interviewPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bundlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCourseNestedInput
    liveClasses?: LiveClassUncheckedUpdateManyWithoutCourseNestedInput
    batches?: BatchUncheckedUpdateManyWithoutCourseNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type LessonUpsertWithWhereUniqueWithoutModuleInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutModuleInput, LessonUncheckedUpdateWithoutModuleInput>
    create: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutModuleInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutModuleInput, LessonUncheckedUpdateWithoutModuleInput>
  }

  export type LessonUpdateManyWithWhereWithoutModuleInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutModuleInput>
  }

  export type LessonScalarWhereInput = {
    AND?: LessonScalarWhereInput | LessonScalarWhereInput[]
    OR?: LessonScalarWhereInput[]
    NOT?: LessonScalarWhereInput | LessonScalarWhereInput[]
    id?: StringFilter<"Lesson"> | string
    moduleId?: StringFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    content?: StringNullableFilter<"Lesson"> | string | null
    videoUrl?: StringNullableFilter<"Lesson"> | string | null
    duration?: IntNullableFilter<"Lesson"> | number | null
    order?: IntFilter<"Lesson"> | number
    type?: EnumLessonTypeFilter<"Lesson"> | $Enums.LessonType
    isPublished?: BoolFilter<"Lesson"> | boolean
    isPreview?: BoolFilter<"Lesson"> | boolean
    settings?: JsonNullableFilter<"Lesson">
    resources?: JsonNullableFilter<"Lesson">
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
  }

  export type ModuleCreateWithoutLessonsInput = {
    id?: string
    title: string
    description?: string | null
    orderIndex: number
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutModulesInput
  }

  export type ModuleUncheckedCreateWithoutLessonsInput = {
    id?: string
    courseId: string
    title: string
    description?: string | null
    orderIndex: number
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleCreateOrConnectWithoutLessonsInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutLessonsInput, ModuleUncheckedCreateWithoutLessonsInput>
  }

  export type QuizCreateWithoutLessonInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    correctAnswer: string
    explanation?: string | null
    createdAt?: Date | string
  }

  export type QuizUncheckedCreateWithoutLessonInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    correctAnswer: string
    explanation?: string | null
    createdAt?: Date | string
  }

  export type QuizCreateOrConnectWithoutLessonInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput>
  }

  export type QuizCreateManyLessonInputEnvelope = {
    data: QuizCreateManyLessonInput | QuizCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type LessonProgressCreateWithoutLessonInput = {
    id?: string
    completed?: boolean
    score?: number | null
    timeSpent?: number
    lastAccessedAt?: Date | string
    user: UserCreateNestedOneWithoutLessonProgressInput
  }

  export type LessonProgressUncheckedCreateWithoutLessonInput = {
    id?: string
    userId: string
    completed?: boolean
    score?: number | null
    timeSpent?: number
    lastAccessedAt?: Date | string
  }

  export type LessonProgressCreateOrConnectWithoutLessonInput = {
    where: LessonProgressWhereUniqueInput
    create: XOR<LessonProgressCreateWithoutLessonInput, LessonProgressUncheckedCreateWithoutLessonInput>
  }

  export type LessonProgressCreateManyLessonInputEnvelope = {
    data: LessonProgressCreateManyLessonInput | LessonProgressCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type LessonCommentCreateWithoutLessonInput = {
    id?: string
    content: string
    isPinned?: boolean
    isInstructorResponse?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLessonCommentsInput
    parent?: LessonCommentCreateNestedOneWithoutRepliesInput
    replies?: LessonCommentCreateNestedManyWithoutParentInput
  }

  export type LessonCommentUncheckedCreateWithoutLessonInput = {
    id?: string
    userId: string
    content: string
    parentId?: string | null
    isPinned?: boolean
    isInstructorResponse?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: LessonCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type LessonCommentCreateOrConnectWithoutLessonInput = {
    where: LessonCommentWhereUniqueInput
    create: XOR<LessonCommentCreateWithoutLessonInput, LessonCommentUncheckedCreateWithoutLessonInput>
  }

  export type LessonCommentCreateManyLessonInputEnvelope = {
    data: LessonCommentCreateManyLessonInput | LessonCommentCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentSubmissionCreateWithoutLessonInput = {
    id?: string
    content?: string | null
    fileUrl?: string | null
    grade?: number | null
    feedback?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAssignmentSubmissionsInput
  }

  export type AssignmentSubmissionUncheckedCreateWithoutLessonInput = {
    id?: string
    userId: string
    content?: string | null
    fileUrl?: string | null
    grade?: number | null
    feedback?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentSubmissionCreateOrConnectWithoutLessonInput = {
    where: AssignmentSubmissionWhereUniqueInput
    create: XOR<AssignmentSubmissionCreateWithoutLessonInput, AssignmentSubmissionUncheckedCreateWithoutLessonInput>
  }

  export type AssignmentSubmissionCreateManyLessonInputEnvelope = {
    data: AssignmentSubmissionCreateManyLessonInput | AssignmentSubmissionCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type ModuleUpsertWithoutLessonsInput = {
    update: XOR<ModuleUpdateWithoutLessonsInput, ModuleUncheckedUpdateWithoutLessonsInput>
    create: XOR<ModuleCreateWithoutLessonsInput, ModuleUncheckedCreateWithoutLessonsInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutLessonsInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutLessonsInput, ModuleUncheckedUpdateWithoutLessonsInput>
  }

  export type ModuleUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUpsertWithWhereUniqueWithoutLessonInput = {
    where: QuizWhereUniqueInput
    update: XOR<QuizUpdateWithoutLessonInput, QuizUncheckedUpdateWithoutLessonInput>
    create: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput>
  }

  export type QuizUpdateWithWhereUniqueWithoutLessonInput = {
    where: QuizWhereUniqueInput
    data: XOR<QuizUpdateWithoutLessonInput, QuizUncheckedUpdateWithoutLessonInput>
  }

  export type QuizUpdateManyWithWhereWithoutLessonInput = {
    where: QuizScalarWhereInput
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyWithoutLessonInput>
  }

  export type QuizScalarWhereInput = {
    AND?: QuizScalarWhereInput | QuizScalarWhereInput[]
    OR?: QuizScalarWhereInput[]
    NOT?: QuizScalarWhereInput | QuizScalarWhereInput[]
    id?: StringFilter<"Quiz"> | string
    lessonId?: StringFilter<"Quiz"> | string
    question?: StringFilter<"Quiz"> | string
    options?: JsonFilter<"Quiz">
    correctAnswer?: StringFilter<"Quiz"> | string
    explanation?: StringNullableFilter<"Quiz"> | string | null
    createdAt?: DateTimeFilter<"Quiz"> | Date | string
  }

  export type LessonProgressUpsertWithWhereUniqueWithoutLessonInput = {
    where: LessonProgressWhereUniqueInput
    update: XOR<LessonProgressUpdateWithoutLessonInput, LessonProgressUncheckedUpdateWithoutLessonInput>
    create: XOR<LessonProgressCreateWithoutLessonInput, LessonProgressUncheckedCreateWithoutLessonInput>
  }

  export type LessonProgressUpdateWithWhereUniqueWithoutLessonInput = {
    where: LessonProgressWhereUniqueInput
    data: XOR<LessonProgressUpdateWithoutLessonInput, LessonProgressUncheckedUpdateWithoutLessonInput>
  }

  export type LessonProgressUpdateManyWithWhereWithoutLessonInput = {
    where: LessonProgressScalarWhereInput
    data: XOR<LessonProgressUpdateManyMutationInput, LessonProgressUncheckedUpdateManyWithoutLessonInput>
  }

  export type LessonCommentUpsertWithWhereUniqueWithoutLessonInput = {
    where: LessonCommentWhereUniqueInput
    update: XOR<LessonCommentUpdateWithoutLessonInput, LessonCommentUncheckedUpdateWithoutLessonInput>
    create: XOR<LessonCommentCreateWithoutLessonInput, LessonCommentUncheckedCreateWithoutLessonInput>
  }

  export type LessonCommentUpdateWithWhereUniqueWithoutLessonInput = {
    where: LessonCommentWhereUniqueInput
    data: XOR<LessonCommentUpdateWithoutLessonInput, LessonCommentUncheckedUpdateWithoutLessonInput>
  }

  export type LessonCommentUpdateManyWithWhereWithoutLessonInput = {
    where: LessonCommentScalarWhereInput
    data: XOR<LessonCommentUpdateManyMutationInput, LessonCommentUncheckedUpdateManyWithoutLessonInput>
  }

  export type AssignmentSubmissionUpsertWithWhereUniqueWithoutLessonInput = {
    where: AssignmentSubmissionWhereUniqueInput
    update: XOR<AssignmentSubmissionUpdateWithoutLessonInput, AssignmentSubmissionUncheckedUpdateWithoutLessonInput>
    create: XOR<AssignmentSubmissionCreateWithoutLessonInput, AssignmentSubmissionUncheckedCreateWithoutLessonInput>
  }

  export type AssignmentSubmissionUpdateWithWhereUniqueWithoutLessonInput = {
    where: AssignmentSubmissionWhereUniqueInput
    data: XOR<AssignmentSubmissionUpdateWithoutLessonInput, AssignmentSubmissionUncheckedUpdateWithoutLessonInput>
  }

  export type AssignmentSubmissionUpdateManyWithWhereWithoutLessonInput = {
    where: AssignmentSubmissionScalarWhereInput
    data: XOR<AssignmentSubmissionUpdateManyMutationInput, AssignmentSubmissionUncheckedUpdateManyWithoutLessonInput>
  }

  export type LessonCreateWithoutQuizzesInput = {
    id?: string
    title: string
    content?: string | null
    videoUrl?: string | null
    duration?: number | null
    order: number
    type?: $Enums.LessonType
    isPublished?: boolean
    isPreview?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    module: ModuleCreateNestedOneWithoutLessonsInput
    progress?: LessonProgressCreateNestedManyWithoutLessonInput
    comments?: LessonCommentCreateNestedManyWithoutLessonInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutQuizzesInput = {
    id?: string
    moduleId: string
    title: string
    content?: string | null
    videoUrl?: string | null
    duration?: number | null
    order: number
    type?: $Enums.LessonType
    isPublished?: boolean
    isPreview?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: LessonProgressUncheckedCreateNestedManyWithoutLessonInput
    comments?: LessonCommentUncheckedCreateNestedManyWithoutLessonInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutQuizzesInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutQuizzesInput, LessonUncheckedCreateWithoutQuizzesInput>
  }

  export type LessonUpsertWithoutQuizzesInput = {
    update: XOR<LessonUpdateWithoutQuizzesInput, LessonUncheckedUpdateWithoutQuizzesInput>
    create: XOR<LessonCreateWithoutQuizzesInput, LessonUncheckedCreateWithoutQuizzesInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutQuizzesInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutQuizzesInput, LessonUncheckedUpdateWithoutQuizzesInput>
  }

  export type LessonUpdateWithoutQuizzesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneRequiredWithoutLessonsNestedInput
    progress?: LessonProgressUpdateManyWithoutLessonNestedInput
    comments?: LessonCommentUpdateManyWithoutLessonNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutQuizzesInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: LessonProgressUncheckedUpdateManyWithoutLessonNestedInput
    comments?: LessonCommentUncheckedUpdateManyWithoutLessonNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonCreateWithoutAssignmentSubmissionsInput = {
    id?: string
    title: string
    content?: string | null
    videoUrl?: string | null
    duration?: number | null
    order: number
    type?: $Enums.LessonType
    isPublished?: boolean
    isPreview?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    module: ModuleCreateNestedOneWithoutLessonsInput
    quizzes?: QuizCreateNestedManyWithoutLessonInput
    progress?: LessonProgressCreateNestedManyWithoutLessonInput
    comments?: LessonCommentCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutAssignmentSubmissionsInput = {
    id?: string
    moduleId: string
    title: string
    content?: string | null
    videoUrl?: string | null
    duration?: number | null
    order: number
    type?: $Enums.LessonType
    isPublished?: boolean
    isPreview?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    quizzes?: QuizUncheckedCreateNestedManyWithoutLessonInput
    progress?: LessonProgressUncheckedCreateNestedManyWithoutLessonInput
    comments?: LessonCommentUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutAssignmentSubmissionsInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutAssignmentSubmissionsInput, LessonUncheckedCreateWithoutAssignmentSubmissionsInput>
  }

  export type UserCreateWithoutAssignmentSubmissionsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutAssignmentSubmissionsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutAssignmentSubmissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignmentSubmissionsInput, UserUncheckedCreateWithoutAssignmentSubmissionsInput>
  }

  export type LessonUpsertWithoutAssignmentSubmissionsInput = {
    update: XOR<LessonUpdateWithoutAssignmentSubmissionsInput, LessonUncheckedUpdateWithoutAssignmentSubmissionsInput>
    create: XOR<LessonCreateWithoutAssignmentSubmissionsInput, LessonUncheckedCreateWithoutAssignmentSubmissionsInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutAssignmentSubmissionsInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutAssignmentSubmissionsInput, LessonUncheckedUpdateWithoutAssignmentSubmissionsInput>
  }

  export type LessonUpdateWithoutAssignmentSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneRequiredWithoutLessonsNestedInput
    quizzes?: QuizUpdateManyWithoutLessonNestedInput
    progress?: LessonProgressUpdateManyWithoutLessonNestedInput
    comments?: LessonCommentUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutAssignmentSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizzes?: QuizUncheckedUpdateManyWithoutLessonNestedInput
    progress?: LessonProgressUncheckedUpdateManyWithoutLessonNestedInput
    comments?: LessonCommentUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type UserUpsertWithoutAssignmentSubmissionsInput = {
    update: XOR<UserUpdateWithoutAssignmentSubmissionsInput, UserUncheckedUpdateWithoutAssignmentSubmissionsInput>
    create: XOR<UserCreateWithoutAssignmentSubmissionsInput, UserUncheckedCreateWithoutAssignmentSubmissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignmentSubmissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignmentSubmissionsInput, UserUncheckedUpdateWithoutAssignmentSubmissionsInput>
  }

  export type UserUpdateWithoutAssignmentSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignmentSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type UserCreateWithoutEnrollmentsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutEnrollmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
  }

  export type CourseCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    description: string
    thumbnail?: string | null
    category: string
    difficulty?: $Enums.Difficulty
    duration?: number
    price?: Decimal | DecimalJsLike | number | string
    discountPrice?: Decimal | DecimalJsLike | number | string
    courseCode?: string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: string | null
    averageRating?: number
    instructorId: string
    isPublished?: boolean
    hasInterviewPrep?: boolean
    interviewPrice?: Decimal | DecimalJsLike | number | string
    bundlePrice?: Decimal | DecimalJsLike | number | string
    courseType?: $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: $Enums.PublishStatus
    publishedAt?: Date | string | null
    reviewNotes?: string | null
    submittedForReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleCreateNestedManyWithoutCourseInput
    payments?: PaymentCreateNestedManyWithoutCourseInput
    reviews?: ReviewCreateNestedManyWithoutCourseInput
    liveClasses?: LiveClassCreateNestedManyWithoutCourseInput
    batches?: BatchCreateNestedManyWithoutCourseInput
    announcements?: AnnouncementCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    description: string
    thumbnail?: string | null
    category: string
    difficulty?: $Enums.Difficulty
    duration?: number
    price?: Decimal | DecimalJsLike | number | string
    discountPrice?: Decimal | DecimalJsLike | number | string
    courseCode?: string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: string | null
    averageRating?: number
    instructorId: string
    isPublished?: boolean
    hasInterviewPrep?: boolean
    interviewPrice?: Decimal | DecimalJsLike | number | string
    bundlePrice?: Decimal | DecimalJsLike | number | string
    courseType?: $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: $Enums.PublishStatus
    publishedAt?: Date | string | null
    reviewNotes?: string | null
    submittedForReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCourseInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCourseInput
    liveClasses?: LiveClassUncheckedCreateNestedManyWithoutCourseInput
    batches?: BatchUncheckedCreateNestedManyWithoutCourseInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutEnrollmentsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
  }

  export type BatchCreateWithoutEnrollmentsInput = {
    id?: string
    name: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    description?: string | null
    maxStudents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutBatchesInput
    instructor: UserCreateNestedOneWithoutInstructedBatchesInput
    announcements?: AnnouncementCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    name: string
    courseId: string
    instructorId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    description?: string | null
    maxStudents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutEnrollmentsInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutEnrollmentsInput, BatchUncheckedCreateWithoutEnrollmentsInput>
  }

  export type UserUpsertWithoutEnrollmentsInput = {
    update: XOR<UserUpdateWithoutEnrollmentsInput, UserUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEnrollmentsInput, UserUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type UserUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type CourseUpsertWithoutEnrollmentsInput = {
    update: XOR<CourseUpdateWithoutEnrollmentsInput, CourseUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutEnrollmentsInput, CourseUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseCode?: NullableStringFieldUpdateOperationsInput | string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    instructorId?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    hasInterviewPrep?: BoolFieldUpdateOperationsInput | boolean
    interviewPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bundlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    payments?: PaymentUpdateManyWithoutCourseNestedInput
    reviews?: ReviewUpdateManyWithoutCourseNestedInput
    liveClasses?: LiveClassUpdateManyWithoutCourseNestedInput
    batches?: BatchUpdateManyWithoutCourseNestedInput
    announcements?: AnnouncementUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseCode?: NullableStringFieldUpdateOperationsInput | string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    instructorId?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    hasInterviewPrep?: BoolFieldUpdateOperationsInput | boolean
    interviewPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bundlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCourseNestedInput
    liveClasses?: LiveClassUncheckedUpdateManyWithoutCourseNestedInput
    batches?: BatchUncheckedUpdateManyWithoutCourseNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type BatchUpsertWithoutEnrollmentsInput = {
    update: XOR<BatchUpdateWithoutEnrollmentsInput, BatchUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<BatchCreateWithoutEnrollmentsInput, BatchUncheckedCreateWithoutEnrollmentsInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutEnrollmentsInput, BatchUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type BatchUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutBatchesNestedInput
    instructor?: UserUpdateOneRequiredWithoutInstructedBatchesNestedInput
    announcements?: AnnouncementUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    announcements?: AnnouncementUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type UserCreateWithoutLessonProgressInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutLessonProgressInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutLessonProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLessonProgressInput, UserUncheckedCreateWithoutLessonProgressInput>
  }

  export type LessonCreateWithoutProgressInput = {
    id?: string
    title: string
    content?: string | null
    videoUrl?: string | null
    duration?: number | null
    order: number
    type?: $Enums.LessonType
    isPublished?: boolean
    isPreview?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    module: ModuleCreateNestedOneWithoutLessonsInput
    quizzes?: QuizCreateNestedManyWithoutLessonInput
    comments?: LessonCommentCreateNestedManyWithoutLessonInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutProgressInput = {
    id?: string
    moduleId: string
    title: string
    content?: string | null
    videoUrl?: string | null
    duration?: number | null
    order: number
    type?: $Enums.LessonType
    isPublished?: boolean
    isPreview?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    quizzes?: QuizUncheckedCreateNestedManyWithoutLessonInput
    comments?: LessonCommentUncheckedCreateNestedManyWithoutLessonInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutProgressInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutProgressInput, LessonUncheckedCreateWithoutProgressInput>
  }

  export type UserUpsertWithoutLessonProgressInput = {
    update: XOR<UserUpdateWithoutLessonProgressInput, UserUncheckedUpdateWithoutLessonProgressInput>
    create: XOR<UserCreateWithoutLessonProgressInput, UserUncheckedCreateWithoutLessonProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLessonProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLessonProgressInput, UserUncheckedUpdateWithoutLessonProgressInput>
  }

  export type UserUpdateWithoutLessonProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutLessonProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type LessonUpsertWithoutProgressInput = {
    update: XOR<LessonUpdateWithoutProgressInput, LessonUncheckedUpdateWithoutProgressInput>
    create: XOR<LessonCreateWithoutProgressInput, LessonUncheckedCreateWithoutProgressInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutProgressInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutProgressInput, LessonUncheckedUpdateWithoutProgressInput>
  }

  export type LessonUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneRequiredWithoutLessonsNestedInput
    quizzes?: QuizUpdateManyWithoutLessonNestedInput
    comments?: LessonCommentUpdateManyWithoutLessonNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizzes?: QuizUncheckedUpdateManyWithoutLessonNestedInput
    comments?: LessonCommentUncheckedUpdateManyWithoutLessonNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type CourseCreateWithoutReviewsInput = {
    id?: string
    title: string
    description: string
    thumbnail?: string | null
    category: string
    difficulty?: $Enums.Difficulty
    duration?: number
    price?: Decimal | DecimalJsLike | number | string
    discountPrice?: Decimal | DecimalJsLike | number | string
    courseCode?: string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: string | null
    averageRating?: number
    instructorId: string
    isPublished?: boolean
    hasInterviewPrep?: boolean
    interviewPrice?: Decimal | DecimalJsLike | number | string
    bundlePrice?: Decimal | DecimalJsLike | number | string
    courseType?: $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: $Enums.PublishStatus
    publishedAt?: Date | string | null
    reviewNotes?: string | null
    submittedForReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    payments?: PaymentCreateNestedManyWithoutCourseInput
    liveClasses?: LiveClassCreateNestedManyWithoutCourseInput
    batches?: BatchCreateNestedManyWithoutCourseInput
    announcements?: AnnouncementCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutReviewsInput = {
    id?: string
    title: string
    description: string
    thumbnail?: string | null
    category: string
    difficulty?: $Enums.Difficulty
    duration?: number
    price?: Decimal | DecimalJsLike | number | string
    discountPrice?: Decimal | DecimalJsLike | number | string
    courseCode?: string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: string | null
    averageRating?: number
    instructorId: string
    isPublished?: boolean
    hasInterviewPrep?: boolean
    interviewPrice?: Decimal | DecimalJsLike | number | string
    bundlePrice?: Decimal | DecimalJsLike | number | string
    courseType?: $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: $Enums.PublishStatus
    publishedAt?: Date | string | null
    reviewNotes?: string | null
    submittedForReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCourseInput
    liveClasses?: LiveClassUncheckedCreateNestedManyWithoutCourseInput
    batches?: BatchUncheckedCreateNestedManyWithoutCourseInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutReviewsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutReviewsInput, CourseUncheckedCreateWithoutReviewsInput>
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type CourseUpsertWithoutReviewsInput = {
    update: XOR<CourseUpdateWithoutReviewsInput, CourseUncheckedUpdateWithoutReviewsInput>
    create: XOR<CourseCreateWithoutReviewsInput, CourseUncheckedCreateWithoutReviewsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutReviewsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutReviewsInput, CourseUncheckedUpdateWithoutReviewsInput>
  }

  export type CourseUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseCode?: NullableStringFieldUpdateOperationsInput | string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    instructorId?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    hasInterviewPrep?: BoolFieldUpdateOperationsInput | boolean
    interviewPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bundlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    payments?: PaymentUpdateManyWithoutCourseNestedInput
    liveClasses?: LiveClassUpdateManyWithoutCourseNestedInput
    batches?: BatchUpdateManyWithoutCourseNestedInput
    announcements?: AnnouncementUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseCode?: NullableStringFieldUpdateOperationsInput | string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    instructorId?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    hasInterviewPrep?: BoolFieldUpdateOperationsInput | boolean
    interviewPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bundlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCourseNestedInput
    liveClasses?: LiveClassUncheckedUpdateManyWithoutCourseNestedInput
    batches?: BatchUncheckedUpdateManyWithoutCourseNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserCreateWithoutInterviewsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutInterviewsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutInterviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInterviewsInput, UserUncheckedCreateWithoutInterviewsInput>
  }

  export type InterviewQuestionCreateWithoutInterviewInput = {
    id?: string
    avatarId?: string | null
    question: string
    type: $Enums.QuestionType
    order: number
    response?: InterviewResponseCreateNestedOneWithoutQuestionInput
  }

  export type InterviewQuestionUncheckedCreateWithoutInterviewInput = {
    id?: string
    avatarId?: string | null
    question: string
    type: $Enums.QuestionType
    order: number
    response?: InterviewResponseUncheckedCreateNestedOneWithoutQuestionInput
  }

  export type InterviewQuestionCreateOrConnectWithoutInterviewInput = {
    where: InterviewQuestionWhereUniqueInput
    create: XOR<InterviewQuestionCreateWithoutInterviewInput, InterviewQuestionUncheckedCreateWithoutInterviewInput>
  }

  export type InterviewQuestionCreateManyInterviewInputEnvelope = {
    data: InterviewQuestionCreateManyInterviewInput | InterviewQuestionCreateManyInterviewInput[]
    skipDuplicates?: boolean
  }

  export type InterviewResponseCreateWithoutInterviewInput = {
    id?: string
    transcript?: string | null
    code?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    duration?: number | null
    respondedAt?: Date | string
    question: InterviewQuestionCreateNestedOneWithoutResponseInput
  }

  export type InterviewResponseUncheckedCreateWithoutInterviewInput = {
    id?: string
    questionId: string
    transcript?: string | null
    code?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    duration?: number | null
    respondedAt?: Date | string
  }

  export type InterviewResponseCreateOrConnectWithoutInterviewInput = {
    where: InterviewResponseWhereUniqueInput
    create: XOR<InterviewResponseCreateWithoutInterviewInput, InterviewResponseUncheckedCreateWithoutInterviewInput>
  }

  export type InterviewResponseCreateManyInterviewInputEnvelope = {
    data: InterviewResponseCreateManyInterviewInput | InterviewResponseCreateManyInterviewInput[]
    skipDuplicates?: boolean
  }

  export type InterviewEvaluationCreateWithoutInterviewInput = {
    id?: string
    overallScore: number
    technicalScore: number
    communicationScore: number
    confidenceScore: number
    starMethodScore: number
    strengths: JsonNullValueInput | InputJsonValue
    weaknesses: JsonNullValueInput | InputJsonValue
    recommendations: JsonNullValueInput | InputJsonValue
    aiInsights?: string | null
    createdAt?: Date | string
  }

  export type InterviewEvaluationUncheckedCreateWithoutInterviewInput = {
    id?: string
    overallScore: number
    technicalScore: number
    communicationScore: number
    confidenceScore: number
    starMethodScore: number
    strengths: JsonNullValueInput | InputJsonValue
    weaknesses: JsonNullValueInput | InputJsonValue
    recommendations: JsonNullValueInput | InputJsonValue
    aiInsights?: string | null
    createdAt?: Date | string
  }

  export type InterviewEvaluationCreateOrConnectWithoutInterviewInput = {
    where: InterviewEvaluationWhereUniqueInput
    create: XOR<InterviewEvaluationCreateWithoutInterviewInput, InterviewEvaluationUncheckedCreateWithoutInterviewInput>
  }

  export type UserUpsertWithoutInterviewsInput = {
    update: XOR<UserUpdateWithoutInterviewsInput, UserUncheckedUpdateWithoutInterviewsInput>
    create: XOR<UserCreateWithoutInterviewsInput, UserUncheckedCreateWithoutInterviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInterviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInterviewsInput, UserUncheckedUpdateWithoutInterviewsInput>
  }

  export type UserUpdateWithoutInterviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutInterviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type InterviewQuestionUpsertWithWhereUniqueWithoutInterviewInput = {
    where: InterviewQuestionWhereUniqueInput
    update: XOR<InterviewQuestionUpdateWithoutInterviewInput, InterviewQuestionUncheckedUpdateWithoutInterviewInput>
    create: XOR<InterviewQuestionCreateWithoutInterviewInput, InterviewQuestionUncheckedCreateWithoutInterviewInput>
  }

  export type InterviewQuestionUpdateWithWhereUniqueWithoutInterviewInput = {
    where: InterviewQuestionWhereUniqueInput
    data: XOR<InterviewQuestionUpdateWithoutInterviewInput, InterviewQuestionUncheckedUpdateWithoutInterviewInput>
  }

  export type InterviewQuestionUpdateManyWithWhereWithoutInterviewInput = {
    where: InterviewQuestionScalarWhereInput
    data: XOR<InterviewQuestionUpdateManyMutationInput, InterviewQuestionUncheckedUpdateManyWithoutInterviewInput>
  }

  export type InterviewQuestionScalarWhereInput = {
    AND?: InterviewQuestionScalarWhereInput | InterviewQuestionScalarWhereInput[]
    OR?: InterviewQuestionScalarWhereInput[]
    NOT?: InterviewQuestionScalarWhereInput | InterviewQuestionScalarWhereInput[]
    id?: StringFilter<"InterviewQuestion"> | string
    interviewId?: StringFilter<"InterviewQuestion"> | string
    avatarId?: StringNullableFilter<"InterviewQuestion"> | string | null
    question?: StringFilter<"InterviewQuestion"> | string
    type?: EnumQuestionTypeFilter<"InterviewQuestion"> | $Enums.QuestionType
    order?: IntFilter<"InterviewQuestion"> | number
  }

  export type InterviewResponseUpsertWithWhereUniqueWithoutInterviewInput = {
    where: InterviewResponseWhereUniqueInput
    update: XOR<InterviewResponseUpdateWithoutInterviewInput, InterviewResponseUncheckedUpdateWithoutInterviewInput>
    create: XOR<InterviewResponseCreateWithoutInterviewInput, InterviewResponseUncheckedCreateWithoutInterviewInput>
  }

  export type InterviewResponseUpdateWithWhereUniqueWithoutInterviewInput = {
    where: InterviewResponseWhereUniqueInput
    data: XOR<InterviewResponseUpdateWithoutInterviewInput, InterviewResponseUncheckedUpdateWithoutInterviewInput>
  }

  export type InterviewResponseUpdateManyWithWhereWithoutInterviewInput = {
    where: InterviewResponseScalarWhereInput
    data: XOR<InterviewResponseUpdateManyMutationInput, InterviewResponseUncheckedUpdateManyWithoutInterviewInput>
  }

  export type InterviewResponseScalarWhereInput = {
    AND?: InterviewResponseScalarWhereInput | InterviewResponseScalarWhereInput[]
    OR?: InterviewResponseScalarWhereInput[]
    NOT?: InterviewResponseScalarWhereInput | InterviewResponseScalarWhereInput[]
    id?: StringFilter<"InterviewResponse"> | string
    interviewId?: StringFilter<"InterviewResponse"> | string
    questionId?: StringFilter<"InterviewResponse"> | string
    transcript?: StringNullableFilter<"InterviewResponse"> | string | null
    code?: StringNullableFilter<"InterviewResponse"> | string | null
    videoUrl?: StringNullableFilter<"InterviewResponse"> | string | null
    audioUrl?: StringNullableFilter<"InterviewResponse"> | string | null
    duration?: IntNullableFilter<"InterviewResponse"> | number | null
    respondedAt?: DateTimeFilter<"InterviewResponse"> | Date | string
  }

  export type InterviewEvaluationUpsertWithoutInterviewInput = {
    update: XOR<InterviewEvaluationUpdateWithoutInterviewInput, InterviewEvaluationUncheckedUpdateWithoutInterviewInput>
    create: XOR<InterviewEvaluationCreateWithoutInterviewInput, InterviewEvaluationUncheckedCreateWithoutInterviewInput>
    where?: InterviewEvaluationWhereInput
  }

  export type InterviewEvaluationUpdateToOneWithWhereWithoutInterviewInput = {
    where?: InterviewEvaluationWhereInput
    data: XOR<InterviewEvaluationUpdateWithoutInterviewInput, InterviewEvaluationUncheckedUpdateWithoutInterviewInput>
  }

  export type InterviewEvaluationUpdateWithoutInterviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    technicalScore?: IntFieldUpdateOperationsInput | number
    communicationScore?: IntFieldUpdateOperationsInput | number
    confidenceScore?: IntFieldUpdateOperationsInput | number
    starMethodScore?: IntFieldUpdateOperationsInput | number
    strengths?: JsonNullValueInput | InputJsonValue
    weaknesses?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    aiInsights?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewEvaluationUncheckedUpdateWithoutInterviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    technicalScore?: IntFieldUpdateOperationsInput | number
    communicationScore?: IntFieldUpdateOperationsInput | number
    confidenceScore?: IntFieldUpdateOperationsInput | number
    starMethodScore?: IntFieldUpdateOperationsInput | number
    strengths?: JsonNullValueInput | InputJsonValue
    weaknesses?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    aiInsights?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewCreateWithoutQuestionsInput = {
    id?: string
    domain: string
    company?: string | null
    role: string
    technology?: string | null
    jobDescription?: string | null
    resumeUrl?: string | null
    difficulty?: $Enums.Difficulty
    panelCount?: number
    linkedCourseId?: string | null
    duration?: number
    selectedAvatars?: InterviewCreateselectedAvatarsInput | string[]
    status?: $Enums.InterviewStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutInterviewsInput
    responses?: InterviewResponseCreateNestedManyWithoutInterviewInput
    evaluation?: InterviewEvaluationCreateNestedOneWithoutInterviewInput
  }

  export type InterviewUncheckedCreateWithoutQuestionsInput = {
    id?: string
    userId: string
    domain: string
    company?: string | null
    role: string
    technology?: string | null
    jobDescription?: string | null
    resumeUrl?: string | null
    difficulty?: $Enums.Difficulty
    panelCount?: number
    linkedCourseId?: string | null
    duration?: number
    selectedAvatars?: InterviewCreateselectedAvatarsInput | string[]
    status?: $Enums.InterviewStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    responses?: InterviewResponseUncheckedCreateNestedManyWithoutInterviewInput
    evaluation?: InterviewEvaluationUncheckedCreateNestedOneWithoutInterviewInput
  }

  export type InterviewCreateOrConnectWithoutQuestionsInput = {
    where: InterviewWhereUniqueInput
    create: XOR<InterviewCreateWithoutQuestionsInput, InterviewUncheckedCreateWithoutQuestionsInput>
  }

  export type InterviewResponseCreateWithoutQuestionInput = {
    id?: string
    transcript?: string | null
    code?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    duration?: number | null
    respondedAt?: Date | string
    interview: InterviewCreateNestedOneWithoutResponsesInput
  }

  export type InterviewResponseUncheckedCreateWithoutQuestionInput = {
    id?: string
    interviewId: string
    transcript?: string | null
    code?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    duration?: number | null
    respondedAt?: Date | string
  }

  export type InterviewResponseCreateOrConnectWithoutQuestionInput = {
    where: InterviewResponseWhereUniqueInput
    create: XOR<InterviewResponseCreateWithoutQuestionInput, InterviewResponseUncheckedCreateWithoutQuestionInput>
  }

  export type InterviewUpsertWithoutQuestionsInput = {
    update: XOR<InterviewUpdateWithoutQuestionsInput, InterviewUncheckedUpdateWithoutQuestionsInput>
    create: XOR<InterviewCreateWithoutQuestionsInput, InterviewUncheckedCreateWithoutQuestionsInput>
    where?: InterviewWhereInput
  }

  export type InterviewUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: InterviewWhereInput
    data: XOR<InterviewUpdateWithoutQuestionsInput, InterviewUncheckedUpdateWithoutQuestionsInput>
  }

  export type InterviewUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    technology?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    panelCount?: IntFieldUpdateOperationsInput | number
    linkedCourseId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    selectedAvatars?: InterviewUpdateselectedAvatarsInput | string[]
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInterviewsNestedInput
    responses?: InterviewResponseUpdateManyWithoutInterviewNestedInput
    evaluation?: InterviewEvaluationUpdateOneWithoutInterviewNestedInput
  }

  export type InterviewUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    technology?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    panelCount?: IntFieldUpdateOperationsInput | number
    linkedCourseId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    selectedAvatars?: InterviewUpdateselectedAvatarsInput | string[]
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: InterviewResponseUncheckedUpdateManyWithoutInterviewNestedInput
    evaluation?: InterviewEvaluationUncheckedUpdateOneWithoutInterviewNestedInput
  }

  export type InterviewResponseUpsertWithoutQuestionInput = {
    update: XOR<InterviewResponseUpdateWithoutQuestionInput, InterviewResponseUncheckedUpdateWithoutQuestionInput>
    create: XOR<InterviewResponseCreateWithoutQuestionInput, InterviewResponseUncheckedCreateWithoutQuestionInput>
    where?: InterviewResponseWhereInput
  }

  export type InterviewResponseUpdateToOneWithWhereWithoutQuestionInput = {
    where?: InterviewResponseWhereInput
    data: XOR<InterviewResponseUpdateWithoutQuestionInput, InterviewResponseUncheckedUpdateWithoutQuestionInput>
  }

  export type InterviewResponseUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interview?: InterviewUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type InterviewResponseUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    interviewId?: StringFieldUpdateOperationsInput | string
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewCreateWithoutResponsesInput = {
    id?: string
    domain: string
    company?: string | null
    role: string
    technology?: string | null
    jobDescription?: string | null
    resumeUrl?: string | null
    difficulty?: $Enums.Difficulty
    panelCount?: number
    linkedCourseId?: string | null
    duration?: number
    selectedAvatars?: InterviewCreateselectedAvatarsInput | string[]
    status?: $Enums.InterviewStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutInterviewsInput
    questions?: InterviewQuestionCreateNestedManyWithoutInterviewInput
    evaluation?: InterviewEvaluationCreateNestedOneWithoutInterviewInput
  }

  export type InterviewUncheckedCreateWithoutResponsesInput = {
    id?: string
    userId: string
    domain: string
    company?: string | null
    role: string
    technology?: string | null
    jobDescription?: string | null
    resumeUrl?: string | null
    difficulty?: $Enums.Difficulty
    panelCount?: number
    linkedCourseId?: string | null
    duration?: number
    selectedAvatars?: InterviewCreateselectedAvatarsInput | string[]
    status?: $Enums.InterviewStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    questions?: InterviewQuestionUncheckedCreateNestedManyWithoutInterviewInput
    evaluation?: InterviewEvaluationUncheckedCreateNestedOneWithoutInterviewInput
  }

  export type InterviewCreateOrConnectWithoutResponsesInput = {
    where: InterviewWhereUniqueInput
    create: XOR<InterviewCreateWithoutResponsesInput, InterviewUncheckedCreateWithoutResponsesInput>
  }

  export type InterviewQuestionCreateWithoutResponseInput = {
    id?: string
    avatarId?: string | null
    question: string
    type: $Enums.QuestionType
    order: number
    interview: InterviewCreateNestedOneWithoutQuestionsInput
  }

  export type InterviewQuestionUncheckedCreateWithoutResponseInput = {
    id?: string
    interviewId: string
    avatarId?: string | null
    question: string
    type: $Enums.QuestionType
    order: number
  }

  export type InterviewQuestionCreateOrConnectWithoutResponseInput = {
    where: InterviewQuestionWhereUniqueInput
    create: XOR<InterviewQuestionCreateWithoutResponseInput, InterviewQuestionUncheckedCreateWithoutResponseInput>
  }

  export type InterviewUpsertWithoutResponsesInput = {
    update: XOR<InterviewUpdateWithoutResponsesInput, InterviewUncheckedUpdateWithoutResponsesInput>
    create: XOR<InterviewCreateWithoutResponsesInput, InterviewUncheckedCreateWithoutResponsesInput>
    where?: InterviewWhereInput
  }

  export type InterviewUpdateToOneWithWhereWithoutResponsesInput = {
    where?: InterviewWhereInput
    data: XOR<InterviewUpdateWithoutResponsesInput, InterviewUncheckedUpdateWithoutResponsesInput>
  }

  export type InterviewUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    technology?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    panelCount?: IntFieldUpdateOperationsInput | number
    linkedCourseId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    selectedAvatars?: InterviewUpdateselectedAvatarsInput | string[]
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInterviewsNestedInput
    questions?: InterviewQuestionUpdateManyWithoutInterviewNestedInput
    evaluation?: InterviewEvaluationUpdateOneWithoutInterviewNestedInput
  }

  export type InterviewUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    technology?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    panelCount?: IntFieldUpdateOperationsInput | number
    linkedCourseId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    selectedAvatars?: InterviewUpdateselectedAvatarsInput | string[]
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: InterviewQuestionUncheckedUpdateManyWithoutInterviewNestedInput
    evaluation?: InterviewEvaluationUncheckedUpdateOneWithoutInterviewNestedInput
  }

  export type InterviewQuestionUpsertWithoutResponseInput = {
    update: XOR<InterviewQuestionUpdateWithoutResponseInput, InterviewQuestionUncheckedUpdateWithoutResponseInput>
    create: XOR<InterviewQuestionCreateWithoutResponseInput, InterviewQuestionUncheckedCreateWithoutResponseInput>
    where?: InterviewQuestionWhereInput
  }

  export type InterviewQuestionUpdateToOneWithWhereWithoutResponseInput = {
    where?: InterviewQuestionWhereInput
    data: XOR<InterviewQuestionUpdateWithoutResponseInput, InterviewQuestionUncheckedUpdateWithoutResponseInput>
  }

  export type InterviewQuestionUpdateWithoutResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatarId?: NullableStringFieldUpdateOperationsInput | string | null
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    order?: IntFieldUpdateOperationsInput | number
    interview?: InterviewUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type InterviewQuestionUncheckedUpdateWithoutResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    interviewId?: StringFieldUpdateOperationsInput | string
    avatarId?: NullableStringFieldUpdateOperationsInput | string | null
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    order?: IntFieldUpdateOperationsInput | number
  }

  export type InterviewCreateWithoutEvaluationInput = {
    id?: string
    domain: string
    company?: string | null
    role: string
    technology?: string | null
    jobDescription?: string | null
    resumeUrl?: string | null
    difficulty?: $Enums.Difficulty
    panelCount?: number
    linkedCourseId?: string | null
    duration?: number
    selectedAvatars?: InterviewCreateselectedAvatarsInput | string[]
    status?: $Enums.InterviewStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutInterviewsInput
    questions?: InterviewQuestionCreateNestedManyWithoutInterviewInput
    responses?: InterviewResponseCreateNestedManyWithoutInterviewInput
  }

  export type InterviewUncheckedCreateWithoutEvaluationInput = {
    id?: string
    userId: string
    domain: string
    company?: string | null
    role: string
    technology?: string | null
    jobDescription?: string | null
    resumeUrl?: string | null
    difficulty?: $Enums.Difficulty
    panelCount?: number
    linkedCourseId?: string | null
    duration?: number
    selectedAvatars?: InterviewCreateselectedAvatarsInput | string[]
    status?: $Enums.InterviewStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    questions?: InterviewQuestionUncheckedCreateNestedManyWithoutInterviewInput
    responses?: InterviewResponseUncheckedCreateNestedManyWithoutInterviewInput
  }

  export type InterviewCreateOrConnectWithoutEvaluationInput = {
    where: InterviewWhereUniqueInput
    create: XOR<InterviewCreateWithoutEvaluationInput, InterviewUncheckedCreateWithoutEvaluationInput>
  }

  export type InterviewUpsertWithoutEvaluationInput = {
    update: XOR<InterviewUpdateWithoutEvaluationInput, InterviewUncheckedUpdateWithoutEvaluationInput>
    create: XOR<InterviewCreateWithoutEvaluationInput, InterviewUncheckedCreateWithoutEvaluationInput>
    where?: InterviewWhereInput
  }

  export type InterviewUpdateToOneWithWhereWithoutEvaluationInput = {
    where?: InterviewWhereInput
    data: XOR<InterviewUpdateWithoutEvaluationInput, InterviewUncheckedUpdateWithoutEvaluationInput>
  }

  export type InterviewUpdateWithoutEvaluationInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    technology?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    panelCount?: IntFieldUpdateOperationsInput | number
    linkedCourseId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    selectedAvatars?: InterviewUpdateselectedAvatarsInput | string[]
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInterviewsNestedInput
    questions?: InterviewQuestionUpdateManyWithoutInterviewNestedInput
    responses?: InterviewResponseUpdateManyWithoutInterviewNestedInput
  }

  export type InterviewUncheckedUpdateWithoutEvaluationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    technology?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    panelCount?: IntFieldUpdateOperationsInput | number
    linkedCourseId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    selectedAvatars?: InterviewUpdateselectedAvatarsInput | string[]
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: InterviewQuestionUncheckedUpdateManyWithoutInterviewNestedInput
    responses?: InterviewResponseUncheckedUpdateManyWithoutInterviewNestedInput
  }

  export type UserCreateWithoutPaymentsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type CourseCreateWithoutPaymentsInput = {
    id?: string
    title: string
    description: string
    thumbnail?: string | null
    category: string
    difficulty?: $Enums.Difficulty
    duration?: number
    price?: Decimal | DecimalJsLike | number | string
    discountPrice?: Decimal | DecimalJsLike | number | string
    courseCode?: string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: string | null
    averageRating?: number
    instructorId: string
    isPublished?: boolean
    hasInterviewPrep?: boolean
    interviewPrice?: Decimal | DecimalJsLike | number | string
    bundlePrice?: Decimal | DecimalJsLike | number | string
    courseType?: $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: $Enums.PublishStatus
    publishedAt?: Date | string | null
    reviewNotes?: string | null
    submittedForReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    reviews?: ReviewCreateNestedManyWithoutCourseInput
    liveClasses?: LiveClassCreateNestedManyWithoutCourseInput
    batches?: BatchCreateNestedManyWithoutCourseInput
    announcements?: AnnouncementCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutPaymentsInput = {
    id?: string
    title: string
    description: string
    thumbnail?: string | null
    category: string
    difficulty?: $Enums.Difficulty
    duration?: number
    price?: Decimal | DecimalJsLike | number | string
    discountPrice?: Decimal | DecimalJsLike | number | string
    courseCode?: string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: string | null
    averageRating?: number
    instructorId: string
    isPublished?: boolean
    hasInterviewPrep?: boolean
    interviewPrice?: Decimal | DecimalJsLike | number | string
    bundlePrice?: Decimal | DecimalJsLike | number | string
    courseType?: $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: $Enums.PublishStatus
    publishedAt?: Date | string | null
    reviewNotes?: string | null
    submittedForReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCourseInput
    liveClasses?: LiveClassUncheckedCreateNestedManyWithoutCourseInput
    batches?: BatchUncheckedCreateNestedManyWithoutCourseInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutPaymentsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutPaymentsInput, CourseUncheckedCreateWithoutPaymentsInput>
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type CourseUpsertWithoutPaymentsInput = {
    update: XOR<CourseUpdateWithoutPaymentsInput, CourseUncheckedUpdateWithoutPaymentsInput>
    create: XOR<CourseCreateWithoutPaymentsInput, CourseUncheckedCreateWithoutPaymentsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutPaymentsInput, CourseUncheckedUpdateWithoutPaymentsInput>
  }

  export type CourseUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseCode?: NullableStringFieldUpdateOperationsInput | string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    instructorId?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    hasInterviewPrep?: BoolFieldUpdateOperationsInput | boolean
    interviewPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bundlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    reviews?: ReviewUpdateManyWithoutCourseNestedInput
    liveClasses?: LiveClassUpdateManyWithoutCourseNestedInput
    batches?: BatchUpdateManyWithoutCourseNestedInput
    announcements?: AnnouncementUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseCode?: NullableStringFieldUpdateOperationsInput | string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    instructorId?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    hasInterviewPrep?: BoolFieldUpdateOperationsInput | boolean
    interviewPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bundlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCourseNestedInput
    liveClasses?: LiveClassUncheckedUpdateManyWithoutCourseNestedInput
    batches?: BatchUncheckedUpdateManyWithoutCourseNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type ForumPostCreateWithoutCategoryInput = {
    id?: string
    title: string
    content: string
    slug: string
    likes?: number
    views?: number
    isPinned?: boolean
    isSolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPostsInput
    comments?: ForumCommentCreateNestedManyWithoutPostInput
  }

  export type ForumPostUncheckedCreateWithoutCategoryInput = {
    id?: string
    title: string
    content: string
    slug: string
    authorId: string
    likes?: number
    views?: number
    isPinned?: boolean
    isSolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ForumCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type ForumPostCreateOrConnectWithoutCategoryInput = {
    where: ForumPostWhereUniqueInput
    create: XOR<ForumPostCreateWithoutCategoryInput, ForumPostUncheckedCreateWithoutCategoryInput>
  }

  export type ForumPostCreateManyCategoryInputEnvelope = {
    data: ForumPostCreateManyCategoryInput | ForumPostCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ForumPostUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ForumPostWhereUniqueInput
    update: XOR<ForumPostUpdateWithoutCategoryInput, ForumPostUncheckedUpdateWithoutCategoryInput>
    create: XOR<ForumPostCreateWithoutCategoryInput, ForumPostUncheckedCreateWithoutCategoryInput>
  }

  export type ForumPostUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ForumPostWhereUniqueInput
    data: XOR<ForumPostUpdateWithoutCategoryInput, ForumPostUncheckedUpdateWithoutCategoryInput>
  }

  export type ForumPostUpdateManyWithWhereWithoutCategoryInput = {
    where: ForumPostScalarWhereInput
    data: XOR<ForumPostUpdateManyMutationInput, ForumPostUncheckedUpdateManyWithoutCategoryInput>
  }

  export type UserCreateWithoutPostsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type ForumCategoryCreateWithoutPostsInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCategoryUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    icon?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCategoryCreateOrConnectWithoutPostsInput = {
    where: ForumCategoryWhereUniqueInput
    create: XOR<ForumCategoryCreateWithoutPostsInput, ForumCategoryUncheckedCreateWithoutPostsInput>
  }

  export type ForumCommentCreateWithoutPostInput = {
    id?: string
    content: string
    parentId?: string | null
    isSolution?: boolean
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutCommentsInput
  }

  export type ForumCommentUncheckedCreateWithoutPostInput = {
    id?: string
    content: string
    authorId: string
    parentId?: string | null
    isSolution?: boolean
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCommentCreateOrConnectWithoutPostInput = {
    where: ForumCommentWhereUniqueInput
    create: XOR<ForumCommentCreateWithoutPostInput, ForumCommentUncheckedCreateWithoutPostInput>
  }

  export type ForumCommentCreateManyPostInputEnvelope = {
    data: ForumCommentCreateManyPostInput | ForumCommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type ForumCategoryUpsertWithoutPostsInput = {
    update: XOR<ForumCategoryUpdateWithoutPostsInput, ForumCategoryUncheckedUpdateWithoutPostsInput>
    create: XOR<ForumCategoryCreateWithoutPostsInput, ForumCategoryUncheckedCreateWithoutPostsInput>
    where?: ForumCategoryWhereInput
  }

  export type ForumCategoryUpdateToOneWithWhereWithoutPostsInput = {
    where?: ForumCategoryWhereInput
    data: XOR<ForumCategoryUpdateWithoutPostsInput, ForumCategoryUncheckedUpdateWithoutPostsInput>
  }

  export type ForumCategoryUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCategoryUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentUpsertWithWhereUniqueWithoutPostInput = {
    where: ForumCommentWhereUniqueInput
    update: XOR<ForumCommentUpdateWithoutPostInput, ForumCommentUncheckedUpdateWithoutPostInput>
    create: XOR<ForumCommentCreateWithoutPostInput, ForumCommentUncheckedCreateWithoutPostInput>
  }

  export type ForumCommentUpdateWithWhereUniqueWithoutPostInput = {
    where: ForumCommentWhereUniqueInput
    data: XOR<ForumCommentUpdateWithoutPostInput, ForumCommentUncheckedUpdateWithoutPostInput>
  }

  export type ForumCommentUpdateManyWithWhereWithoutPostInput = {
    where: ForumCommentScalarWhereInput
    data: XOR<ForumCommentUpdateManyMutationInput, ForumCommentUncheckedUpdateManyWithoutPostInput>
  }

  export type ForumPostCreateWithoutCommentsInput = {
    id?: string
    title: string
    content: string
    slug: string
    likes?: number
    views?: number
    isPinned?: boolean
    isSolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPostsInput
    category: ForumCategoryCreateNestedOneWithoutPostsInput
  }

  export type ForumPostUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    content: string
    slug: string
    authorId: string
    categoryId: string
    likes?: number
    views?: number
    isPinned?: boolean
    isSolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumPostCreateOrConnectWithoutCommentsInput = {
    where: ForumPostWhereUniqueInput
    create: XOR<ForumPostCreateWithoutCommentsInput, ForumPostUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type ForumPostUpsertWithoutCommentsInput = {
    update: XOR<ForumPostUpdateWithoutCommentsInput, ForumPostUncheckedUpdateWithoutCommentsInput>
    create: XOR<ForumPostCreateWithoutCommentsInput, ForumPostUncheckedCreateWithoutCommentsInput>
    where?: ForumPostWhereInput
  }

  export type ForumPostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ForumPostWhereInput
    data: XOR<ForumPostUpdateWithoutCommentsInput, ForumPostUncheckedUpdateWithoutCommentsInput>
  }

  export type ForumPostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isSolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    category?: ForumCategoryUpdateOneRequiredWithoutPostsNestedInput
  }

  export type ForumPostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isSolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type UserCreateWithoutConversationsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutConversationsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    content: string
    readBy?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    senderId: string
    content: string
    readBy?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutConversationsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutConversationsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateManyWithWhereWithoutConversationsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutConversationsInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    avatar?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    emailVerified?: BoolFilter<"User"> | boolean
    permissions?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    name?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: UserCreateNestedManyWithoutConversationsInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    name?: string | null
    isGroup?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: UserUncheckedCreateNestedManyWithoutConversationsInput
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: UserUpdateManyWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: UserUncheckedUpdateManyWithoutConversationsNestedInput
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type UserCreateWithoutCertificatesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutCertificatesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutCertificatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCertificatesInput, UserUncheckedCreateWithoutCertificatesInput>
  }

  export type CertificateTemplateCreateWithoutCertificatesInput = {
    id?: string
    name: string
    description?: string | null
    designUrl: string
    previewUrl?: string | null
    isDefault?: boolean
    isActive?: boolean
    layout?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateTemplateUncheckedCreateWithoutCertificatesInput = {
    id?: string
    name: string
    description?: string | null
    designUrl: string
    previewUrl?: string | null
    isDefault?: boolean
    isActive?: boolean
    layout?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateTemplateCreateOrConnectWithoutCertificatesInput = {
    where: CertificateTemplateWhereUniqueInput
    create: XOR<CertificateTemplateCreateWithoutCertificatesInput, CertificateTemplateUncheckedCreateWithoutCertificatesInput>
  }

  export type UserUpsertWithoutCertificatesInput = {
    update: XOR<UserUpdateWithoutCertificatesInput, UserUncheckedUpdateWithoutCertificatesInput>
    create: XOR<UserCreateWithoutCertificatesInput, UserUncheckedCreateWithoutCertificatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCertificatesInput, UserUncheckedUpdateWithoutCertificatesInput>
  }

  export type UserUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type CertificateTemplateUpsertWithoutCertificatesInput = {
    update: XOR<CertificateTemplateUpdateWithoutCertificatesInput, CertificateTemplateUncheckedUpdateWithoutCertificatesInput>
    create: XOR<CertificateTemplateCreateWithoutCertificatesInput, CertificateTemplateUncheckedCreateWithoutCertificatesInput>
    where?: CertificateTemplateWhereInput
  }

  export type CertificateTemplateUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: CertificateTemplateWhereInput
    data: XOR<CertificateTemplateUpdateWithoutCertificatesInput, CertificateTemplateUncheckedUpdateWithoutCertificatesInput>
  }

  export type CertificateTemplateUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    designUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    layout?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateTemplateUncheckedUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    designUrl?: StringFieldUpdateOperationsInput | string
    previewUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    layout?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateCreateWithoutTemplateInput = {
    id?: string
    uniqueId: string
    courseId: string
    enrollmentId: string
    studentName: string
    courseName: string
    courseCategory?: string | null
    issueDate?: Date | string
    expiryDate?: Date | string | null
    signatureUrl?: string | null
    signatoryName?: string | null
    signatoryTitle?: string | null
    verificationUrl?: string | null
    isValid?: boolean
    grade?: string | null
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateWithoutTemplateInput = {
    id?: string
    uniqueId: string
    userId: string
    courseId: string
    enrollmentId: string
    studentName: string
    courseName: string
    courseCategory?: string | null
    issueDate?: Date | string
    expiryDate?: Date | string | null
    signatureUrl?: string | null
    signatoryName?: string | null
    signatoryTitle?: string | null
    verificationUrl?: string | null
    isValid?: boolean
    grade?: string | null
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateCreateOrConnectWithoutTemplateInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutTemplateInput, CertificateUncheckedCreateWithoutTemplateInput>
  }

  export type CertificateCreateManyTemplateInputEnvelope = {
    data: CertificateCreateManyTemplateInput | CertificateCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type CertificateUpsertWithWhereUniqueWithoutTemplateInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutTemplateInput, CertificateUncheckedUpdateWithoutTemplateInput>
    create: XOR<CertificateCreateWithoutTemplateInput, CertificateUncheckedCreateWithoutTemplateInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutTemplateInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutTemplateInput, CertificateUncheckedUpdateWithoutTemplateInput>
  }

  export type CertificateUpdateManyWithWhereWithoutTemplateInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutTemplateInput>
  }

  export type CourseCreateWithoutLiveClassesInput = {
    id?: string
    title: string
    description: string
    thumbnail?: string | null
    category: string
    difficulty?: $Enums.Difficulty
    duration?: number
    price?: Decimal | DecimalJsLike | number | string
    discountPrice?: Decimal | DecimalJsLike | number | string
    courseCode?: string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: string | null
    averageRating?: number
    instructorId: string
    isPublished?: boolean
    hasInterviewPrep?: boolean
    interviewPrice?: Decimal | DecimalJsLike | number | string
    bundlePrice?: Decimal | DecimalJsLike | number | string
    courseType?: $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: $Enums.PublishStatus
    publishedAt?: Date | string | null
    reviewNotes?: string | null
    submittedForReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    payments?: PaymentCreateNestedManyWithoutCourseInput
    reviews?: ReviewCreateNestedManyWithoutCourseInput
    batches?: BatchCreateNestedManyWithoutCourseInput
    announcements?: AnnouncementCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutLiveClassesInput = {
    id?: string
    title: string
    description: string
    thumbnail?: string | null
    category: string
    difficulty?: $Enums.Difficulty
    duration?: number
    price?: Decimal | DecimalJsLike | number | string
    discountPrice?: Decimal | DecimalJsLike | number | string
    courseCode?: string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: string | null
    averageRating?: number
    instructorId: string
    isPublished?: boolean
    hasInterviewPrep?: boolean
    interviewPrice?: Decimal | DecimalJsLike | number | string
    bundlePrice?: Decimal | DecimalJsLike | number | string
    courseType?: $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: $Enums.PublishStatus
    publishedAt?: Date | string | null
    reviewNotes?: string | null
    submittedForReviewAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCourseInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCourseInput
    batches?: BatchUncheckedCreateNestedManyWithoutCourseInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutLiveClassesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutLiveClassesInput, CourseUncheckedCreateWithoutLiveClassesInput>
  }

  export type CourseUpsertWithoutLiveClassesInput = {
    update: XOR<CourseUpdateWithoutLiveClassesInput, CourseUncheckedUpdateWithoutLiveClassesInput>
    create: XOR<CourseCreateWithoutLiveClassesInput, CourseUncheckedCreateWithoutLiveClassesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutLiveClassesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutLiveClassesInput, CourseUncheckedUpdateWithoutLiveClassesInput>
  }

  export type CourseUpdateWithoutLiveClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseCode?: NullableStringFieldUpdateOperationsInput | string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    instructorId?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    hasInterviewPrep?: BoolFieldUpdateOperationsInput | boolean
    interviewPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bundlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    payments?: PaymentUpdateManyWithoutCourseNestedInput
    reviews?: ReviewUpdateManyWithoutCourseNestedInput
    batches?: BatchUpdateManyWithoutCourseNestedInput
    announcements?: AnnouncementUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutLiveClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    duration?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseCode?: NullableStringFieldUpdateOperationsInput | string | null
    jobRoles?: NullableJsonNullValueInput | InputJsonValue
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    instructorId?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    hasInterviewPrep?: BoolFieldUpdateOperationsInput | boolean
    interviewPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bundlePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    courseType?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    liveSchedule?: NullableJsonNullValueInput | InputJsonValue
    hybridConfig?: NullableJsonNullValueInput | InputJsonValue
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    submittedForReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCourseNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCourseNestedInput
    batches?: BatchUncheckedUpdateManyWithoutCourseNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type TaskCreateWithoutLeadInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignee?: UserCreateNestedOneWithoutAssignedTasksInput
    creator?: UserCreateNestedOneWithoutCreatedTasksInput
    comments?: TaskCommentCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutLeadInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    assignedTo?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: TaskCommentUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutLeadInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutLeadInput, TaskUncheckedCreateWithoutLeadInput>
  }

  export type TaskCreateManyLeadInputEnvelope = {
    data: TaskCreateManyLeadInput | TaskCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type TaskUpsertWithWhereUniqueWithoutLeadInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutLeadInput, TaskUncheckedUpdateWithoutLeadInput>
    create: XOR<TaskCreateWithoutLeadInput, TaskUncheckedCreateWithoutLeadInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutLeadInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutLeadInput, TaskUncheckedUpdateWithoutLeadInput>
  }

  export type TaskUpdateManyWithWhereWithoutLeadInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutLeadInput>
  }

  export type UserCreateWithoutAssignedTasksInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutAssignedTasksInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutAssignedTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
  }

  export type UserCreateWithoutCreatedTasksInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutCreatedTasksInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutCreatedTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTasksInput, UserUncheckedCreateWithoutCreatedTasksInput>
  }

  export type LeadCreateWithoutTasksInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    college?: string | null
    qualification?: string | null
    dob?: Date | string | null
    location?: string | null
    gender?: string | null
    source: string
    status?: $Enums.LeadStatus
    notes?: string | null
    assignedTo?: string | null
    platform?: string | null
    campaignId?: string | null
    adGroupId?: string | null
    adId?: string | null
    formId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    college?: string | null
    qualification?: string | null
    dob?: Date | string | null
    location?: string | null
    gender?: string | null
    source: string
    status?: $Enums.LeadStatus
    notes?: string | null
    assignedTo?: string | null
    platform?: string | null
    campaignId?: string | null
    adGroupId?: string | null
    adId?: string | null
    formId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadCreateOrConnectWithoutTasksInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutTasksInput, LeadUncheckedCreateWithoutTasksInput>
  }

  export type TaskCommentCreateWithoutTaskInput = {
    id?: string
    content: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTaskCommentsInput
  }

  export type TaskCommentUncheckedCreateWithoutTaskInput = {
    id?: string
    content: string
    userId: string
    createdAt?: Date | string
  }

  export type TaskCommentCreateOrConnectWithoutTaskInput = {
    where: TaskCommentWhereUniqueInput
    create: XOR<TaskCommentCreateWithoutTaskInput, TaskCommentUncheckedCreateWithoutTaskInput>
  }

  export type TaskCommentCreateManyTaskInputEnvelope = {
    data: TaskCommentCreateManyTaskInput | TaskCommentCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAssignedTasksInput = {
    update: XOR<UserUpdateWithoutAssignedTasksInput, UserUncheckedUpdateWithoutAssignedTasksInput>
    create: XOR<UserCreateWithoutAssignedTasksInput, UserUncheckedCreateWithoutAssignedTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedTasksInput, UserUncheckedUpdateWithoutAssignedTasksInput>
  }

  export type UserUpdateWithoutAssignedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUpsertWithoutCreatedTasksInput = {
    update: XOR<UserUpdateWithoutCreatedTasksInput, UserUncheckedUpdateWithoutCreatedTasksInput>
    create: XOR<UserCreateWithoutCreatedTasksInput, UserUncheckedCreateWithoutCreatedTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTasksInput, UserUncheckedUpdateWithoutCreatedTasksInput>
  }

  export type UserUpdateWithoutCreatedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type LeadUpsertWithoutTasksInput = {
    update: XOR<LeadUpdateWithoutTasksInput, LeadUncheckedUpdateWithoutTasksInput>
    create: XOR<LeadCreateWithoutTasksInput, LeadUncheckedCreateWithoutTasksInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutTasksInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutTasksInput, LeadUncheckedUpdateWithoutTasksInput>
  }

  export type LeadUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    adGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    college?: NullableStringFieldUpdateOperationsInput | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    adGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    formId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCommentUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskCommentWhereUniqueInput
    update: XOR<TaskCommentUpdateWithoutTaskInput, TaskCommentUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskCommentCreateWithoutTaskInput, TaskCommentUncheckedCreateWithoutTaskInput>
  }

  export type TaskCommentUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskCommentWhereUniqueInput
    data: XOR<TaskCommentUpdateWithoutTaskInput, TaskCommentUncheckedUpdateWithoutTaskInput>
  }

  export type TaskCommentUpdateManyWithWhereWithoutTaskInput = {
    where: TaskCommentScalarWhereInput
    data: XOR<TaskCommentUpdateManyMutationInput, TaskCommentUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskCreateWithoutCommentsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignee?: UserCreateNestedOneWithoutAssignedTasksInput
    creator?: UserCreateNestedOneWithoutCreatedTasksInput
    lead?: LeadCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    assignedTo?: string | null
    createdBy?: string | null
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutCommentsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutTaskCommentsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutTaskCommentsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutTaskCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaskCommentsInput, UserUncheckedCreateWithoutTaskCommentsInput>
  }

  export type TaskUpsertWithoutCommentsInput = {
    update: XOR<TaskUpdateWithoutCommentsInput, TaskUncheckedUpdateWithoutCommentsInput>
    create: XOR<TaskCreateWithoutCommentsInput, TaskUncheckedCreateWithoutCommentsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutCommentsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutCommentsInput, TaskUncheckedUpdateWithoutCommentsInput>
  }

  export type TaskUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignee?: UserUpdateOneWithoutAssignedTasksNestedInput
    creator?: UserUpdateOneWithoutCreatedTasksNestedInput
    lead?: LeadUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTaskCommentsInput = {
    update: XOR<UserUpdateWithoutTaskCommentsInput, UserUncheckedUpdateWithoutTaskCommentsInput>
    create: XOR<UserCreateWithoutTaskCommentsInput, UserUncheckedCreateWithoutTaskCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaskCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaskCommentsInput, UserUncheckedUpdateWithoutTaskCommentsInput>
  }

  export type UserUpdateWithoutTaskCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutTaskCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type UserCreateWithoutBlogPostsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutBlogPostsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutBlogPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
  }

  export type UserUpsertWithoutBlogPostsInput = {
    update: XOR<UserUpdateWithoutBlogPostsInput, UserUncheckedUpdateWithoutBlogPostsInput>
    create: XOR<UserCreateWithoutBlogPostsInput, UserUncheckedCreateWithoutBlogPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogPostsInput, UserUncheckedUpdateWithoutBlogPostsInput>
  }

  export type UserUpdateWithoutBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type UserCreateWithoutTicketsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutTicketsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
  }

  export type TicketMessageCreateWithoutTicketInput = {
    id?: string
    message: string
    attachmentUrl?: string | null
    isStaffReply?: boolean
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutSentTicketMessagesInput
  }

  export type TicketMessageUncheckedCreateWithoutTicketInput = {
    id?: string
    message: string
    attachmentUrl?: string | null
    isStaffReply?: boolean
    createdAt?: Date | string
    userId?: string | null
  }

  export type TicketMessageCreateOrConnectWithoutTicketInput = {
    where: TicketMessageWhereUniqueInput
    create: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput>
  }

  export type TicketMessageCreateManyTicketInputEnvelope = {
    data: TicketMessageCreateManyTicketInput | TicketMessageCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTicketsInput = {
    update: XOR<UserUpdateWithoutTicketsInput, UserUncheckedUpdateWithoutTicketsInput>
    create: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketsInput, UserUncheckedUpdateWithoutTicketsInput>
  }

  export type UserUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type TicketMessageUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketMessageWhereUniqueInput
    update: XOR<TicketMessageUpdateWithoutTicketInput, TicketMessageUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput>
  }

  export type TicketMessageUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketMessageWhereUniqueInput
    data: XOR<TicketMessageUpdateWithoutTicketInput, TicketMessageUncheckedUpdateWithoutTicketInput>
  }

  export type TicketMessageUpdateManyWithWhereWithoutTicketInput = {
    where: TicketMessageScalarWhereInput
    data: XOR<TicketMessageUpdateManyMutationInput, TicketMessageUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketCreateWithoutMessagesInput = {
    id?: string
    subject: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    category?: $Enums.TicketCategory
    assignedTo?: string | null
    internalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutMessagesInput = {
    id?: string
    subject: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    category?: $Enums.TicketCategory
    userId: string
    assignedTo?: string | null
    internalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateOrConnectWithoutMessagesInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutMessagesInput, TicketUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutSentTicketMessagesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutSentTicketMessagesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutSentTicketMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentTicketMessagesInput, UserUncheckedCreateWithoutSentTicketMessagesInput>
  }

  export type TicketUpsertWithoutMessagesInput = {
    update: XOR<TicketUpdateWithoutMessagesInput, TicketUncheckedUpdateWithoutMessagesInput>
    create: XOR<TicketCreateWithoutMessagesInput, TicketUncheckedCreateWithoutMessagesInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutMessagesInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutMessagesInput, TicketUncheckedUpdateWithoutMessagesInput>
  }

  export type TicketUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    userId?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutSentTicketMessagesInput = {
    update: XOR<UserUpdateWithoutSentTicketMessagesInput, UserUncheckedUpdateWithoutSentTicketMessagesInput>
    create: XOR<UserCreateWithoutSentTicketMessagesInput, UserUncheckedCreateWithoutSentTicketMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentTicketMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentTicketMessagesInput, UserUncheckedUpdateWithoutSentTicketMessagesInput>
  }

  export type UserUpdateWithoutSentTicketMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutSentTicketMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type UserCreateWithoutEmployerProfileInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutEmployerProfileInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutEmployerProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployerProfileInput, UserUncheckedCreateWithoutEmployerProfileInput>
  }

  export type UserUpsertWithoutEmployerProfileInput = {
    update: XOR<UserUpdateWithoutEmployerProfileInput, UserUncheckedUpdateWithoutEmployerProfileInput>
    create: XOR<UserCreateWithoutEmployerProfileInput, UserUncheckedCreateWithoutEmployerProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployerProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployerProfileInput, UserUncheckedUpdateWithoutEmployerProfileInput>
  }

  export type UserUpdateWithoutEmployerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type UserCreateWithoutJobsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutJobsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutJobsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJobsInput, UserUncheckedCreateWithoutJobsInput>
  }

  export type JobApplicationCreateWithoutJobInput = {
    id?: string
    source?: $Enums.CandidateSource
    externalName?: string | null
    externalEmail?: string | null
    externalPhone?: string | null
    resumeUrl?: string | null
    coverLetter?: string | null
    resumeParsedText?: string | null
    atsScore?: number
    status?: $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    applicant?: UserCreateNestedOneWithoutApplicationsInput
    interviews?: JobInterviewCreateNestedManyWithoutApplicationInput
    emailLogs?: EmailLogCreateNestedManyWithoutApplicationInput
    auditLogs?: AuditLogCreateNestedManyWithoutApplicationInput
  }

  export type JobApplicationUncheckedCreateWithoutJobInput = {
    id?: string
    applicantId?: string | null
    source?: $Enums.CandidateSource
    externalName?: string | null
    externalEmail?: string | null
    externalPhone?: string | null
    resumeUrl?: string | null
    coverLetter?: string | null
    resumeParsedText?: string | null
    atsScore?: number
    status?: $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interviews?: JobInterviewUncheckedCreateNestedManyWithoutApplicationInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutApplicationInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type JobApplicationCreateOrConnectWithoutJobInput = {
    where: JobApplicationWhereUniqueInput
    create: XOR<JobApplicationCreateWithoutJobInput, JobApplicationUncheckedCreateWithoutJobInput>
  }

  export type JobApplicationCreateManyJobInputEnvelope = {
    data: JobApplicationCreateManyJobInput | JobApplicationCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutJobsInput = {
    update: XOR<UserUpdateWithoutJobsInput, UserUncheckedUpdateWithoutJobsInput>
    create: XOR<UserCreateWithoutJobsInput, UserUncheckedCreateWithoutJobsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJobsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJobsInput, UserUncheckedUpdateWithoutJobsInput>
  }

  export type UserUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type JobApplicationUpsertWithWhereUniqueWithoutJobInput = {
    where: JobApplicationWhereUniqueInput
    update: XOR<JobApplicationUpdateWithoutJobInput, JobApplicationUncheckedUpdateWithoutJobInput>
    create: XOR<JobApplicationCreateWithoutJobInput, JobApplicationUncheckedCreateWithoutJobInput>
  }

  export type JobApplicationUpdateWithWhereUniqueWithoutJobInput = {
    where: JobApplicationWhereUniqueInput
    data: XOR<JobApplicationUpdateWithoutJobInput, JobApplicationUncheckedUpdateWithoutJobInput>
  }

  export type JobApplicationUpdateManyWithWhereWithoutJobInput = {
    where: JobApplicationScalarWhereInput
    data: XOR<JobApplicationUpdateManyMutationInput, JobApplicationUncheckedUpdateManyWithoutJobInput>
  }

  export type JobCreateWithoutApplicationsInput = {
    id?: string
    title: string
    description: string
    requirements?: string | null
    location: string
    type?: $Enums.JobType
    experience?: string | null
    salary?: string | null
    skills?: string | null
    clientName?: string | null
    shift?: string | null
    domain?: string | null
    qualification?: string | null
    status?: $Enums.JobStatus
    publishedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employer: UserCreateNestedOneWithoutJobsInput
  }

  export type JobUncheckedCreateWithoutApplicationsInput = {
    id?: string
    title: string
    description: string
    requirements?: string | null
    location: string
    type?: $Enums.JobType
    experience?: string | null
    salary?: string | null
    skills?: string | null
    clientName?: string | null
    shift?: string | null
    domain?: string | null
    qualification?: string | null
    employerId: string
    status?: $Enums.JobStatus
    publishedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobCreateOrConnectWithoutApplicationsInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutApplicationsInput, JobUncheckedCreateWithoutApplicationsInput>
  }

  export type UserCreateWithoutApplicationsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewCreateNestedManyWithoutInterviewerInput
  }

  export type UserUncheckedCreateWithoutApplicationsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
    conductedJobInterviews?: JobInterviewUncheckedCreateNestedManyWithoutInterviewerInput
  }

  export type UserCreateOrConnectWithoutApplicationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
  }

  export type JobInterviewCreateWithoutApplicationInput = {
    id?: string
    roundName: string
    roundType?: $Enums.InterviewRoundType
    scheduledAt: Date | string
    duration?: number
    meetingLink?: string | null
    location?: string | null
    status?: $Enums.InterviewStatus
    feedback?: string | null
    score?: number | null
    result?: $Enums.InterviewResult | null
    createdAt?: Date | string
    updatedAt?: Date | string
    interviewer: UserCreateNestedOneWithoutConductedJobInterviewsInput
  }

  export type JobInterviewUncheckedCreateWithoutApplicationInput = {
    id?: string
    roundName: string
    roundType?: $Enums.InterviewRoundType
    scheduledAt: Date | string
    duration?: number
    meetingLink?: string | null
    location?: string | null
    interviewerId: string
    status?: $Enums.InterviewStatus
    feedback?: string | null
    score?: number | null
    result?: $Enums.InterviewResult | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobInterviewCreateOrConnectWithoutApplicationInput = {
    where: JobInterviewWhereUniqueInput
    create: XOR<JobInterviewCreateWithoutApplicationInput, JobInterviewUncheckedCreateWithoutApplicationInput>
  }

  export type JobInterviewCreateManyApplicationInputEnvelope = {
    data: JobInterviewCreateManyApplicationInput | JobInterviewCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type EmailLogCreateWithoutApplicationInput = {
    id?: string
    jobId?: string | null
    recipientEmail: string
    recipientName?: string | null
    templateName: string
    subject: string
    body: string
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    error?: string | null
    triggeredBy?: string | null
  }

  export type EmailLogUncheckedCreateWithoutApplicationInput = {
    id?: string
    jobId?: string | null
    recipientEmail: string
    recipientName?: string | null
    templateName: string
    subject: string
    body: string
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    error?: string | null
    triggeredBy?: string | null
  }

  export type EmailLogCreateOrConnectWithoutApplicationInput = {
    where: EmailLogWhereUniqueInput
    create: XOR<EmailLogCreateWithoutApplicationInput, EmailLogUncheckedCreateWithoutApplicationInput>
  }

  export type EmailLogCreateManyApplicationInputEnvelope = {
    data: EmailLogCreateManyApplicationInput | EmailLogCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutApplicationInput = {
    id?: string
    entityType: string
    entityId?: string | null
    action: string
    method?: string | null
    path?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    performedBy: string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutApplicationInput = {
    id?: string
    entityType: string
    entityId?: string | null
    action: string
    method?: string | null
    path?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    performedBy: string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutApplicationInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutApplicationInput, AuditLogUncheckedCreateWithoutApplicationInput>
  }

  export type AuditLogCreateManyApplicationInputEnvelope = {
    data: AuditLogCreateManyApplicationInput | AuditLogCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type JobUpsertWithoutApplicationsInput = {
    update: XOR<JobUpdateWithoutApplicationsInput, JobUncheckedUpdateWithoutApplicationsInput>
    create: XOR<JobCreateWithoutApplicationsInput, JobUncheckedCreateWithoutApplicationsInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutApplicationsInput, JobUncheckedUpdateWithoutApplicationsInput>
  }

  export type JobUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employer?: UserUpdateOneRequiredWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    employerId?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutApplicationsInput = {
    update: XOR<UserUpdateWithoutApplicationsInput, UserUncheckedUpdateWithoutApplicationsInput>
    create: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApplicationsInput, UserUncheckedUpdateWithoutApplicationsInput>
  }

  export type UserUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type JobInterviewUpsertWithWhereUniqueWithoutApplicationInput = {
    where: JobInterviewWhereUniqueInput
    update: XOR<JobInterviewUpdateWithoutApplicationInput, JobInterviewUncheckedUpdateWithoutApplicationInput>
    create: XOR<JobInterviewCreateWithoutApplicationInput, JobInterviewUncheckedCreateWithoutApplicationInput>
  }

  export type JobInterviewUpdateWithWhereUniqueWithoutApplicationInput = {
    where: JobInterviewWhereUniqueInput
    data: XOR<JobInterviewUpdateWithoutApplicationInput, JobInterviewUncheckedUpdateWithoutApplicationInput>
  }

  export type JobInterviewUpdateManyWithWhereWithoutApplicationInput = {
    where: JobInterviewScalarWhereInput
    data: XOR<JobInterviewUpdateManyMutationInput, JobInterviewUncheckedUpdateManyWithoutApplicationInput>
  }

  export type EmailLogUpsertWithWhereUniqueWithoutApplicationInput = {
    where: EmailLogWhereUniqueInput
    update: XOR<EmailLogUpdateWithoutApplicationInput, EmailLogUncheckedUpdateWithoutApplicationInput>
    create: XOR<EmailLogCreateWithoutApplicationInput, EmailLogUncheckedCreateWithoutApplicationInput>
  }

  export type EmailLogUpdateWithWhereUniqueWithoutApplicationInput = {
    where: EmailLogWhereUniqueInput
    data: XOR<EmailLogUpdateWithoutApplicationInput, EmailLogUncheckedUpdateWithoutApplicationInput>
  }

  export type EmailLogUpdateManyWithWhereWithoutApplicationInput = {
    where: EmailLogScalarWhereInput
    data: XOR<EmailLogUpdateManyMutationInput, EmailLogUncheckedUpdateManyWithoutApplicationInput>
  }

  export type EmailLogScalarWhereInput = {
    AND?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
    OR?: EmailLogScalarWhereInput[]
    NOT?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
    id?: StringFilter<"EmailLog"> | string
    jobId?: StringNullableFilter<"EmailLog"> | string | null
    applicationId?: StringNullableFilter<"EmailLog"> | string | null
    recipientEmail?: StringFilter<"EmailLog"> | string
    recipientName?: StringNullableFilter<"EmailLog"> | string | null
    templateName?: StringFilter<"EmailLog"> | string
    subject?: StringFilter<"EmailLog"> | string
    body?: StringFilter<"EmailLog"> | string
    status?: EnumEmailStatusFilter<"EmailLog"> | $Enums.EmailStatus
    sentAt?: DateTimeFilter<"EmailLog"> | Date | string
    error?: StringNullableFilter<"EmailLog"> | string | null
    triggeredBy?: StringNullableFilter<"EmailLog"> | string | null
  }

  export type AuditLogUpsertWithWhereUniqueWithoutApplicationInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutApplicationInput, AuditLogUncheckedUpdateWithoutApplicationInput>
    create: XOR<AuditLogCreateWithoutApplicationInput, AuditLogUncheckedCreateWithoutApplicationInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutApplicationInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutApplicationInput, AuditLogUncheckedUpdateWithoutApplicationInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutApplicationInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutApplicationInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    method?: StringNullableFilter<"AuditLog"> | string | null
    path?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    oldValue?: JsonNullableFilter<"AuditLog">
    newValue?: JsonNullableFilter<"AuditLog">
    applicationId?: StringNullableFilter<"AuditLog"> | string | null
    performedBy?: StringFilter<"AuditLog"> | string
    details?: JsonNullableFilter<"AuditLog">
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type JobApplicationCreateWithoutInterviewsInput = {
    id?: string
    source?: $Enums.CandidateSource
    externalName?: string | null
    externalEmail?: string | null
    externalPhone?: string | null
    resumeUrl?: string | null
    coverLetter?: string | null
    resumeParsedText?: string | null
    atsScore?: number
    status?: $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    job: JobCreateNestedOneWithoutApplicationsInput
    applicant?: UserCreateNestedOneWithoutApplicationsInput
    emailLogs?: EmailLogCreateNestedManyWithoutApplicationInput
    auditLogs?: AuditLogCreateNestedManyWithoutApplicationInput
  }

  export type JobApplicationUncheckedCreateWithoutInterviewsInput = {
    id?: string
    jobId: string
    applicantId?: string | null
    source?: $Enums.CandidateSource
    externalName?: string | null
    externalEmail?: string | null
    externalPhone?: string | null
    resumeUrl?: string | null
    coverLetter?: string | null
    resumeParsedText?: string | null
    atsScore?: number
    status?: $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutApplicationInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type JobApplicationCreateOrConnectWithoutInterviewsInput = {
    where: JobApplicationWhereUniqueInput
    create: XOR<JobApplicationCreateWithoutInterviewsInput, JobApplicationUncheckedCreateWithoutInterviewsInput>
  }

  export type UserCreateWithoutConductedJobInterviewsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    interviews?: InterviewCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressCreateNestedManyWithoutUserInput
    posts?: ForumPostCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentCreateNestedManyWithoutAuthorInput
    conversations?: ConversationCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    tickets?: TicketCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileCreateNestedOneWithoutUserInput
    jobs?: JobCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentCreateNestedManyWithoutUserInput
    instructedBatches?: BatchCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementCreateNestedManyWithoutInstructorInput
  }

  export type UserUncheckedCreateWithoutConductedJobInterviewsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.Role
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    emailVerified?: boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    interviews?: InterviewUncheckedCreateNestedManyWithoutUserInput
    lessonProgress?: LessonProgressUncheckedCreateNestedManyWithoutUserInput
    posts?: ForumPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: ForumCommentUncheckedCreateNestedManyWithoutAuthorInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutParticipantsInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    tickets?: TicketUncheckedCreateNestedManyWithoutUserInput
    sentTicketMessages?: TicketMessageUncheckedCreateNestedManyWithoutUserInput
    employerProfile?: EmployerProfileUncheckedCreateNestedOneWithoutUserInput
    jobs?: JobUncheckedCreateNestedManyWithoutEmployerInput
    applications?: JobApplicationUncheckedCreateNestedManyWithoutApplicantInput
    assignedTasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    createdTasks?: TaskUncheckedCreateNestedManyWithoutCreatorInput
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutAuthorInput
    taskComments?: TaskCommentUncheckedCreateNestedManyWithoutUserInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutUserInput
    lessonComments?: LessonCommentUncheckedCreateNestedManyWithoutUserInput
    instructedBatches?: BatchUncheckedCreateNestedManyWithoutInstructorInput
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutInstructorInput
  }

  export type UserCreateOrConnectWithoutConductedJobInterviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConductedJobInterviewsInput, UserUncheckedCreateWithoutConductedJobInterviewsInput>
  }

  export type JobApplicationUpsertWithoutInterviewsInput = {
    update: XOR<JobApplicationUpdateWithoutInterviewsInput, JobApplicationUncheckedUpdateWithoutInterviewsInput>
    create: XOR<JobApplicationCreateWithoutInterviewsInput, JobApplicationUncheckedCreateWithoutInterviewsInput>
    where?: JobApplicationWhereInput
  }

  export type JobApplicationUpdateToOneWithWhereWithoutInterviewsInput = {
    where?: JobApplicationWhereInput
    data: XOR<JobApplicationUpdateWithoutInterviewsInput, JobApplicationUncheckedUpdateWithoutInterviewsInput>
  }

  export type JobApplicationUpdateWithoutInterviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumCandidateSourceFieldUpdateOperationsInput | $Enums.CandidateSource
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    externalPhone?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeParsedText?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: FloatFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutApplicationsNestedInput
    applicant?: UserUpdateOneWithoutApplicationsNestedInput
    emailLogs?: EmailLogUpdateManyWithoutApplicationNestedInput
    auditLogs?: AuditLogUpdateManyWithoutApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateWithoutInterviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    applicantId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumCandidateSourceFieldUpdateOperationsInput | $Enums.CandidateSource
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    externalPhone?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeParsedText?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: FloatFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailLogs?: EmailLogUncheckedUpdateManyWithoutApplicationNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type UserUpsertWithoutConductedJobInterviewsInput = {
    update: XOR<UserUpdateWithoutConductedJobInterviewsInput, UserUncheckedUpdateWithoutConductedJobInterviewsInput>
    create: XOR<UserCreateWithoutConductedJobInterviewsInput, UserUncheckedCreateWithoutConductedJobInterviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConductedJobInterviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConductedJobInterviewsInput, UserUncheckedUpdateWithoutConductedJobInterviewsInput>
  }

  export type UserUpdateWithoutConductedJobInterviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
  }

  export type UserUncheckedUpdateWithoutConductedJobInterviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutParticipantsNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
  }

  export type JobApplicationCreateWithoutEmailLogsInput = {
    id?: string
    source?: $Enums.CandidateSource
    externalName?: string | null
    externalEmail?: string | null
    externalPhone?: string | null
    resumeUrl?: string | null
    coverLetter?: string | null
    resumeParsedText?: string | null
    atsScore?: number
    status?: $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    job: JobCreateNestedOneWithoutApplicationsInput
    applicant?: UserCreateNestedOneWithoutApplicationsInput
    interviews?: JobInterviewCreateNestedManyWithoutApplicationInput
    auditLogs?: AuditLogCreateNestedManyWithoutApplicationInput
  }

  export type JobApplicationUncheckedCreateWithoutEmailLogsInput = {
    id?: string
    jobId: string
    applicantId?: string | null
    source?: $Enums.CandidateSource
    externalName?: string | null
    externalEmail?: string | null
    externalPhone?: string | null
    resumeUrl?: string | null
    coverLetter?: string | null
    resumeParsedText?: string | null
    atsScore?: number
    status?: $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interviews?: JobInterviewUncheckedCreateNestedManyWithoutApplicationInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type JobApplicationCreateOrConnectWithoutEmailLogsInput = {
    where: JobApplicationWhereUniqueInput
    create: XOR<JobApplicationCreateWithoutEmailLogsInput, JobApplicationUncheckedCreateWithoutEmailLogsInput>
  }

  export type JobApplicationUpsertWithoutEmailLogsInput = {
    update: XOR<JobApplicationUpdateWithoutEmailLogsInput, JobApplicationUncheckedUpdateWithoutEmailLogsInput>
    create: XOR<JobApplicationCreateWithoutEmailLogsInput, JobApplicationUncheckedCreateWithoutEmailLogsInput>
    where?: JobApplicationWhereInput
  }

  export type JobApplicationUpdateToOneWithWhereWithoutEmailLogsInput = {
    where?: JobApplicationWhereInput
    data: XOR<JobApplicationUpdateWithoutEmailLogsInput, JobApplicationUncheckedUpdateWithoutEmailLogsInput>
  }

  export type JobApplicationUpdateWithoutEmailLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumCandidateSourceFieldUpdateOperationsInput | $Enums.CandidateSource
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    externalPhone?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeParsedText?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: FloatFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutApplicationsNestedInput
    applicant?: UserUpdateOneWithoutApplicationsNestedInput
    interviews?: JobInterviewUpdateManyWithoutApplicationNestedInput
    auditLogs?: AuditLogUpdateManyWithoutApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateWithoutEmailLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    applicantId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumCandidateSourceFieldUpdateOperationsInput | $Enums.CandidateSource
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    externalPhone?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeParsedText?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: FloatFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interviews?: JobInterviewUncheckedUpdateManyWithoutApplicationNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type JobApplicationCreateWithoutAuditLogsInput = {
    id?: string
    source?: $Enums.CandidateSource
    externalName?: string | null
    externalEmail?: string | null
    externalPhone?: string | null
    resumeUrl?: string | null
    coverLetter?: string | null
    resumeParsedText?: string | null
    atsScore?: number
    status?: $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    job: JobCreateNestedOneWithoutApplicationsInput
    applicant?: UserCreateNestedOneWithoutApplicationsInput
    interviews?: JobInterviewCreateNestedManyWithoutApplicationInput
    emailLogs?: EmailLogCreateNestedManyWithoutApplicationInput
  }

  export type JobApplicationUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    jobId: string
    applicantId?: string | null
    source?: $Enums.CandidateSource
    externalName?: string | null
    externalEmail?: string | null
    externalPhone?: string | null
    resumeUrl?: string | null
    coverLetter?: string | null
    resumeParsedText?: string | null
    atsScore?: number
    status?: $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interviews?: JobInterviewUncheckedCreateNestedManyWithoutApplicationInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type JobApplicationCreateOrConnectWithoutAuditLogsInput = {
    where: JobApplicationWhereUniqueInput
    create: XOR<JobApplicationCreateWithoutAuditLogsInput, JobApplicationUncheckedCreateWithoutAuditLogsInput>
  }

  export type JobApplicationUpsertWithoutAuditLogsInput = {
    update: XOR<JobApplicationUpdateWithoutAuditLogsInput, JobApplicationUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<JobApplicationCreateWithoutAuditLogsInput, JobApplicationUncheckedCreateWithoutAuditLogsInput>
    where?: JobApplicationWhereInput
  }

  export type JobApplicationUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: JobApplicationWhereInput
    data: XOR<JobApplicationUpdateWithoutAuditLogsInput, JobApplicationUncheckedUpdateWithoutAuditLogsInput>
  }

  export type JobApplicationUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumCandidateSourceFieldUpdateOperationsInput | $Enums.CandidateSource
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    externalPhone?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeParsedText?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: FloatFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutApplicationsNestedInput
    applicant?: UserUpdateOneWithoutApplicationsNestedInput
    interviews?: JobInterviewUpdateManyWithoutApplicationNestedInput
    emailLogs?: EmailLogUpdateManyWithoutApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    applicantId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumCandidateSourceFieldUpdateOperationsInput | $Enums.CandidateSource
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    externalPhone?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeParsedText?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: FloatFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interviews?: JobInterviewUncheckedUpdateManyWithoutApplicationNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type EnrollmentCreateManyUserInput = {
    id?: string
    courseId: string
    progress?: number
    status?: $Enums.EnrollmentStatus
    hasInterviewAccess?: boolean
    batchId?: string | null
    enrolledAt?: Date | string
    completedAt?: Date | string | null
  }

  export type InterviewCreateManyUserInput = {
    id?: string
    domain: string
    company?: string | null
    role: string
    technology?: string | null
    jobDescription?: string | null
    resumeUrl?: string | null
    difficulty?: $Enums.Difficulty
    panelCount?: number
    linkedCourseId?: string | null
    duration?: number
    selectedAvatars?: InterviewCreateselectedAvatarsInput | string[]
    status?: $Enums.InterviewStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type LessonProgressCreateManyUserInput = {
    id?: string
    lessonId: string
    completed?: boolean
    score?: number | null
    timeSpent?: number
    lastAccessedAt?: Date | string
  }

  export type ForumPostCreateManyAuthorInput = {
    id?: string
    title: string
    content: string
    slug: string
    categoryId: string
    likes?: number
    views?: number
    isPinned?: boolean
    isSolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCommentCreateManyAuthorInput = {
    id?: string
    content: string
    postId: string
    parentId?: string | null
    isSolution?: boolean
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    conversationId: string
    content: string
    readBy?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    orderId: string
    paymentId?: string | null
    signature?: string | null
    amount: number
    currency?: string
    status?: string
    courseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateCreateManyUserInput = {
    id?: string
    uniqueId: string
    courseId: string
    enrollmentId: string
    studentName: string
    courseName: string
    courseCategory?: string | null
    issueDate?: Date | string
    expiryDate?: Date | string | null
    templateId?: string | null
    signatureUrl?: string | null
    signatoryName?: string | null
    signatoryTitle?: string | null
    verificationUrl?: string | null
    isValid?: boolean
    grade?: string | null
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyUserInput = {
    id?: string
    courseId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateManyUserInput = {
    id?: string
    subject: string
    description: string
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    category?: $Enums.TicketCategory
    assignedTo?: string | null
    internalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketMessageCreateManyUserInput = {
    id?: string
    message: string
    attachmentUrl?: string | null
    isStaffReply?: boolean
    ticketId: string
    createdAt?: Date | string
  }

  export type JobCreateManyEmployerInput = {
    id?: string
    title: string
    description: string
    requirements?: string | null
    location: string
    type?: $Enums.JobType
    experience?: string | null
    salary?: string | null
    skills?: string | null
    clientName?: string | null
    shift?: string | null
    domain?: string | null
    qualification?: string | null
    status?: $Enums.JobStatus
    publishedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobApplicationCreateManyApplicantInput = {
    id?: string
    jobId: string
    source?: $Enums.CandidateSource
    externalName?: string | null
    externalEmail?: string | null
    externalPhone?: string | null
    resumeUrl?: string | null
    coverLetter?: string | null
    resumeParsedText?: string | null
    atsScore?: number
    status?: $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    createdBy?: string | null
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyCreatorInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    assignedTo?: string | null
    leadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogPostCreateManyAuthorInput = {
    id?: string
    title: string
    slug: string
    content: string
    summary?: string | null
    coverImage?: string | null
    status?: $Enums.BlogStatus
    tags?: NullableJsonNullValueInput | InputJsonValue
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCommentCreateManyUserInput = {
    id?: string
    content: string
    taskId: string
    createdAt?: Date | string
  }

  export type AssignmentSubmissionCreateManyUserInput = {
    id?: string
    lessonId: string
    content?: string | null
    fileUrl?: string | null
    grade?: number | null
    feedback?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonCommentCreateManyUserInput = {
    id?: string
    lessonId: string
    content: string
    parentId?: string | null
    isPinned?: boolean
    isInstructorResponse?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchCreateManyInstructorInput = {
    id?: string
    name: string
    courseId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    description?: string | null
    maxStudents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementCreateManyInstructorInput = {
    id?: string
    title: string
    content: string
    priority?: string
    courseId?: string | null
    batchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobInterviewCreateManyInterviewerInput = {
    id?: string
    applicationId: string
    roundName: string
    roundType?: $Enums.InterviewRoundType
    scheduledAt: Date | string
    duration?: number
    meetingLink?: string | null
    location?: string | null
    status?: $Enums.InterviewStatus
    feedback?: string | null
    score?: number | null
    result?: $Enums.InterviewResult | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    hasInterviewAccess?: BoolFieldUpdateOperationsInput | boolean
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
    batch?: BatchUpdateOneWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    hasInterviewAccess?: BoolFieldUpdateOperationsInput | boolean
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnrollmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    hasInterviewAccess?: BoolFieldUpdateOperationsInput | boolean
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InterviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    technology?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    panelCount?: IntFieldUpdateOperationsInput | number
    linkedCourseId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    selectedAvatars?: InterviewUpdateselectedAvatarsInput | string[]
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: InterviewQuestionUpdateManyWithoutInterviewNestedInput
    responses?: InterviewResponseUpdateManyWithoutInterviewNestedInput
    evaluation?: InterviewEvaluationUpdateOneWithoutInterviewNestedInput
  }

  export type InterviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    technology?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    panelCount?: IntFieldUpdateOperationsInput | number
    linkedCourseId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    selectedAvatars?: InterviewUpdateselectedAvatarsInput | string[]
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: InterviewQuestionUncheckedUpdateManyWithoutInterviewNestedInput
    responses?: InterviewResponseUncheckedUpdateManyWithoutInterviewNestedInput
    evaluation?: InterviewEvaluationUncheckedUpdateOneWithoutInterviewNestedInput
  }

  export type InterviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    technology?: NullableStringFieldUpdateOperationsInput | string | null
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: EnumDifficultyFieldUpdateOperationsInput | $Enums.Difficulty
    panelCount?: IntFieldUpdateOperationsInput | number
    linkedCourseId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    selectedAvatars?: InterviewUpdateselectedAvatarsInput | string[]
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpent?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutProgressNestedInput
  }

  export type LessonProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpent?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonProgressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpent?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isSolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ForumCategoryUpdateOneRequiredWithoutPostsNestedInput
    comments?: ForumCommentUpdateManyWithoutPostNestedInput
  }

  export type ForumPostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isSolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ForumCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ForumPostUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isSolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isSolution?: BoolFieldUpdateOperationsInput | boolean
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: ForumPostUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type ForumCommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isSolution?: BoolFieldUpdateOperationsInput | boolean
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isSolution?: BoolFieldUpdateOperationsInput | boolean
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    readBy?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    readBy?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    readBy?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    courseName?: StringFieldUpdateOperationsInput | string
    courseCategory?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatoryName?: NullableStringFieldUpdateOperationsInput | string | null
    signatoryTitle?: NullableStringFieldUpdateOperationsInput | string | null
    verificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: CertificateTemplateUpdateOneWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    courseName?: StringFieldUpdateOperationsInput | string
    courseCategory?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatoryName?: NullableStringFieldUpdateOperationsInput | string | null
    signatoryTitle?: NullableStringFieldUpdateOperationsInput | string | null
    verificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    courseName?: StringFieldUpdateOperationsInput | string
    courseCategory?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatoryName?: NullableStringFieldUpdateOperationsInput | string | null
    signatoryTitle?: NullableStringFieldUpdateOperationsInput | string | null
    verificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: TicketMessageUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: TicketMessageUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    category?: EnumTicketCategoryFieldUpdateOperationsInput | $Enums.TicketCategory
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isStaffReply?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type TicketMessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isStaffReply?: BoolFieldUpdateOperationsInput | boolean
    ticketId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isStaffReply?: BoolFieldUpdateOperationsInput | boolean
    ticketId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobUpdateWithoutEmployerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: JobApplicationUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutEmployerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: JobApplicationUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateManyWithoutEmployerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    shift?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobApplicationUpdateWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumCandidateSourceFieldUpdateOperationsInput | $Enums.CandidateSource
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    externalPhone?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeParsedText?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: FloatFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutApplicationsNestedInput
    interviews?: JobInterviewUpdateManyWithoutApplicationNestedInput
    emailLogs?: EmailLogUpdateManyWithoutApplicationNestedInput
    auditLogs?: AuditLogUpdateManyWithoutApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    source?: EnumCandidateSourceFieldUpdateOperationsInput | $Enums.CandidateSource
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    externalPhone?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeParsedText?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: FloatFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interviews?: JobInterviewUncheckedUpdateManyWithoutApplicationNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutApplicationNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateManyWithoutApplicantInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    source?: EnumCandidateSourceFieldUpdateOperationsInput | $Enums.CandidateSource
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    externalPhone?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeParsedText?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: FloatFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutCreatedTasksNestedInput
    lead?: LeadUpdateOneWithoutTasksNestedInput
    comments?: TaskCommentUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: TaskCommentUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignee?: UserUpdateOneWithoutAssignedTasksNestedInput
    lead?: LeadUpdateOneWithoutTasksNestedInput
    comments?: TaskCommentUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: TaskCommentUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBlogStatusFieldUpdateOperationsInput | $Enums.BlogStatus
    tags?: NullableJsonNullValueInput | InputJsonValue
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBlogStatusFieldUpdateOperationsInput | $Enums.BlogStatus
    tags?: NullableJsonNullValueInput | InputJsonValue
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBlogStatusFieldUpdateOperationsInput | $Enums.BlogStatus
    tags?: NullableJsonNullValueInput | InputJsonValue
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type TaskCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentSubmissionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutAssignmentSubmissionsNestedInput
  }

  export type AssignmentSubmissionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentSubmissionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isInstructorResponse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutCommentsNestedInput
    parent?: LessonCommentUpdateOneWithoutRepliesNestedInput
    replies?: LessonCommentUpdateManyWithoutParentNestedInput
  }

  export type LessonCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isInstructorResponse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: LessonCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type LessonCommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isInstructorResponse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchUpdateWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutBatchesNestedInput
    announcements?: AnnouncementUpdateManyWithoutBatchNestedInput
    enrollments?: EnrollmentUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    announcements?: AnnouncementUncheckedUpdateManyWithoutBatchNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUpdateWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneWithoutAnnouncementsNestedInput
    batch?: BatchUpdateOneWithoutAnnouncementsNestedInput
  }

  export type AnnouncementUncheckedUpdateWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobInterviewUpdateWithoutInterviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    roundName?: StringFieldUpdateOperationsInput | string
    roundType?: EnumInterviewRoundTypeFieldUpdateOperationsInput | $Enums.InterviewRoundType
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableEnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: JobApplicationUpdateOneRequiredWithoutInterviewsNestedInput
  }

  export type JobInterviewUncheckedUpdateWithoutInterviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    roundName?: StringFieldUpdateOperationsInput | string
    roundType?: EnumInterviewRoundTypeFieldUpdateOperationsInput | $Enums.InterviewRoundType
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableEnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobInterviewUncheckedUpdateManyWithoutInterviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    roundName?: StringFieldUpdateOperationsInput | string
    roundType?: EnumInterviewRoundTypeFieldUpdateOperationsInput | $Enums.InterviewRoundType
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableEnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleCreateManyCourseInput = {
    id?: string
    title: string
    description?: string | null
    orderIndex: number
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentCreateManyCourseInput = {
    id?: string
    userId: string
    progress?: number
    status?: $Enums.EnrollmentStatus
    hasInterviewAccess?: boolean
    batchId?: string | null
    enrolledAt?: Date | string
    completedAt?: Date | string | null
  }

  export type PaymentCreateManyCourseInput = {
    id?: string
    orderId: string
    paymentId?: string | null
    signature?: string | null
    amount: number
    currency?: string
    status?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyCourseInput = {
    id?: string
    userId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiveClassCreateManyCourseInput = {
    id?: string
    title: string
    description?: string | null
    platform: string
    meetingLink?: string | null
    meetingId?: string | null
    password?: string | null
    scheduledAt: Date | string
    duration: number
    timezone?: string
    status?: $Enums.LiveClassStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    recordingUrl?: string | null
    recordingPassword?: string | null
    hostId?: string | null
    hostName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchCreateManyCourseInput = {
    id?: string
    name: string
    instructorId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    description?: string | null
    maxStudents?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementCreateManyCourseInput = {
    id?: string
    title: string
    content: string
    priority?: string
    batchId?: string | null
    instructorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessons?: LessonUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    hasInterviewAccess?: BoolFieldUpdateOperationsInput | boolean
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutEnrollmentsNestedInput
    batch?: BatchUpdateOneWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    hasInterviewAccess?: BoolFieldUpdateOperationsInput | boolean
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnrollmentUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    hasInterviewAccess?: BoolFieldUpdateOperationsInput | boolean
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiveClassUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    status?: EnumLiveClassStatusFieldUpdateOperationsInput | $Enums.LiveClassStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hostId?: NullableStringFieldUpdateOperationsInput | string | null
    hostName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiveClassUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    status?: EnumLiveClassStatusFieldUpdateOperationsInput | $Enums.LiveClassStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hostId?: NullableStringFieldUpdateOperationsInput | string | null
    hostName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiveClassUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: StringFieldUpdateOperationsInput | string
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    status?: EnumLiveClassStatusFieldUpdateOperationsInput | $Enums.LiveClassStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingPassword?: NullableStringFieldUpdateOperationsInput | string | null
    hostId?: NullableStringFieldUpdateOperationsInput | string | null
    hostName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: UserUpdateOneRequiredWithoutInstructedBatchesNestedInput
    announcements?: AnnouncementUpdateManyWithoutBatchNestedInput
    enrollments?: EnrollmentUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    announcements?: AnnouncementUncheckedUpdateManyWithoutBatchNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    instructorId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: BatchUpdateOneWithoutAnnouncementsNestedInput
    instructor?: UserUpdateOneRequiredWithoutAnnouncementsNestedInput
  }

  export type AnnouncementUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementCreateManyBatchInput = {
    id?: string
    title: string
    content: string
    priority?: string
    courseId?: string | null
    instructorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentCreateManyBatchInput = {
    id?: string
    userId: string
    courseId: string
    progress?: number
    status?: $Enums.EnrollmentStatus
    hasInterviewAccess?: boolean
    enrolledAt?: Date | string
    completedAt?: Date | string | null
  }

  export type AnnouncementUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneWithoutAnnouncementsNestedInput
    instructor?: UserUpdateOneRequiredWithoutAnnouncementsNestedInput
  }

  export type AnnouncementUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    hasInterviewAccess?: BoolFieldUpdateOperationsInput | boolean
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutEnrollmentsNestedInput
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    hasInterviewAccess?: BoolFieldUpdateOperationsInput | boolean
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnrollmentUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    status?: EnumEnrollmentStatusFieldUpdateOperationsInput | $Enums.EnrollmentStatus
    hasInterviewAccess?: BoolFieldUpdateOperationsInput | boolean
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonCommentCreateManyParentInput = {
    id?: string
    lessonId: string
    userId: string
    content: string
    isPinned?: boolean
    isInstructorResponse?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonCommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isInstructorResponse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutLessonCommentsNestedInput
    replies?: LessonCommentUpdateManyWithoutParentNestedInput
  }

  export type LessonCommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isInstructorResponse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: LessonCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type LessonCommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isInstructorResponse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCreateManyModuleInput = {
    id?: string
    title: string
    content?: string | null
    videoUrl?: string | null
    duration?: number | null
    order: number
    type?: $Enums.LessonType
    isPublished?: boolean
    isPreview?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizzes?: QuizUpdateManyWithoutLessonNestedInput
    progress?: LessonProgressUpdateManyWithoutLessonNestedInput
    comments?: LessonCommentUpdateManyWithoutLessonNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizzes?: QuizUncheckedUpdateManyWithoutLessonNestedInput
    progress?: LessonProgressUncheckedUpdateManyWithoutLessonNestedInput
    comments?: LessonCommentUncheckedUpdateManyWithoutLessonNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    isPreview?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    resources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCreateManyLessonInput = {
    id?: string
    question: string
    options: JsonNullValueInput | InputJsonValue
    correctAnswer: string
    explanation?: string | null
    createdAt?: Date | string
  }

  export type LessonProgressCreateManyLessonInput = {
    id?: string
    userId: string
    completed?: boolean
    score?: number | null
    timeSpent?: number
    lastAccessedAt?: Date | string
  }

  export type LessonCommentCreateManyLessonInput = {
    id?: string
    userId: string
    content: string
    parentId?: string | null
    isPinned?: boolean
    isInstructorResponse?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentSubmissionCreateManyLessonInput = {
    id?: string
    userId: string
    content?: string | null
    fileUrl?: string | null
    grade?: number | null
    feedback?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonProgressUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpent?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLessonProgressNestedInput
  }

  export type LessonProgressUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpent?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonProgressUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableIntFieldUpdateOperationsInput | number | null
    timeSpent?: IntFieldUpdateOperationsInput | number
    lastAccessedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCommentUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isInstructorResponse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLessonCommentsNestedInput
    parent?: LessonCommentUpdateOneWithoutRepliesNestedInput
    replies?: LessonCommentUpdateManyWithoutParentNestedInput
  }

  export type LessonCommentUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isInstructorResponse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: LessonCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type LessonCommentUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isInstructorResponse?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentSubmissionUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAssignmentSubmissionsNestedInput
  }

  export type AssignmentSubmissionUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentSubmissionUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewQuestionCreateManyInterviewInput = {
    id?: string
    avatarId?: string | null
    question: string
    type: $Enums.QuestionType
    order: number
  }

  export type InterviewResponseCreateManyInterviewInput = {
    id?: string
    questionId: string
    transcript?: string | null
    code?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    duration?: number | null
    respondedAt?: Date | string
  }

  export type InterviewQuestionUpdateWithoutInterviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatarId?: NullableStringFieldUpdateOperationsInput | string | null
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    order?: IntFieldUpdateOperationsInput | number
    response?: InterviewResponseUpdateOneWithoutQuestionNestedInput
  }

  export type InterviewQuestionUncheckedUpdateWithoutInterviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatarId?: NullableStringFieldUpdateOperationsInput | string | null
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    order?: IntFieldUpdateOperationsInput | number
    response?: InterviewResponseUncheckedUpdateOneWithoutQuestionNestedInput
  }

  export type InterviewQuestionUncheckedUpdateManyWithoutInterviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatarId?: NullableStringFieldUpdateOperationsInput | string | null
    question?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    order?: IntFieldUpdateOperationsInput | number
  }

  export type InterviewResponseUpdateWithoutInterviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: InterviewQuestionUpdateOneRequiredWithoutResponseNestedInput
  }

  export type InterviewResponseUncheckedUpdateWithoutInterviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewResponseUncheckedUpdateManyWithoutInterviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostCreateManyCategoryInput = {
    id?: string
    title: string
    content: string
    slug: string
    authorId: string
    likes?: number
    views?: number
    isPinned?: boolean
    isSolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumPostUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isSolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    comments?: ForumCommentUpdateManyWithoutPostNestedInput
  }

  export type ForumPostUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isSolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ForumCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ForumPostUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    isSolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentCreateManyPostInput = {
    id?: string
    content: string
    authorId: string
    parentId?: string | null
    isSolution?: boolean
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isSolution?: BoolFieldUpdateOperationsInput | boolean
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type ForumCommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isSolution?: BoolFieldUpdateOperationsInput | boolean
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isSolution?: BoolFieldUpdateOperationsInput | boolean
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    senderId: string
    content: string
    readBy?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UserUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    interviews?: InterviewUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUpdateManyWithoutUserNestedInput
    posts?: ForumPostUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUpdateManyWithoutAuthorNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    tickets?: TicketUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUpdateOneWithoutUserNestedInput
    jobs?: JobUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    interviews?: InterviewUncheckedUpdateManyWithoutUserNestedInput
    lessonProgress?: LessonProgressUncheckedUpdateManyWithoutUserNestedInput
    posts?: ForumPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: ForumCommentUncheckedUpdateManyWithoutAuthorNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutUserNestedInput
    sentTicketMessages?: TicketMessageUncheckedUpdateManyWithoutUserNestedInput
    employerProfile?: EmployerProfileUncheckedUpdateOneWithoutUserNestedInput
    jobs?: JobUncheckedUpdateManyWithoutEmployerNestedInput
    applications?: JobApplicationUncheckedUpdateManyWithoutApplicantNestedInput
    assignedTasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    createdTasks?: TaskUncheckedUpdateManyWithoutCreatorNestedInput
    blogPosts?: BlogPostUncheckedUpdateManyWithoutAuthorNestedInput
    taskComments?: TaskCommentUncheckedUpdateManyWithoutUserNestedInput
    assignmentSubmissions?: AssignmentSubmissionUncheckedUpdateManyWithoutUserNestedInput
    lessonComments?: LessonCommentUncheckedUpdateManyWithoutUserNestedInput
    instructedBatches?: BatchUncheckedUpdateManyWithoutInstructorNestedInput
    announcements?: AnnouncementUncheckedUpdateManyWithoutInstructorNestedInput
    conductedJobInterviews?: JobInterviewUncheckedUpdateManyWithoutInterviewerNestedInput
  }

  export type UserUncheckedUpdateManyWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    readBy?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    readBy?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    readBy?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateCreateManyTemplateInput = {
    id?: string
    uniqueId: string
    userId: string
    courseId: string
    enrollmentId: string
    studentName: string
    courseName: string
    courseCategory?: string | null
    issueDate?: Date | string
    expiryDate?: Date | string | null
    signatureUrl?: string | null
    signatoryName?: string | null
    signatoryTitle?: string | null
    verificationUrl?: string | null
    isValid?: boolean
    grade?: string | null
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    courseName?: StringFieldUpdateOperationsInput | string
    courseCategory?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatoryName?: NullableStringFieldUpdateOperationsInput | string | null
    signatoryTitle?: NullableStringFieldUpdateOperationsInput | string | null
    verificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    courseName?: StringFieldUpdateOperationsInput | string
    courseCategory?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatoryName?: NullableStringFieldUpdateOperationsInput | string | null
    signatoryTitle?: NullableStringFieldUpdateOperationsInput | string | null
    verificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uniqueId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrollmentId?: StringFieldUpdateOperationsInput | string
    studentName?: StringFieldUpdateOperationsInput | string
    courseName?: StringFieldUpdateOperationsInput | string
    courseCategory?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    signatoryName?: NullableStringFieldUpdateOperationsInput | string | null
    signatoryTitle?: NullableStringFieldUpdateOperationsInput | string | null
    verificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyLeadInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    priority?: $Enums.Priority
    dueDate?: Date | string | null
    assignedTo?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignee?: UserUpdateOneWithoutAssignedTasksNestedInput
    creator?: UserUpdateOneWithoutCreatedTasksNestedInput
    comments?: TaskCommentUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: TaskCommentUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCommentCreateManyTaskInput = {
    id?: string
    content: string
    userId: string
    createdAt?: Date | string
  }

  export type TaskCommentUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTaskCommentsNestedInput
  }

  export type TaskCommentUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCommentUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMessageCreateManyTicketInput = {
    id?: string
    message: string
    attachmentUrl?: string | null
    isStaffReply?: boolean
    createdAt?: Date | string
    userId?: string | null
  }

  export type TicketMessageUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isStaffReply?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSentTicketMessagesNestedInput
  }

  export type TicketMessageUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isStaffReply?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketMessageUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    attachmentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isStaffReply?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobApplicationCreateManyJobInput = {
    id?: string
    applicantId?: string | null
    source?: $Enums.CandidateSource
    externalName?: string | null
    externalEmail?: string | null
    externalPhone?: string | null
    resumeUrl?: string | null
    coverLetter?: string | null
    resumeParsedText?: string | null
    atsScore?: number
    status?: $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobApplicationUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: EnumCandidateSourceFieldUpdateOperationsInput | $Enums.CandidateSource
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    externalPhone?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeParsedText?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: FloatFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant?: UserUpdateOneWithoutApplicationsNestedInput
    interviews?: JobInterviewUpdateManyWithoutApplicationNestedInput
    emailLogs?: EmailLogUpdateManyWithoutApplicationNestedInput
    auditLogs?: AuditLogUpdateManyWithoutApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumCandidateSourceFieldUpdateOperationsInput | $Enums.CandidateSource
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    externalPhone?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeParsedText?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: FloatFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interviews?: JobInterviewUncheckedUpdateManyWithoutApplicationNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutApplicationNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type JobApplicationUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumCandidateSourceFieldUpdateOperationsInput | $Enums.CandidateSource
    externalName?: NullableStringFieldUpdateOperationsInput | string | null
    externalEmail?: NullableStringFieldUpdateOperationsInput | string | null
    externalPhone?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeParsedText?: NullableStringFieldUpdateOperationsInput | string | null
    atsScore?: FloatFieldUpdateOperationsInput | number
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    statusHistory?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobInterviewCreateManyApplicationInput = {
    id?: string
    roundName: string
    roundType?: $Enums.InterviewRoundType
    scheduledAt: Date | string
    duration?: number
    meetingLink?: string | null
    location?: string | null
    interviewerId: string
    status?: $Enums.InterviewStatus
    feedback?: string | null
    score?: number | null
    result?: $Enums.InterviewResult | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailLogCreateManyApplicationInput = {
    id?: string
    jobId?: string | null
    recipientEmail: string
    recipientName?: string | null
    templateName: string
    subject: string
    body: string
    status?: $Enums.EmailStatus
    sentAt?: Date | string
    error?: string | null
    triggeredBy?: string | null
  }

  export type AuditLogCreateManyApplicationInput = {
    id?: string
    entityType: string
    entityId?: string | null
    action: string
    method?: string | null
    path?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    performedBy: string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type JobInterviewUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roundName?: StringFieldUpdateOperationsInput | string
    roundType?: EnumInterviewRoundTypeFieldUpdateOperationsInput | $Enums.InterviewRoundType
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableEnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interviewer?: UserUpdateOneRequiredWithoutConductedJobInterviewsNestedInput
  }

  export type JobInterviewUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roundName?: StringFieldUpdateOperationsInput | string
    roundType?: EnumInterviewRoundTypeFieldUpdateOperationsInput | $Enums.InterviewRoundType
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    interviewerId?: StringFieldUpdateOperationsInput | string
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableEnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobInterviewUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roundName?: StringFieldUpdateOperationsInput | string
    roundType?: EnumInterviewRoundTypeFieldUpdateOperationsInput | $Enums.InterviewRoundType
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    interviewerId?: StringFieldUpdateOperationsInput | string
    status?: EnumInterviewStatusFieldUpdateOperationsInput | $Enums.InterviewStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    result?: NullableEnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    templateName?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailLogUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    templateName?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailLogUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    recipientEmail?: StringFieldUpdateOperationsInput | string
    recipientName?: NullableStringFieldUpdateOperationsInput | string | null
    templateName?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumEmailStatusFieldUpdateOperationsInput | $Enums.EmailStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    performedBy?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    performedBy?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    performedBy?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}